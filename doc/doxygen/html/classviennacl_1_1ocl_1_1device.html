<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: device Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1ocl.html">ocl</a>      </li>
      <li class="navelem"><a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">device Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="viennacl::ocl::device" -->
<p>A class representing a compute device (e.g. a GPU)  
 <a href="classviennacl_1_1ocl_1_1device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="device_8hpp_source.html">device.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#aa6214b6ab6f2d943669af7dd76cef3a2">device</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a17858dabba4d274000c38bc42de8487c">device</a> (cl_device_id dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a58ac501d01e9cb8eac21a831e8f0874c">device</a> (const <a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a8309715ac80d84b3d33928d7447b5258">address_bits</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default compute device address space size specified as an unsigned integer value in bits. Currently supported values are 32 or 64 bits.  <a href="#a8309715ac80d84b3d33928d7447b5258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a8f220d225a572fc920524892902aac60">available</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is CL_TRUE if the device is available and CL_FALSE if the device is not available.  <a href="#a8f220d225a572fc920524892902aac60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a8f365008733eabcd519578beb099b0d7">compiler_available</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is CL_FALSE if the implementation does not have a compiler available to compile the program source. Is CL_TRUE if the compiler is available. This can be CL_FALSE for the embedded platform profile only.  <a href="#a8f365008733eabcd519578beb099b0d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a186dc1deea58169fb2044c13e952bf0b">endian_little</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is CL_TRUE if the OpenCL device is a little endian device and CL_FALSE otherwise.  <a href="#a186dc1deea58169fb2044c13e952bf0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ac11837beee79843ef898d9cf12652474">error_correction_support</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is CL_TRUE if the device implements error correction for all accesses to compute device memory (global and constant) and CL_FALSE otherwise.  <a href="#ac11837beee79843ef898d9cf12652474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_device_exec_capabilities&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a2ce02d6139f3833916c66fdd883b6a8d">execution_capabilities</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the execution capabilities of the device.  <a href="#a2ce02d6139f3833916c66fdd883b6a8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378">extensions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a space-separated list of extension names (the extension names themselves do not contain any spaces).  <a href="#a13c05d46e01b83a17a635e4873ad8378"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad1fc58e70bbf8de4ce006f2b20fe5247">global_mem_cache_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of global memory cache in bytes.  <a href="#ad1fc58e70bbf8de4ce006f2b20fe5247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_device_mem_cache_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ae4afa4cd9be93609dbd0bb79345368e4">global_mem_cache_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of global memory cache supported. Valid values are: CL_NONE, CL_READ_ONLY_CACHE, and CL_READ_WRITE_CACHE.  <a href="#ae4afa4cd9be93609dbd0bb79345368e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a6c21e467f78c1a7a37d51a303729d5a2">global_mem_cacheline_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of global memory cache in bytes.  <a href="#a6c21e467f78c1a7a37d51a303729d5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad45acc1aefd8535b948f28cbdc11f1c9">global_mem_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of global memory in bytes.  <a href="#ad45acc1aefd8535b948f28cbdc11f1c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#af6a152b64e7f80a18df3aafc9303e4bd">image_support</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is CL_TRUE if the device and the host have a unified memory subsystem and is CL_FALSE otherwise.  <a href="#af6a152b64e7f80a18df3aafc9303e4bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a27c69153da9c199b28607cd6fe539720">image2d_max_height</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max height of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#a27c69153da9c199b28607cd6fe539720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a891f1c8a5008296e36c5243c6b553157">image2d_max_width</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max width of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#a891f1c8a5008296e36c5243c6b553157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#acd51b91e6ef23771cb6f5f5bfddac634">image3d_max_depth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max depth of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#acd51b91e6ef23771cb6f5f5bfddac634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a1350aeecc36ebcecc7535695117f87fe">image3d_max_height</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max height of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#a1350aeecc36ebcecc7535695117f87fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad1e0b838ced23bfd058a80b64af96281">image3d_max_width</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max width of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#ad1e0b838ced23bfd058a80b64af96281"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a089c660aee310ef2c01aa5171239f7de">local_mem_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of local memory arena in bytes. The minimum value is 32 KB.  <a href="#a089c660aee310ef2c01aa5171239f7de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_device_local_mem_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a8091787f68d0b4fec54982ac60ff0e58">local_mem_type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of local memory supported. This can be set to CL_LOCAL implying dedicated local memory storage such as SRAM, or CL_GLOBAL.  <a href="#a8091787f68d0b4fec54982ac60ff0e58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ab3f87b373439a4d280102b3323a3646c">max_clock_frequency</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum configured clock frequency of the device in MHz.  <a href="#ab3f87b373439a4d280102b3323a3646c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ab2a44bd7f2d691fa15460928af757d99">max_compute_units</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of parallel compute cores on the OpenCL device. The minimum value is 1.  <a href="#ab2a44bd7f2d691fa15460928af757d99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a692f1cbba0e5ec45a36546e7d3566b17">max_constant_args</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of arguments declared with the __constant qualifier in a kernel. The minimum value is 8.  <a href="#a692f1cbba0e5ec45a36546e7d3566b17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#aa2d0aa7e89b3bd75bf363f427bb8cf05">max_constant_buffer_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max size in bytes of a constant buffer allocation. The minimum value is 64 KB.  <a href="#aa2d0aa7e89b3bd75bf363f427bb8cf05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a76e80ea0f77a23879abaf577db0f28bd">max_mem_alloc_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max size of memory object allocation in bytes. The minimum value is max(1/4th of CL_DEVICE_GLOBAL_MEM_SIZE, 128*1024*1024)  <a href="#a76e80ea0f77a23879abaf577db0f28bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a1ec4f9908f272af3158d54ef5368ff3b">max_parameter_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max size in bytes of the arguments that can be passed to a kernel. The minimum value is 1024.  <a href="#a1ec4f9908f272af3158d54ef5368ff3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad49d0c2c2041cedf8a0e3f63e0b729b8">max_read_image_args</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#ad49d0c2c2041cedf8a0e3f63e0b729b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#abab1724b923609c7f0aa17b0d59e5e81">max_samplers</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#abab1724b923609c7f0aa17b0d59e5e81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a49dafae1d5a718f0825eefd245b14683">max_work_group_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of work-items in a work-group executing a kernel using the data parallel execution model. The minimum value is 1.  <a href="#a49dafae1d5a718f0825eefd245b14683"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a9a996b0b90a0ce4abebfe13d68634ca1">max_work_item_dimensions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum dimensions that specify the global and local work-item IDs used by the data parallel execution model. The minimum value is 3.  <a href="#a9a996b0b90a0ce4abebfe13d68634ca1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a1b3b4141030035fe9f4898495f22e11e">max_work_item_sizes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of work-items that can be specified in each dimension of the work-group.  <a href="#a1b3b4141030035fe9f4898495f22e11e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad373bfe54f24f176f898af2e02c4f6a1">max_write_image_args</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of simultaneous image objects that can be written to by a kernel. The minimum value is 8 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.  <a href="#ad373bfe54f24f176f898af2e02c4f6a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#af06975359d57fe421bfe1b57b0073956">mem_base_addr_align</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the alignment in bits of the base address of any allocated memory object.  <a href="#af06975359d57fe421bfe1b57b0073956"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a11526ca6bb6e66405ec0e51dafe167dd">min_data_type_align_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The smallest alignment in bytes which can be used for any data type.  <a href="#a11526ca6bb6e66405ec0e51dafe167dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Device name string.  <a href="#a37627d5d5bba7f4a8690c71c2ab3cb07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl_1_1ocl.html#adb83837b11c9bec5603b76a0012e24e8">device_architecture_family</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#afe5ac2e026232fe02cbcf50bcf453d5c">architecture_family</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Device architecture family.  <a href="#afe5ac2e026232fe02cbcf50bcf453d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_platform_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#adc00f11c541e009faf21e1a93592cdbd">platform</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The platform associated with this device.  <a href="#adc00f11c541e009faf21e1a93592cdbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a88376a162cd1a0d5c61a5051918a7df7">preferred_vector_width_char</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#a88376a162cd1a0d5c61a5051918a7df7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a43e57454609654363908d5d1bff67e11">preferred_vector_width_short</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#a43e57454609654363908d5d1bff67e11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a0d9ba534766a629f6d83242ec20d9c7d">preferred_vector_width_int</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#a0d9ba534766a629f6d83242ec20d9c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a7ca95e17c171318c3fcab76bcaeccc9e">preferred_vector_width_long</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#a7ca95e17c171318c3fcab76bcaeccc9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a035903cebad6b26df51ae4ee8d95d898">preferred_vector_width_float</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#a035903cebad6b26df51ae4ee8d95d898"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a7409d792a832e9adc3d003aabe181e1c">preferred_vector_width_double</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#a7409d792a832e9adc3d003aabe181e1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#abaed2e4ea123afab890a1ee3d825aaef">profile</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector.  <a href="#abaed2e4ea123afab890a1ee3d825aaef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#afd92d6ae0f09c371d207fdacf72bb775">profiling_timer_resolution</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the resolution of device timer. This is measured in nanoseconds.  <a href="#afd92d6ae0f09c371d207fdacf72bb775"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_command_queue_properties&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a632b3e9d82280ba91a1147544efad604">queue_properties</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the command-queue properties supported by the device.  <a href="#a632b3e9d82280ba91a1147544efad604"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_device_fp_config&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#adef66e00159d69c443e5dcc90d9b6772">single_fp_config</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes single precision floating-point capability of the OpenCL device.  <a href="#adef66e00159d69c443e5dcc90d9b6772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_device_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a30cb8b6361720dfb6c7ce63d1c347e41">type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpenCL device type.  <a href="#a30cb8b6361720dfb6c7ce63d1c347e41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a5c6eb4b06ab73aea8614531b04a44d5b">vendor</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor name string.  <a href="#a5c6eb4b06ab73aea8614531b04a44d5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a1575318b34ec417067780eb43514f37d">vendor_id</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique device vendor identifier. An example of a unique device identifier could be the PCIe ID.  <a href="#a1575318b34ec417067780eb43514f37d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a74fde2dcc73016d9f02eba2a83ca5e9b">version</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor name string.  <a href="#a74fde2dcc73016d9f02eba2a83ca5e9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a662b75f96a75aad23ec28c7c55b64d88">driver_version</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vendor name string.  <a href="#a662b75f96a75aad23ec28c7c55b64d88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ab61c1a1216e3f4a8537c6b7bd8a36634">double_support</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ViennaCL convenience function: Returns true if the device supports double precision.  <a href="#ab61c1a1216e3f4a8537c6b7bd8a36634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a36eb84a793487af78b6a620b418efb6a">double_support_extension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ViennaCL convenience function: Returns the device extension which enables double precision (usually cl_khr_fp64, but AMD used cl_amd_fp64 in the past)  <a href="#a36eb84a793487af78b6a620b418efb6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cl_device_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad710a9f9e2cff5a4fe874545102c4c06">id</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OpenCL device id.  <a href="#ad710a9f9e2cff5a4fe874545102c4c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a2471dfe5b4c8e8992fc08d4520aa8b43">info</a> (<a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> indent=0, char indent_char= ' ') const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an info string with a few properties of the device. Use <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad7b04f6f02a8917e0a7da57897e8815d" title="Returns an info string with all device properties defined in the OpenCL 1.1 standard, listed in alphabetical order. Use info() for a short overview.">full_info()</a> to get all details.  <a href="#a2471dfe5b4c8e8992fc08d4520aa8b43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#ad7b04f6f02a8917e0a7da57897e8815d">full_info</a> (<a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> indent=0, char indent_char= ' ') const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an info string with all device properties defined in the OpenCL 1.1 standard, listed in alphabetical order. Use <a class="el" href="classviennacl_1_1ocl_1_1device.html#a2471dfe5b4c8e8992fc08d4520aa8b43" title="Returns an info string with a few properties of the device. Use full_info() to get all details...">info()</a> for a short overview.  <a href="#ad7b04f6f02a8917e0a7da57897e8815d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a42bb548ced469dc5714f1816603a4d35">operator==</a> (<a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> const &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ocl_1_1device.html#a06e1d466be32d6b0072a8a8e23b339f9">operator==</a> (cl_device_id other) const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A class representing a compute device (e.g. a GPU) </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa6214b6ab6f2d943669af7dd76cef3a2"></a><!-- doxytag: member="viennacl::ocl::device::device" ref="aa6214b6ab6f2d943669af7dd76cef3a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a17858dabba4d274000c38bc42de8487c"></a><!-- doxytag: member="viennacl::ocl::device::device" ref="a17858dabba4d274000c38bc42de8487c" args="(cl_device_id dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> </td>
          <td>(</td>
          <td class="paramtype">cl_device_id&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a58ac501d01e9cb8eac21a831e8f0874c"></a><!-- doxytag: member="viennacl::ocl::device::device" ref="a58ac501d01e9cb8eac21a831e8f0874c" args="(const device &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8309715ac80d84b3d33928d7447b5258"></a><!-- doxytag: member="viennacl::ocl::device::address_bits" ref="a8309715ac80d84b3d33928d7447b5258" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a8309715ac80d84b3d33928d7447b5258">address_bits</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default compute device address space size specified as an unsigned integer value in bits. Currently supported values are 32 or 64 bits. </p>

</div>
</div>
<a class="anchor" id="afe5ac2e026232fe02cbcf50bcf453d5c"></a><!-- doxytag: member="viennacl::ocl::device::architecture_family" ref="afe5ac2e026232fe02cbcf50bcf453d5c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl_1_1ocl.html#adb83837b11c9bec5603b76a0012e24e8">device_architecture_family</a> <a class="el" href="classviennacl_1_1ocl_1_1device.html#afe5ac2e026232fe02cbcf50bcf453d5c">architecture_family</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Device architecture family. </p>

</div>
</div>
<a class="anchor" id="a8f220d225a572fc920524892902aac60"></a><!-- doxytag: member="viennacl::ocl::device::available" ref="a8f220d225a572fc920524892902aac60" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_bool <a class="el" href="classviennacl_1_1ocl_1_1device.html#a8f220d225a572fc920524892902aac60">available</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is CL_TRUE if the device is available and CL_FALSE if the device is not available. </p>

</div>
</div>
<a class="anchor" id="a8f365008733eabcd519578beb099b0d7"></a><!-- doxytag: member="viennacl::ocl::device::compiler_available" ref="a8f365008733eabcd519578beb099b0d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_bool <a class="el" href="classviennacl_1_1ocl_1_1device.html#a8f365008733eabcd519578beb099b0d7">compiler_available</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is CL_FALSE if the implementation does not have a compiler available to compile the program source. Is CL_TRUE if the compiler is available. This can be CL_FALSE for the embedded platform profile only. </p>

</div>
</div>
<a class="anchor" id="ab61c1a1216e3f4a8537c6b7bd8a36634"></a><!-- doxytag: member="viennacl::ocl::device::double_support" ref="ab61c1a1216e3f4a8537c6b7bd8a36634" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classviennacl_1_1ocl_1_1device.html#ab61c1a1216e3f4a8537c6b7bd8a36634">double_support</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ViennaCL convenience function: Returns true if the device supports double precision. </p>

</div>
</div>
<a class="anchor" id="a36eb84a793487af78b6a620b418efb6a"></a><!-- doxytag: member="viennacl::ocl::device::double_support_extension" ref="a36eb84a793487af78b6a620b418efb6a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a36eb84a793487af78b6a620b418efb6a">double_support_extension</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ViennaCL convenience function: Returns the device extension which enables double precision (usually cl_khr_fp64, but AMD used cl_amd_fp64 in the past) </p>

</div>
</div>
<a class="anchor" id="a662b75f96a75aad23ec28c7c55b64d88"></a><!-- doxytag: member="viennacl::ocl::device::driver_version" ref="a662b75f96a75aad23ec28c7c55b64d88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a662b75f96a75aad23ec28c7c55b64d88">driver_version</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vendor name string. </p>

</div>
</div>
<a class="anchor" id="a186dc1deea58169fb2044c13e952bf0b"></a><!-- doxytag: member="viennacl::ocl::device::endian_little" ref="a186dc1deea58169fb2044c13e952bf0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_bool <a class="el" href="classviennacl_1_1ocl_1_1device.html#a186dc1deea58169fb2044c13e952bf0b">endian_little</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is CL_TRUE if the OpenCL device is a little endian device and CL_FALSE otherwise. </p>

</div>
</div>
<a class="anchor" id="ac11837beee79843ef898d9cf12652474"></a><!-- doxytag: member="viennacl::ocl::device::error_correction_support" ref="ac11837beee79843ef898d9cf12652474" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_bool <a class="el" href="classviennacl_1_1ocl_1_1device.html#ac11837beee79843ef898d9cf12652474">error_correction_support</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is CL_TRUE if the device implements error correction for all accesses to compute device memory (global and constant) and CL_FALSE otherwise. </p>

</div>
</div>
<a class="anchor" id="a2ce02d6139f3833916c66fdd883b6a8d"></a><!-- doxytag: member="viennacl::ocl::device::execution_capabilities" ref="a2ce02d6139f3833916c66fdd883b6a8d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_device_exec_capabilities <a class="el" href="classviennacl_1_1ocl_1_1device.html#a2ce02d6139f3833916c66fdd883b6a8d">execution_capabilities</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes the execution capabilities of the device. </p>
<p>This is a bit-field that describes one or more of the following values: CL_EXEC_KERNEL - The OpenCL device can execute OpenCL kernels. CL_EXEC_NATIVE_KERNEL - The OpenCL device can execute native kernels. The mandated minimum capability is CL_EXEC_KERNEL. </p>

</div>
</div>
<a class="anchor" id="a13c05d46e01b83a17a635e4873ad8378"></a><!-- doxytag: member="viennacl::ocl::device::extensions" ref="a13c05d46e01b83a17a635e4873ad8378" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378">extensions</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a space-separated list of extension names (the extension names themselves do not contain any spaces). </p>
<p>The list of extension names returned currently can include one or more of the following approved extension names: cl_khr_fp64 cl_khr_int64_base_atomics cl_khr_int64_extended_atomics cl_khr_fp16 cl_khr_gl_sharing cl_khr_gl_event cl_khr_d3d10_sharing </p>

</div>
</div>
<a class="anchor" id="ad7b04f6f02a8917e0a7da57897e8815d"></a><!-- doxytag: member="viennacl::ocl::device::full_info" ref="ad7b04f6f02a8917e0a7da57897e8815d" args="(vcl_size_t indent=0, char indent_char= ' ') const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad7b04f6f02a8917e0a7da57897e8815d">full_info</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an info string with all device properties defined in the OpenCL 1.1 standard, listed in alphabetical order. Use <a class="el" href="classviennacl_1_1ocl_1_1device.html#a2471dfe5b4c8e8992fc08d4520aa8b43" title="Returns an info string with a few properties of the device. Use full_info() to get all details...">info()</a> for a short overview. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">indent</td><td>Number of optional blanks to be added at the start of each line </td></tr>
    <tr><td class="paramname">indent_char</td><td>Character to be used for indenting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1fc58e70bbf8de4ce006f2b20fe5247"></a><!-- doxytag: member="viennacl::ocl::device::global_mem_cache_size" ref="ad1fc58e70bbf8de4ce006f2b20fe5247" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_ulong <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad1fc58e70bbf8de4ce006f2b20fe5247">global_mem_cache_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of global memory cache in bytes. </p>

</div>
</div>
<a class="anchor" id="ae4afa4cd9be93609dbd0bb79345368e4"></a><!-- doxytag: member="viennacl::ocl::device::global_mem_cache_type" ref="ae4afa4cd9be93609dbd0bb79345368e4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_device_mem_cache_type <a class="el" href="classviennacl_1_1ocl_1_1device.html#ae4afa4cd9be93609dbd0bb79345368e4">global_mem_cache_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of global memory cache supported. Valid values are: CL_NONE, CL_READ_ONLY_CACHE, and CL_READ_WRITE_CACHE. </p>

</div>
</div>
<a class="anchor" id="a6c21e467f78c1a7a37d51a303729d5a2"></a><!-- doxytag: member="viennacl::ocl::device::global_mem_cacheline_size" ref="a6c21e467f78c1a7a37d51a303729d5a2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a6c21e467f78c1a7a37d51a303729d5a2">global_mem_cacheline_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of global memory cache in bytes. </p>

</div>
</div>
<a class="anchor" id="ad45acc1aefd8535b948f28cbdc11f1c9"></a><!-- doxytag: member="viennacl::ocl::device::global_mem_size" ref="ad45acc1aefd8535b948f28cbdc11f1c9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_ulong <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad45acc1aefd8535b948f28cbdc11f1c9">global_mem_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of global memory in bytes. </p>

</div>
</div>
<a class="anchor" id="ad710a9f9e2cff5a4fe874545102c4c06"></a><!-- doxytag: member="viennacl::ocl::device::id" ref="ad710a9f9e2cff5a4fe874545102c4c06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_device_id <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad710a9f9e2cff5a4fe874545102c4c06">id</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the OpenCL device id. </p>

</div>
</div>
<a class="anchor" id="a27c69153da9c199b28607cd6fe539720"></a><!-- doxytag: member="viennacl::ocl::device::image2d_max_height" ref="a27c69153da9c199b28607cd6fe539720" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#a27c69153da9c199b28607cd6fe539720">image2d_max_height</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max height of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="a891f1c8a5008296e36c5243c6b553157"></a><!-- doxytag: member="viennacl::ocl::device::image2d_max_width" ref="a891f1c8a5008296e36c5243c6b553157" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#a891f1c8a5008296e36c5243c6b553157">image2d_max_width</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max width of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="acd51b91e6ef23771cb6f5f5bfddac634"></a><!-- doxytag: member="viennacl::ocl::device::image3d_max_depth" ref="acd51b91e6ef23771cb6f5f5bfddac634" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#acd51b91e6ef23771cb6f5f5bfddac634">image3d_max_depth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max depth of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="a1350aeecc36ebcecc7535695117f87fe"></a><!-- doxytag: member="viennacl::ocl::device::image3d_max_height" ref="a1350aeecc36ebcecc7535695117f87fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#a1350aeecc36ebcecc7535695117f87fe">image3d_max_height</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max height of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="ad1e0b838ced23bfd058a80b64af96281"></a><!-- doxytag: member="viennacl::ocl::device::image3d_max_width" ref="ad1e0b838ced23bfd058a80b64af96281" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad1e0b838ced23bfd058a80b64af96281">image3d_max_width</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max width of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="af6a152b64e7f80a18df3aafc9303e4bd"></a><!-- doxytag: member="viennacl::ocl::device::image_support" ref="af6a152b64e7f80a18df3aafc9303e4bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_bool <a class="el" href="classviennacl_1_1ocl_1_1device.html#af6a152b64e7f80a18df3aafc9303e4bd">image_support</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is CL_TRUE if the device and the host have a unified memory subsystem and is CL_FALSE otherwise. </p>
<p>Is CL_TRUE if images are supported by the OpenCL device and CL_FALSE otherwise. </p>

</div>
</div>
<a class="anchor" id="a2471dfe5b4c8e8992fc08d4520aa8b43"></a><!-- doxytag: member="viennacl::ocl::device::info" ref="a2471dfe5b4c8e8992fc08d4520aa8b43" args="(vcl_size_t indent=0, char indent_char= ' ') const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a2471dfe5b4c8e8992fc08d4520aa8b43">info</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an info string with a few properties of the device. Use <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad7b04f6f02a8917e0a7da57897e8815d" title="Returns an info string with all device properties defined in the OpenCL 1.1 standard, listed in alphabetical order. Use info() for a short overview.">full_info()</a> to get all details. </p>
<p>Returns the following device properties: name, vendor, type, availability, max compute units, max work group size, global mem size, local mem size, local mem type, host unified memory</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">indent</td><td>Number of optional blanks to be added at the start of each line </td></tr>
    <tr><td class="paramname">indent_char</td><td>Character to be used for indenting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a089c660aee310ef2c01aa5171239f7de"></a><!-- doxytag: member="viennacl::ocl::device::local_mem_size" ref="a089c660aee310ef2c01aa5171239f7de" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_ulong <a class="el" href="classviennacl_1_1ocl_1_1device.html#a089c660aee310ef2c01aa5171239f7de">local_mem_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size of local memory arena in bytes. The minimum value is 32 KB. </p>

</div>
</div>
<a class="anchor" id="a8091787f68d0b4fec54982ac60ff0e58"></a><!-- doxytag: member="viennacl::ocl::device::local_mem_type" ref="a8091787f68d0b4fec54982ac60ff0e58" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_device_local_mem_type <a class="el" href="classviennacl_1_1ocl_1_1device.html#a8091787f68d0b4fec54982ac60ff0e58">local_mem_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of local memory supported. This can be set to CL_LOCAL implying dedicated local memory storage such as SRAM, or CL_GLOBAL. </p>

</div>
</div>
<a class="anchor" id="ab3f87b373439a4d280102b3323a3646c"></a><!-- doxytag: member="viennacl::ocl::device::max_clock_frequency" ref="ab3f87b373439a4d280102b3323a3646c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#ab3f87b373439a4d280102b3323a3646c">max_clock_frequency</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum configured clock frequency of the device in MHz. </p>

</div>
</div>
<a class="anchor" id="ab2a44bd7f2d691fa15460928af757d99"></a><!-- doxytag: member="viennacl::ocl::device::max_compute_units" ref="ab2a44bd7f2d691fa15460928af757d99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#ab2a44bd7f2d691fa15460928af757d99">max_compute_units</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of parallel compute cores on the OpenCL device. The minimum value is 1. </p>

</div>
</div>
<a class="anchor" id="a692f1cbba0e5ec45a36546e7d3566b17"></a><!-- doxytag: member="viennacl::ocl::device::max_constant_args" ref="a692f1cbba0e5ec45a36546e7d3566b17" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a692f1cbba0e5ec45a36546e7d3566b17">max_constant_args</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max number of arguments declared with the __constant qualifier in a kernel. The minimum value is 8. </p>

</div>
</div>
<a class="anchor" id="aa2d0aa7e89b3bd75bf363f427bb8cf05"></a><!-- doxytag: member="viennacl::ocl::device::max_constant_buffer_size" ref="aa2d0aa7e89b3bd75bf363f427bb8cf05" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_ulong <a class="el" href="classviennacl_1_1ocl_1_1device.html#aa2d0aa7e89b3bd75bf363f427bb8cf05">max_constant_buffer_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max size in bytes of a constant buffer allocation. The minimum value is 64 KB. </p>

</div>
</div>
<a class="anchor" id="a76e80ea0f77a23879abaf577db0f28bd"></a><!-- doxytag: member="viennacl::ocl::device::max_mem_alloc_size" ref="a76e80ea0f77a23879abaf577db0f28bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_ulong <a class="el" href="classviennacl_1_1ocl_1_1device.html#a76e80ea0f77a23879abaf577db0f28bd">max_mem_alloc_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max size of memory object allocation in bytes. The minimum value is max(1/4th of CL_DEVICE_GLOBAL_MEM_SIZE, 128*1024*1024) </p>

</div>
</div>
<a class="anchor" id="a1ec4f9908f272af3158d54ef5368ff3b"></a><!-- doxytag: member="viennacl::ocl::device::max_parameter_size" ref="a1ec4f9908f272af3158d54ef5368ff3b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#a1ec4f9908f272af3158d54ef5368ff3b">max_parameter_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max size in bytes of the arguments that can be passed to a kernel. The minimum value is 1024. </p>
<p>For this minimum value, only a maximum of 128 arguments can be passed to a kernel. </p>

</div>
</div>
<a class="anchor" id="ad49d0c2c2041cedf8a0e3f63e0b729b8"></a><!-- doxytag: member="viennacl::ocl::device::max_read_image_args" ref="ad49d0c2c2041cedf8a0e3f63e0b729b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad49d0c2c2041cedf8a0e3f63e0b729b8">max_read_image_args</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="abab1724b923609c7f0aa17b0d59e5e81"></a><!-- doxytag: member="viennacl::ocl::device::max_samplers" ref="abab1724b923609c7f0aa17b0d59e5e81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#abab1724b923609c7f0aa17b0d59e5e81">max_samplers</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="a49dafae1d5a718f0825eefd245b14683"></a><!-- doxytag: member="viennacl::ocl::device::max_work_group_size" ref="a49dafae1d5a718f0825eefd245b14683" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#a49dafae1d5a718f0825eefd245b14683">max_work_group_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of work-items in a work-group executing a kernel using the data parallel execution model. The minimum value is 1. </p>

</div>
</div>
<a class="anchor" id="a9a996b0b90a0ce4abebfe13d68634ca1"></a><!-- doxytag: member="viennacl::ocl::device::max_work_item_dimensions" ref="a9a996b0b90a0ce4abebfe13d68634ca1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a9a996b0b90a0ce4abebfe13d68634ca1">max_work_item_dimensions</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum dimensions that specify the global and local work-item IDs used by the data parallel execution model. The minimum value is 3. </p>

</div>
</div>
<a class="anchor" id="a1b3b4141030035fe9f4898495f22e11e"></a><!-- doxytag: member="viennacl::ocl::device::max_work_item_sizes" ref="a1b3b4141030035fe9f4898495f22e11e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classviennacl_1_1ocl_1_1device.html#a1b3b4141030035fe9f4898495f22e11e">max_work_item_sizes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of work-items that can be specified in each dimension of the work-group. </p>
<p>Returns n size_t entries, where n is the value returned by the query for CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. The minimum value is (1, 1, 1). </p>

</div>
</div>
<a class="anchor" id="ad373bfe54f24f176f898af2e02c4f6a1"></a><!-- doxytag: member="viennacl::ocl::device::max_write_image_args" ref="ad373bfe54f24f176f898af2e02c4f6a1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#ad373bfe54f24f176f898af2e02c4f6a1">max_write_image_args</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max number of simultaneous image objects that can be written to by a kernel. The minimum value is 8 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE. </p>

</div>
</div>
<a class="anchor" id="af06975359d57fe421bfe1b57b0073956"></a><!-- doxytag: member="viennacl::ocl::device::mem_base_addr_align" ref="af06975359d57fe421bfe1b57b0073956" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#af06975359d57fe421bfe1b57b0073956">mem_base_addr_align</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes the alignment in bits of the base address of any allocated memory object. </p>

</div>
</div>
<a class="anchor" id="a11526ca6bb6e66405ec0e51dafe167dd"></a><!-- doxytag: member="viennacl::ocl::device::min_data_type_align_size" ref="a11526ca6bb6e66405ec0e51dafe167dd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a11526ca6bb6e66405ec0e51dafe167dd">min_data_type_align_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The smallest alignment in bytes which can be used for any data type. </p>

</div>
</div>
<a class="anchor" id="a37627d5d5bba7f4a8690c71c2ab3cb07"></a><!-- doxytag: member="viennacl::ocl::device::name" ref="a37627d5d5bba7f4a8690c71c2ab3cb07" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07">name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Device name string. </p>

</div>
</div>
<a class="anchor" id="a42bb548ced469dc5714f1816603a4d35"></a><!-- doxytag: member="viennacl::ocl::device::operator==" ref="a42bb548ced469dc5714f1816603a4d35" args="(device const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1ocl_1_1device.html">device</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a06e1d466be32d6b0072a8a8e23b339f9"></a><!-- doxytag: member="viennacl::ocl::device::operator==" ref="a06e1d466be32d6b0072a8a8e23b339f9" args="(cl_device_id other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">cl_device_id&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adc00f11c541e009faf21e1a93592cdbd"></a><!-- doxytag: member="viennacl::ocl::device::platform" ref="adc00f11c541e009faf21e1a93592cdbd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_platform_id <a class="el" href="classviennacl_1_1ocl_1_1platform.html">platform</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The platform associated with this device. </p>

</div>
</div>
<a class="anchor" id="a88376a162cd1a0d5c61a5051918a7df7"></a><!-- doxytag: member="viennacl::ocl::device::preferred_vector_width_char" ref="a88376a162cd1a0d5c61a5051918a7df7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a88376a162cd1a0d5c61a5051918a7df7">preferred_vector_width_char</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>

</div>
</div>
<a class="anchor" id="a7409d792a832e9adc3d003aabe181e1c"></a><!-- doxytag: member="viennacl::ocl::device::preferred_vector_width_double" ref="a7409d792a832e9adc3d003aabe181e1c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a7409d792a832e9adc3d003aabe181e1c">preferred_vector_width_double</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>
<p>If the cl_khr_fp64 extension is not supported, this function returns 0. </p>

</div>
</div>
<a class="anchor" id="a035903cebad6b26df51ae4ee8d95d898"></a><!-- doxytag: member="viennacl::ocl::device::preferred_vector_width_float" ref="a035903cebad6b26df51ae4ee8d95d898" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a035903cebad6b26df51ae4ee8d95d898">preferred_vector_width_float</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>

</div>
</div>
<a class="anchor" id="a0d9ba534766a629f6d83242ec20d9c7d"></a><!-- doxytag: member="viennacl::ocl::device::preferred_vector_width_int" ref="a0d9ba534766a629f6d83242ec20d9c7d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a0d9ba534766a629f6d83242ec20d9c7d">preferred_vector_width_int</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>

</div>
</div>
<a class="anchor" id="a7ca95e17c171318c3fcab76bcaeccc9e"></a><!-- doxytag: member="viennacl::ocl::device::preferred_vector_width_long" ref="a7ca95e17c171318c3fcab76bcaeccc9e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a7ca95e17c171318c3fcab76bcaeccc9e">preferred_vector_width_long</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>

</div>
</div>
<a class="anchor" id="a43e57454609654363908d5d1bff67e11"></a><!-- doxytag: member="viennacl::ocl::device::preferred_vector_width_short" ref="a43e57454609654363908d5d1bff67e11" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a43e57454609654363908d5d1bff67e11">preferred_vector_width_short</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>

</div>
</div>
<a class="anchor" id="abaed2e4ea123afab890a1ee3d825aaef"></a><!-- doxytag: member="viennacl::ocl::device::profile" ref="abaed2e4ea123afab890a1ee3d825aaef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#abaed2e4ea123afab890a1ee3d825aaef">profile</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Preferred native vector width size for built-in scalar types that can be put into vectors. The vector width is defined as the number of scalar elements that can be stored in the vector. </p>
<p>If the cl_khr_fp16 extension is not supported, this function returns 0.OpenCL profile string. Returns the profile name supported by the device.</p>
<p>The profile name returned can be one of the following strings: FULL_PROFILE - if the device supports the OpenCL specification EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile. </p>

</div>
</div>
<a class="anchor" id="afd92d6ae0f09c371d207fdacf72bb775"></a><!-- doxytag: member="viennacl::ocl::device::profiling_timer_resolution" ref="afd92d6ae0f09c371d207fdacf72bb775" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classviennacl_1_1ocl_1_1device.html#afd92d6ae0f09c371d207fdacf72bb775">profiling_timer_resolution</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes the resolution of device timer. This is measured in nanoseconds. </p>

</div>
</div>
<a class="anchor" id="a632b3e9d82280ba91a1147544efad604"></a><!-- doxytag: member="viennacl::ocl::device::queue_properties" ref="a632b3e9d82280ba91a1147544efad604" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_command_queue_properties <a class="el" href="classviennacl_1_1ocl_1_1device.html#a632b3e9d82280ba91a1147544efad604">queue_properties</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes the command-queue properties supported by the device. </p>
<p>This is a bit-field that describes one or more of the following values: CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE CL_QUEUE_PROFILING_ENABLE3 These properties are described in the table for clCreateCommandQueue in the OpenCL standard. The mandated minimum capability is CL_QUEUE_PROFILING_ENABLE. </p>

</div>
</div>
<a class="anchor" id="adef66e00159d69c443e5dcc90d9b6772"></a><!-- doxytag: member="viennacl::ocl::device::single_fp_config" ref="adef66e00159d69c443e5dcc90d9b6772" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_device_fp_config <a class="el" href="classviennacl_1_1ocl_1_1device.html#adef66e00159d69c443e5dcc90d9b6772">single_fp_config</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describes single precision floating-point capability of the OpenCL device. </p>
<p>This is a bit-field that describes one or more of the following values: CL_FP_DENORM - denorms are supported. CL_FP_INF_NAN - INF and NaNs are supported. CL_FP_ROUND_TO_NEAREST - round to nearest even rounding mode supported. CL_FP_ROUND_TO_ZERO - round to zero rounding mode supported. CL_FP_ROUND_TO_INF - round to +ve and -ve infinity rounding modes supported. CP_FP_FMA - IEEE754-2008 fused multiply-add is supported. CL_FP_SOFT_FLOAT - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</p>
<p>The mandated minimum floating-point capability is CL_FP_ROUND_TO_NEAREST | CL_FP_INF_NAN. </p>

</div>
</div>
<a class="anchor" id="a30cb8b6361720dfb6c7ce63d1c347e41"></a><!-- doxytag: member="viennacl::ocl::device::type" ref="a30cb8b6361720dfb6c7ce63d1c347e41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_device_type <a class="el" href="classviennacl_1_1ocl_1_1device.html#a30cb8b6361720dfb6c7ce63d1c347e41">type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The OpenCL device type. </p>
<p>Currently supported values are one of or a combination of: CL_DEVICE_TYPE_CPU, CL_DEVICE_TYPE_GPU, CL_DEVICE_TYPE_ACCELERATOR, or CL_DEVICE_TYPE_DEFAULT. </p>

</div>
</div>
<a class="anchor" id="a5c6eb4b06ab73aea8614531b04a44d5b"></a><!-- doxytag: member="viennacl::ocl::device::vendor" ref="a5c6eb4b06ab73aea8614531b04a44d5b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a5c6eb4b06ab73aea8614531b04a44d5b">vendor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vendor name string. </p>

</div>
</div>
<a class="anchor" id="a1575318b34ec417067780eb43514f37d"></a><!-- doxytag: member="viennacl::ocl::device::vendor_id" ref="a1575318b34ec417067780eb43514f37d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint <a class="el" href="classviennacl_1_1ocl_1_1device.html#a1575318b34ec417067780eb43514f37d">vendor_id</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A unique device vendor identifier. An example of a unique device identifier could be the PCIe ID. </p>

</div>
</div>
<a class="anchor" id="a74fde2dcc73016d9f02eba2a83ca5e9b"></a><!-- doxytag: member="viennacl::ocl::device::version" ref="a74fde2dcc73016d9f02eba2a83ca5e9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classviennacl_1_1ocl_1_1device.html#a74fde2dcc73016d9f02eba2a83ca5e9b">version</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vendor name string. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>viennacl/ocl/<a class="el" href="device_8hpp_source.html">device.hpp</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:38 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
