<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/linalg/opencl/vector_operations.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/linalg/opencl/vector_operations.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="opencl_2vector__operations_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_LINALG_OPENCL_VECTOR_OPERATIONS_HPP_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_LINALG_OPENCL_VECTOR_OPERATIONS_HPP_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2014, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL.">viennacl/forwards.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="device_8hpp.html" title="Represents an OpenCL device within ViennaCL.">viennacl/ocl/device.hpp</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="ocl_2handle_8hpp.html" title="Implementation of a smart-pointer-like class for handling OpenCL handles.">viennacl/ocl/handle.hpp</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="kernel_8hpp.html" title="Representation of an OpenCL kernel in ViennaCL.">viennacl/ocl/kernel.hpp</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html" title="Implementation of the ViennaCL scalar class.">viennacl/scalar.hpp</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html" title="Various little tools used here and there in ViennaCL.">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="opencl_2common_8hpp.html" title="Common implementations shared by OpenCL-based operations.">viennacl/linalg/opencl/common.hpp</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="linalg_2opencl_2kernels_2vector_8hpp.html" title="OpenCL kernel file for vector operations.">viennacl/linalg/opencl/kernels/vector.hpp</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="vector__element_8hpp.html" title="OpenCL kernel file for element-wise vector operations.">viennacl/linalg/opencl/kernels/vector_element.hpp</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="predicate_8hpp.html" title="All the predicates used within ViennaCL. Checks for expressions to be vectors, etc.">viennacl/meta/predicate.hpp</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="enable__if_8hpp.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl/meta/enable_if.hpp</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="size_8hpp.html" title="Generic size and resize functionality for different vector and matrix types.">viennacl/traits/size.hpp</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="start_8hpp.html" title="Extracts the underlying OpenCL start index handle from a vector, a matrix, an expression etc...">viennacl/traits/start.hpp</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="traits_2handle_8hpp.html" title="Extracts the underlying OpenCL handle from a vector, a matrix, an expression etc.">viennacl/traits/handle.hpp</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="stride_8hpp.html" title="Determines row and column increments for matrices and matrix proxies.">viennacl/traits/stride.hpp</a>&quot;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="keyword">namespace </span>viennacl
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045   <span class="keyword">namespace </span>linalg
<a name="l00046"></a>00046   {
<a name="l00047"></a>00047     <span class="keyword">namespace </span>opencl
<a name="l00048"></a>00048     {
<a name="l00049"></a>00049       <span class="comment">//</span>
<a name="l00050"></a>00050       <span class="comment">// Introductory note: By convention, all dimensions are already checked in the dispatcher frontend. No need to double-check again in here!</span>
<a name="l00051"></a>00051       <span class="comment">//</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a>00054       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ScalarType1&gt;
<a name="l00055"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a0501c423f35eb16759db2c3028ae4857">00055</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a0501c423f35eb16759db2c3028ae4857">av</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1,
<a name="l00056"></a>00056               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec2, ScalarType1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha)
<a name="l00057"></a>00057       {
<a name="l00058"></a>00058         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00059"></a>00059 
<a name="l00060"></a>00060         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00061"></a>00061         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(),
<a name="l00066"></a>00066                                                    (<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> ? <span class="stringliteral">&quot;av_cpu&quot;</span> : <span class="stringliteral">&quot;av_gpu&quot;</span>));
<a name="l00067"></a>00067         k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, std::min&lt;vcl_size_t&gt;(128 * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(),
<a name="l00068"></a>00068                                                     viennacl::tools::align_to_multiple&lt;vcl_size_t&gt;(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1), k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()) ) );
<a name="l00069"></a>00069 
<a name="l00070"></a>00070         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec1;
<a name="l00071"></a>00071         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1));
<a name="l00072"></a>00072         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1));
<a name="l00073"></a>00073         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1));
<a name="l00074"></a>00074         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec1));
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec2;
<a name="l00077"></a>00077         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2));
<a name="l00078"></a>00078         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2));
<a name="l00079"></a>00079         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2));
<a name="l00080"></a>00080         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec2));
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00084"></a>00084                                  size_vec1,
<a name="l00085"></a>00085 
<a name="l00086"></a>00086                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;T&gt;(alpha)),
<a name="l00087"></a>00087                                  options_alpha,
<a name="l00088"></a>00088                                  viennacl::traits::opencl_handle(vec2),
<a name="l00089"></a>00089                                  size_vec2 )
<a name="l00090"></a>00090                               );
<a name="l00091"></a>00091       }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ScalarType1, <span class="keyword">typename</span> ScalarType2&gt;
<a name="l00095"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad22775c47f41c305da21168d1cb92236">00095</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad22775c47f41c305da21168d1cb92236">avbv</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1,
<a name="l00096"></a>00096                 <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec2, ScalarType1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha,
<a name="l00097"></a>00097                 <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec3, ScalarType2 <span class="keyword">const</span> &amp; beta,  <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_beta,  <span class="keywordtype">bool</span> reciprocal_beta,  <span class="keywordtype">bool</span> flip_sign_beta)
<a name="l00098"></a>00098       {
<a name="l00099"></a>00099         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00100"></a>00100         assert(viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec3).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00101"></a>00101 
<a name="l00102"></a>00102         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00103"></a>00103         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         std::string kernel_name;
<a name="l00106"></a>00106         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00107"></a>00107           kernel_name = <span class="stringliteral">&quot;avbv_cpu_cpu&quot;</span>;
<a name="l00108"></a>00108         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; !<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00109"></a>00109           kernel_name = <span class="stringliteral">&quot;avbv_cpu_gpu&quot;</span>;
<a name="l00110"></a>00110         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00111"></a>00111           kernel_name = <span class="stringliteral">&quot;avbv_gpu_cpu&quot;</span>;
<a name="l00112"></a>00112         <span class="keywordflow">else</span>
<a name="l00113"></a>00113           kernel_name = <span class="stringliteral">&quot;avbv_gpu_gpu&quot;</span>;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00116"></a>00116         cl_uint options_beta  = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_beta,  reciprocal_beta,  flip_sign_beta);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), kernel_name);
<a name="l00119"></a>00119         k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, std::min&lt;vcl_size_t&gt;(128 * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(),
<a name="l00120"></a>00120                                                     viennacl::tools::align_to_multiple&lt;vcl_size_t&gt;(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1), k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()) ) );
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec1;
<a name="l00123"></a>00123         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1));
<a name="l00124"></a>00124         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1));
<a name="l00125"></a>00125         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1));
<a name="l00126"></a>00126         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec1));
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec2;
<a name="l00129"></a>00129         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2));
<a name="l00130"></a>00130         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2));
<a name="l00131"></a>00131         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2));
<a name="l00132"></a>00132         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec2));
<a name="l00133"></a>00133 
<a name="l00134"></a>00134         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec3;
<a name="l00135"></a>00135         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec3));
<a name="l00136"></a>00136         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec3));
<a name="l00137"></a>00137         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec3));
<a name="l00138"></a>00138         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec3));
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00141"></a>00141                                  size_vec1,
<a name="l00142"></a>00142 
<a name="l00143"></a>00143                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;T&gt;(alpha)),
<a name="l00144"></a>00144                                  options_alpha,
<a name="l00145"></a>00145                                  viennacl::traits::opencl_handle(vec2),
<a name="l00146"></a>00146                                  size_vec2,
<a name="l00147"></a>00147 
<a name="l00148"></a>00148                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;T&gt;(beta)),
<a name="l00149"></a>00149                                  options_beta,
<a name="l00150"></a>00150                                  viennacl::traits::opencl_handle(vec3),
<a name="l00151"></a>00151                                  size_vec3 )
<a name="l00152"></a>00152                               );
<a name="l00153"></a>00153       }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ScalarType1, <span class="keyword">typename</span> ScalarType2&gt;
<a name="l00157"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3acee3fef422c2c2abee2f4e1d67c350">00157</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3acee3fef422c2c2abee2f4e1d67c350">avbv_v</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1,
<a name="l00158"></a>00158                   <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec2, ScalarType1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha,
<a name="l00159"></a>00159                   <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec3, ScalarType2 <span class="keyword">const</span> &amp; beta,  <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_beta,  <span class="keywordtype">bool</span> reciprocal_beta,  <span class="keywordtype">bool</span> flip_sign_beta)
<a name="l00160"></a>00160       {
<a name="l00161"></a>00161         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00162"></a>00162         assert(viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec3).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00163"></a>00163 
<a name="l00164"></a>00164         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00165"></a>00165         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         std::string kernel_name;
<a name="l00168"></a>00168         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00169"></a>00169           kernel_name = <span class="stringliteral">&quot;avbv_v_cpu_cpu&quot;</span>;
<a name="l00170"></a>00170         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; !<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00171"></a>00171           kernel_name = <span class="stringliteral">&quot;avbv_v_cpu_gpu&quot;</span>;
<a name="l00172"></a>00172         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00173"></a>00173           kernel_name = <span class="stringliteral">&quot;avbv_v_gpu_cpu&quot;</span>;
<a name="l00174"></a>00174         <span class="keywordflow">else</span>
<a name="l00175"></a>00175           kernel_name = <span class="stringliteral">&quot;avbv_v_gpu_gpu&quot;</span>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00178"></a>00178         cl_uint options_beta  = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_beta,  reciprocal_beta,  flip_sign_beta);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), kernel_name);
<a name="l00181"></a>00181         k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, std::min&lt;vcl_size_t&gt;(128 * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(),
<a name="l00182"></a>00182                                                     viennacl::tools::align_to_multiple&lt;vcl_size_t&gt;(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1), k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()) ) );
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec1;
<a name="l00185"></a>00185         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1));
<a name="l00186"></a>00186         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1));
<a name="l00187"></a>00187         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1));
<a name="l00188"></a>00188         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec1));
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec2;
<a name="l00191"></a>00191         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2));
<a name="l00192"></a>00192         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2));
<a name="l00193"></a>00193         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2));
<a name="l00194"></a>00194         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec2));
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec3;
<a name="l00197"></a>00197         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec3));
<a name="l00198"></a>00198         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec3));
<a name="l00199"></a>00199         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec3));
<a name="l00200"></a>00200         size_vec3.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec3));
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00203"></a>00203                                  size_vec1,
<a name="l00204"></a>00204 
<a name="l00205"></a>00205                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;T&gt;(alpha)),
<a name="l00206"></a>00206                                  options_alpha,
<a name="l00207"></a>00207                                  viennacl::traits::opencl_handle(vec2),
<a name="l00208"></a>00208                                  size_vec2,
<a name="l00209"></a>00209 
<a name="l00210"></a>00210                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;T&gt;(beta)),
<a name="l00211"></a>00211                                  options_beta,
<a name="l00212"></a>00212                                  viennacl::traits::opencl_handle(vec3),
<a name="l00213"></a>00213                                  size_vec3 )
<a name="l00214"></a>00214                               );
<a name="l00215"></a>00215       }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00224"></a>00224       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00225"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a964528bcf7fca1f0e63be4b81d9a1a4b">00225</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a964528bcf7fca1f0e63be4b81d9a1a4b" title="Assign a constant value to a vector (-range/-slice)">vector_assign</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1, <span class="keyword">const</span> T &amp; alpha, <span class="keywordtype">bool</span> up_to_internal_size = <span class="keyword">false</span>)
<a name="l00226"></a>00226       {
<a name="l00227"></a>00227         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00228"></a>00228         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;assign_cpu&quot;</span>);
<a name="l00231"></a>00231         k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, std::min&lt;vcl_size_t&gt;(128 * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(),
<a name="l00232"></a>00232                                                     viennacl::tools::align_to_multiple&lt;vcl_size_t&gt;(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1), k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()) ) );
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         cl_uint <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">size</a> = up_to_internal_size ? cl_uint(vec1.<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>()) : cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1));
<a name="l00235"></a>00235         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00236"></a>00236                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1)),
<a name="l00237"></a>00237                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1)),
<a name="l00238"></a>00238                                  size,
<a name="l00239"></a>00239                                  cl_uint(vec1.<a class="code" href="classviennacl_1_1vector__base.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>()),     <span class="comment">//Note: Do NOT use traits::internal_size() here, because vector proxies don&#39;t require padding.</span>
<a name="l00240"></a>00240                                  viennacl::traits::opencl_handle(T(alpha)) )
<a name="l00241"></a>00241                               );
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00250"></a>00250       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00251"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8d0663f2f9916ed1ec639bcd1d240a7d">00251</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a8d0663f2f9916ed1ec639bcd1d240a7d" title="Swaps the contents of two vectors, data is copied.">vector_swap</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec2)
<a name="l00252"></a>00252       {
<a name="l00253"></a>00253         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00256"></a>00256         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;swap&quot;</span>);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00261"></a>00261                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1)),
<a name="l00262"></a>00262                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1)),
<a name="l00263"></a>00263                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1)),
<a name="l00264"></a>00264                                  viennacl::traits::opencl_handle(vec2),
<a name="l00265"></a>00265                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2)),
<a name="l00266"></a>00266                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2)),
<a name="l00267"></a>00267                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2)))
<a name="l00268"></a>00268                               );
<a name="l00269"></a>00269       }
<a name="l00270"></a>00270 
<a name="l00272"></a>00272 
<a name="l00278"></a>00278       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> OP&gt;
<a name="l00279"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3676fb99f0f09069c00a2d5eebeb9a3e">00279</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f303555920a75cf584b894ddbb5c8c7" title="Implementation of binary element-wise operations A = OP(B,C)">element_op</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1,
<a name="l00280"></a>00280                       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <a class="code" href="structviennacl_1_1op__element__binary.html" title="A tag class representing element-wise binary operations (like multiplication) on vectors or matrices...">op_element_binary&lt;OP&gt;</a> &gt; <span class="keyword">const</span> &amp; proxy)
<a name="l00281"></a>00281       {
<a name="l00282"></a>00282         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.lhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00283"></a>00283         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.rhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00286"></a>00286         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__element.html" title="Main kernel class for generating OpenCL kernels for elementwise operations other than addition and su...">viennacl::linalg::opencl::kernels::vector_element&lt;T&gt;::init</a>(ctx);
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.get_kernel(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__element.html" title="Main kernel class for generating OpenCL kernels for elementwise operations other than addition and su...">viennacl::linalg::opencl::kernels::vector_element&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;element_op&quot;</span>);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         cl_uint op_type = 2; <span class="comment">//0: product, 1: division, 2: power</span>
<a name="l00291"></a>00291         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a>)
<a name="l00292"></a>00292           op_type = 1;
<a name="l00293"></a>00293         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP&gt;::value</a>)
<a name="l00294"></a>00294           op_type = 0;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00297"></a>00297                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1)),
<a name="l00298"></a>00298                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1)),
<a name="l00299"></a>00299                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1)),
<a name="l00300"></a>00300 
<a name="l00301"></a>00301                                  viennacl::traits::opencl_handle(proxy.lhs()),
<a name="l00302"></a>00302                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(proxy.lhs())),
<a name="l00303"></a>00303                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(proxy.lhs())),
<a name="l00304"></a>00304 
<a name="l00305"></a>00305                                  viennacl::traits::opencl_handle(proxy.rhs()),
<a name="l00306"></a>00306                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(proxy.rhs())),
<a name="l00307"></a>00307                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(proxy.rhs())),
<a name="l00308"></a>00308 
<a name="l00309"></a>00309                                  op_type)
<a name="l00310"></a>00310                               );
<a name="l00311"></a>00311       }
<a name="l00312"></a>00312 
<a name="l00314"></a>00314 
<a name="l00320"></a>00320       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> OP&gt;
<a name="l00321"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a0a42d79551b9a8a6f294211a655048ce">00321</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f303555920a75cf584b894ddbb5c8c7" title="Implementation of binary element-wise operations A = OP(B,C)">element_op</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1,
<a name="l00322"></a>00322                       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a>, <a class="code" href="structviennacl_1_1op__element__unary.html" title="A tag class representing element-wise unary operations (like sin()) on vectors or matrices...">op_element_unary&lt;OP&gt;</a> &gt; <span class="keyword">const</span> &amp; proxy)
<a name="l00323"></a>00323       {
<a name="l00324"></a>00324         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.lhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00325"></a>00325         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.rhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00326"></a>00326 
<a name="l00327"></a>00327         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00328"></a>00328         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__element.html" title="Main kernel class for generating OpenCL kernels for elementwise operations other than addition and su...">viennacl::linalg::opencl::kernels::vector_element&lt;T&gt;::init</a>(ctx);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.get_kernel(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__element.html" title="Main kernel class for generating OpenCL kernels for elementwise operations other than addition and su...">viennacl::linalg::opencl::kernels::vector_element&lt;T&gt;::program_name</a>(), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#aaeb876e922457f997cd0e7f2a51c4e1d">detail::op_to_string</a>(OP()) + <span class="stringliteral">&quot;_assign&quot;</span>);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec1;
<a name="l00333"></a>00333         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1));
<a name="l00334"></a>00334         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1));
<a name="l00335"></a>00335         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1));
<a name="l00336"></a>00336         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec1));
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec2;
<a name="l00339"></a>00339         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(proxy.lhs()));
<a name="l00340"></a>00340         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(proxy.lhs()));
<a name="l00341"></a>00341         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(proxy.lhs()));
<a name="l00342"></a>00342         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(proxy.lhs()));
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00345"></a>00345                                  size_vec1,
<a name="l00346"></a>00346                                  viennacl::traits::opencl_handle(proxy.lhs()),
<a name="l00347"></a>00347                                  size_vec2)
<a name="l00348"></a>00348                               );
<a name="l00349"></a>00349       }
<a name="l00350"></a>00350 
<a name="l00352"></a>00352 
<a name="l00359"></a>00359       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00360"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a">00360</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a" title="Computes the partial inner product of two vectors - implementation. Library users should call inner_p...">inner_prod_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec1,
<a name="l00361"></a>00361                            <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec2,
<a name="l00362"></a>00362                            <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; partial_result)
<a name="l00363"></a>00363       {
<a name="l00364"></a>00364         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00365"></a>00365         assert(viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(partial_result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00368"></a>00368         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2))
<a name="l00371"></a>00371               &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Incompatible vector sizes in inner_prod_impl()!&quot;</span>));
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;inner_prod1&quot;</span>);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         assert( (k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>() / k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>() &lt;= partial_result.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch for partial reduction in inner_prod_impl()&quot;</span>) );
<a name="l00376"></a>00376 
<a name="l00377"></a>00377         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec1;
<a name="l00378"></a>00378         size_vec1.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1));
<a name="l00379"></a>00379         size_vec1.stride = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1));
<a name="l00380"></a>00380         size_vec1.size   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1));
<a name="l00381"></a>00381         size_vec1.internal_size   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec1));
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec2;
<a name="l00384"></a>00384         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2));
<a name="l00385"></a>00385         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2));
<a name="l00386"></a>00386         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2));
<a name="l00387"></a>00387         size_vec2.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec2));
<a name="l00388"></a>00388 
<a name="l00389"></a>00389         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00390"></a>00390                                  size_vec1,
<a name="l00391"></a>00391                                  viennacl::traits::opencl_handle(vec2),
<a name="l00392"></a>00392                                  size_vec2,
<a name="l00393"></a>00393                                  <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00394"></a>00394                                  viennacl::traits::opencl_handle(partial_result)
<a name="l00395"></a>00395                                 )
<a name="l00396"></a>00396                               );
<a name="l00397"></a>00397       }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 
<a name="l00400"></a>00400       <span class="comment">//implementation of inner product:</span>
<a name="l00401"></a>00401       <span class="comment">//namespace {</span>
<a name="l00408"></a>00408 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00409"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a21cf46147faedd5a95037598b93cf694">00409</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a" title="Computes the partial inner product of two vectors - implementation. Library users should call inner_p...">inner_prod_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec1,
<a name="l00410"></a>00410                            <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec2,
<a name="l00411"></a>00411                            <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;T&gt;</a> &amp; result)
<a name="l00412"></a>00412       {
<a name="l00413"></a>00413         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00414"></a>00414         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00419"></a>00419         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec1));
<a name="l00420"></a>00420         temp.<a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &#39;ALIGNMENT&#39;.">resize</a>(work_groups, ctx); <span class="comment">// bring default-constructed vectors to the correct size:</span>
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         <span class="comment">// Step 1: Compute partial inner products for each work group:</span>
<a name="l00423"></a>00423         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a" title="Computes the partial inner product of two vectors - implementation. Library users should call inner_p...">inner_prod_impl</a>(vec1, vec2, temp);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425         <span class="comment">// Step 2: Sum partial results:</span>
<a name="l00426"></a>00426         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; ksum = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;sum&quot;</span>);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00429"></a>00429         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, work_groups);
<a name="l00430"></a>00430         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00431"></a>00431                                     cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(temp)),
<a name="l00432"></a>00432                                     cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(temp)),
<a name="l00433"></a>00433                                     cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(temp)),
<a name="l00434"></a>00434                                     cl_uint(1),
<a name="l00435"></a>00435                                     <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00436"></a>00436                                     viennacl::traits::opencl_handle(result) )
<a name="l00437"></a>00437                               );
<a name="l00438"></a>00438       }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440       <span class="keyword">namespace </span>detail
<a name="l00441"></a>00441       {
<a name="l00442"></a>00442         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ScalarT&gt;
<a name="l00443"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">00443</a>         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">make_layout</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;ScalarT&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l00444"></a>00444         {
<a name="l00445"></a>00445           <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> ret;
<a name="l00446"></a>00446           ret.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>           = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec));
<a name="l00447"></a>00447           ret.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a>          = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec));
<a name="l00448"></a>00448           ret.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>            = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00449"></a>00449           ret.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00450"></a>00450           <span class="keywordflow">return</span> ret;
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453 
<a name="l00460"></a>00460       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00461"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ab7d4e89a7f0b1bebf7caef5cdbac5a5d">00461</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a" title="Computes the partial inner product of two vectors - implementation. Library users should call inner_p...">inner_prod_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; x,
<a name="l00462"></a>00462                            <a class="code" href="classviennacl_1_1vector__tuple.html" title="Tuple class holding pointers to multiple vectors. Mainly used as a temporary object returned from vie...">vector_tuple&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec_tuple,
<a name="l00463"></a>00463                            <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; result)
<a name="l00464"></a>00464       {
<a name="l00465"></a>00465         assert(viennacl::traits::opencl_handle(x).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(x).context());
<a name="l00468"></a>00468         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00469"></a>00469         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__multi__inner__prod.html" title="Main kernel class for generating OpenCL kernels for multiple inner products on/with viennacl::vector&lt;...">viennacl::linalg::opencl::kernels::vector_multi_inner_prod&lt;T&gt;::init</a>(ctx);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(x));
<a name="l00474"></a>00474         temp.<a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &#39;ALIGNMENT&#39;.">resize</a>(8 * work_groups, ctx); <span class="comment">// bring default-constructed vectors to the correct size:</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> layout_x = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(x);
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; ksum = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__multi__inner__prod.html" title="Main kernel class for generating OpenCL kernels for multiple inner products on/with viennacl::vector&lt;...">viennacl::linalg::opencl::kernels::vector_multi_inner_prod&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;sum_inner_prod&quot;</span>);
<a name="l00479"></a>00479         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; inner_prod_kernel_1 = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;inner_prod1&quot;</span>);
<a name="l00480"></a>00480         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; inner_prod_kernel_2 = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__multi__inner__prod.html" title="Main kernel class for generating OpenCL kernels for multiple inner products on/with viennacl::vector&lt;...">viennacl::linalg::opencl::kernels::vector_multi_inner_prod&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;inner_prod2&quot;</span>);
<a name="l00481"></a>00481         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; inner_prod_kernel_3 = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__multi__inner__prod.html" title="Main kernel class for generating OpenCL kernels for multiple inner products on/with viennacl::vector&lt;...">viennacl::linalg::opencl::kernels::vector_multi_inner_prod&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;inner_prod3&quot;</span>);
<a name="l00482"></a>00482         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; inner_prod_kernel_4 = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__multi__inner__prod.html" title="Main kernel class for generating OpenCL kernels for multiple inner products on/with viennacl::vector&lt;...">viennacl::linalg::opencl::kernels::vector_multi_inner_prod&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;inner_prod4&quot;</span>);
<a name="l00483"></a>00483         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; inner_prod_kernel_8 = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector__multi__inner__prod.html" title="Main kernel class for generating OpenCL kernels for multiple inner products on/with viennacl::vector&lt;...">viennacl::linalg::opencl::kernels::vector_multi_inner_prod&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;inner_prod8&quot;</span>);
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> current_index = 0;
<a name="l00486"></a>00486         <span class="keywordflow">while</span> (current_index &lt; vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#a9364bc941f9a9bd1d2a6e5cf892507c1">const_size</a>())
<a name="l00487"></a>00487         {
<a name="l00488"></a>00488           <span class="keywordflow">switch</span> (vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#a9364bc941f9a9bd1d2a6e5cf892507c1">const_size</a>() - current_index)
<a name="l00489"></a>00489           {
<a name="l00490"></a>00490             <span class="keywordflow">case</span> 7:
<a name="l00491"></a>00491             <span class="keywordflow">case</span> 6:
<a name="l00492"></a>00492             <span class="keywordflow">case</span> 5:
<a name="l00493"></a>00493             <span class="keywordflow">case</span> 4:
<a name="l00494"></a>00494             {
<a name="l00495"></a>00495               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y0 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index    );
<a name="l00496"></a>00496               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y1 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 1);
<a name="l00497"></a>00497               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y2 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 2);
<a name="l00498"></a>00498               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y3 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 3);
<a name="l00499"></a>00499               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(inner_prod_kernel_4( viennacl::traits::opencl_handle(x), layout_x,
<a name="l00500"></a>00500                                                          viennacl::traits::opencl_handle(y0), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y0),
<a name="l00501"></a>00501                                                          viennacl::traits::opencl_handle(y1), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y1),
<a name="l00502"></a>00502                                                          viennacl::traits::opencl_handle(y2), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y2),
<a name="l00503"></a>00503                                                          viennacl::traits::opencl_handle(y3), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y3),
<a name="l00504"></a>00504                                                          <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 4 * inner_prod_kernel_4.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00505"></a>00505                                                          viennacl::traits::opencl_handle(temp)
<a name="l00506"></a>00506                                                         ) );
<a name="l00507"></a>00507 
<a name="l00508"></a>00508               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00509"></a>00509               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, 4 * work_groups);
<a name="l00510"></a>00510               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00511"></a>00511                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 4 * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00512"></a>00512                                           viennacl::traits::opencl_handle(result),
<a name="l00513"></a>00513                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result) + current_index * <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00514"></a>00514                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result))
<a name="l00515"></a>00515                                           )
<a name="l00516"></a>00516                                     );
<a name="l00517"></a>00517             }
<a name="l00518"></a>00518               current_index += 4;
<a name="l00519"></a>00519               <span class="keywordflow">break</span>;
<a name="l00520"></a>00520 
<a name="l00521"></a>00521             <span class="keywordflow">case</span> 3:
<a name="l00522"></a>00522             {
<a name="l00523"></a>00523               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y0 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index    );
<a name="l00524"></a>00524               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y1 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 1);
<a name="l00525"></a>00525               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y2 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 2);
<a name="l00526"></a>00526               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(inner_prod_kernel_3( viennacl::traits::opencl_handle(x), layout_x,
<a name="l00527"></a>00527                                                           viennacl::traits::opencl_handle(y0), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y0),
<a name="l00528"></a>00528                                                           viennacl::traits::opencl_handle(y1), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y1),
<a name="l00529"></a>00529                                                           viennacl::traits::opencl_handle(y2), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y2),
<a name="l00530"></a>00530                                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 3 * inner_prod_kernel_3.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00531"></a>00531                                                           viennacl::traits::opencl_handle(temp)
<a name="l00532"></a>00532                                                          ) );
<a name="l00533"></a>00533 
<a name="l00534"></a>00534               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00535"></a>00535               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, 3 * work_groups);
<a name="l00536"></a>00536               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00537"></a>00537                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 3 * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00538"></a>00538                                           viennacl::traits::opencl_handle(result),
<a name="l00539"></a>00539                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result) + current_index * <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00540"></a>00540                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result))
<a name="l00541"></a>00541                                           )
<a name="l00542"></a>00542                                     );
<a name="l00543"></a>00543             }
<a name="l00544"></a>00544               current_index += 3;
<a name="l00545"></a>00545               <span class="keywordflow">break</span>;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547             <span class="keywordflow">case</span> 2:
<a name="l00548"></a>00548             {
<a name="l00549"></a>00549               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y0 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index    );
<a name="l00550"></a>00550               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y1 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 1);
<a name="l00551"></a>00551               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(inner_prod_kernel_2( viennacl::traits::opencl_handle(x), layout_x,
<a name="l00552"></a>00552                                                           viennacl::traits::opencl_handle(y0), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y0),
<a name="l00553"></a>00553                                                           viennacl::traits::opencl_handle(y1), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y1),
<a name="l00554"></a>00554                                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 2 * inner_prod_kernel_2.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00555"></a>00555                                                           viennacl::traits::opencl_handle(temp)
<a name="l00556"></a>00556                                                         ) );
<a name="l00557"></a>00557 
<a name="l00558"></a>00558               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00559"></a>00559               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, 2 * work_groups);
<a name="l00560"></a>00560               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00561"></a>00561                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 2 * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00562"></a>00562                                           viennacl::traits::opencl_handle(result),
<a name="l00563"></a>00563                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result) + current_index * <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00564"></a>00564                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result))
<a name="l00565"></a>00565                                           )
<a name="l00566"></a>00566                                     );
<a name="l00567"></a>00567             }
<a name="l00568"></a>00568               current_index += 2;
<a name="l00569"></a>00569               <span class="keywordflow">break</span>;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571             <span class="keywordflow">case</span> 1:
<a name="l00572"></a>00572             {
<a name="l00573"></a>00573               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y0 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index    );
<a name="l00574"></a>00574               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(inner_prod_kernel_1( viennacl::traits::opencl_handle(x), layout_x,
<a name="l00575"></a>00575                                                           viennacl::traits::opencl_handle(y0), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y0),
<a name="l00576"></a>00576                                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 1 * inner_prod_kernel_1.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00577"></a>00577                                                           viennacl::traits::opencl_handle(temp)
<a name="l00578"></a>00578                                                         ) );
<a name="l00579"></a>00579 
<a name="l00580"></a>00580               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00581"></a>00581               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, 1 * work_groups);
<a name="l00582"></a>00582               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00583"></a>00583                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 1 * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00584"></a>00584                                           viennacl::traits::opencl_handle(result),
<a name="l00585"></a>00585                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result) + current_index * <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00586"></a>00586                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result))
<a name="l00587"></a>00587                                           )
<a name="l00588"></a>00588                                     );
<a name="l00589"></a>00589             }
<a name="l00590"></a>00590               current_index += 1;
<a name="l00591"></a>00591               <span class="keywordflow">break</span>;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593             <span class="keywordflow">default</span>: <span class="comment">//8 or more vectors</span>
<a name="l00594"></a>00594             {
<a name="l00595"></a>00595               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y0 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index    );
<a name="l00596"></a>00596               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y1 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 1);
<a name="l00597"></a>00597               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y2 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 2);
<a name="l00598"></a>00598               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y3 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 3);
<a name="l00599"></a>00599               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y4 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 4);
<a name="l00600"></a>00600               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y5 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 5);
<a name="l00601"></a>00601               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y6 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 6);
<a name="l00602"></a>00602               <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; y7 = vec_tuple.<a class="code" href="classviennacl_1_1vector__tuple.html#afdfba64f75307b3a4d9abe560e0cf3c2">const_at</a>(current_index + 7);
<a name="l00603"></a>00603               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(inner_prod_kernel_8( viennacl::traits::opencl_handle(x), layout_x,
<a name="l00604"></a>00604                                                           viennacl::traits::opencl_handle(y0), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y0),
<a name="l00605"></a>00605                                                           viennacl::traits::opencl_handle(y1), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y1),
<a name="l00606"></a>00606                                                           viennacl::traits::opencl_handle(y2), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y2),
<a name="l00607"></a>00607                                                           viennacl::traits::opencl_handle(y3), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y3),
<a name="l00608"></a>00608                                                           viennacl::traits::opencl_handle(y4), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y4),
<a name="l00609"></a>00609                                                           viennacl::traits::opencl_handle(y5), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y5),
<a name="l00610"></a>00610                                                           viennacl::traits::opencl_handle(y6), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y6),
<a name="l00611"></a>00611                                                           viennacl::traits::opencl_handle(y7), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a3752cc74fec3ab6b9b00d98145b3e623">detail::make_layout</a>(y7),
<a name="l00612"></a>00612                                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 8 * inner_prod_kernel_8.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00613"></a>00613                                                           viennacl::traits::opencl_handle(temp)
<a name="l00614"></a>00614                                                         ) );
<a name="l00615"></a>00615 
<a name="l00616"></a>00616               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00617"></a>00617               ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, 8 * work_groups);
<a name="l00618"></a>00618               <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00619"></a>00619                                           <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * 8 * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00620"></a>00620                                           viennacl::traits::opencl_handle(result),
<a name="l00621"></a>00621                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result) + current_index * <a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00622"></a>00622                                           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result))
<a name="l00623"></a>00623                                           )
<a name="l00624"></a>00624                                     );
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626               current_index += 8;
<a name="l00627"></a>00627               <span class="keywordflow">break</span>;
<a name="l00628"></a>00628           }
<a name="l00629"></a>00629         }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631       }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 
<a name="l00634"></a>00634       <span class="comment">//implementation of inner product:</span>
<a name="l00635"></a>00635       <span class="comment">//namespace {</span>
<a name="l00642"></a>00642 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00643"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa3db821922ad772f03e524d7dabc022d">00643</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa3db821922ad772f03e524d7dabc022d" title="Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1...">inner_prod_cpu</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec1,
<a name="l00644"></a>00644                           <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec2,
<a name="l00645"></a>00645                           T &amp; result)
<a name="l00646"></a>00646       {
<a name="l00647"></a>00647         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00652"></a>00652         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec1));
<a name="l00653"></a>00653         temp.<a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &#39;ALIGNMENT&#39;.">resize</a>(work_groups, ctx); <span class="comment">// bring default-constructed vectors to the correct size:</span>
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         <span class="comment">// Step 1: Compute partial inner products for each work group:</span>
<a name="l00656"></a>00656         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1adcbf3b6d428fc941484c35ce7e083a" title="Computes the partial inner product of two vectors - implementation. Library users should call inner_p...">inner_prod_impl</a>(vec1, vec2, temp);
<a name="l00657"></a>00657 
<a name="l00658"></a>00658         <span class="comment">// Step 2: Sum partial results:</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         <span class="comment">// Now copy partial results from GPU back to CPU and run reduction there:</span>
<a name="l00661"></a>00661         std::vector&lt;T&gt; temp_cpu(work_groups);
<a name="l00662"></a>00662         <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(temp.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), temp.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), temp_cpu.begin());
<a name="l00663"></a>00663 
<a name="l00664"></a>00664         result = 0;
<a name="l00665"></a>00665         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;T&gt;::const_iterator it = temp_cpu.begin(); it != temp_cpu.end(); ++it)
<a name="l00666"></a>00666           result += *it;
<a name="l00667"></a>00667       }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 
<a name="l00671"></a>00671 
<a name="l00678"></a>00678       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00679"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8">00679</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00680"></a>00680                                <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; partial_result,
<a name="l00681"></a>00681                                 cl_uint norm_id)
<a name="l00682"></a>00682       {
<a name="l00683"></a>00683         assert(viennacl::traits::opencl_handle(vec).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(partial_result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec).context());
<a name="l00686"></a>00686         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;norm&quot;</span>);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690         assert( (k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>() / k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>() &lt;= partial_result.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>()) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch for partial reduction in norm_reduction_impl()&quot;</span>) );
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec),
<a name="l00693"></a>00693                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec)),
<a name="l00694"></a>00694                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec)),
<a name="l00695"></a>00695                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec)),
<a name="l00696"></a>00696                                  cl_uint(norm_id),
<a name="l00697"></a>00697                                  <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00698"></a>00698                                  viennacl::traits::opencl_handle(partial_result) )
<a name="l00699"></a>00699                               );
<a name="l00700"></a>00700       }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 
<a name="l00704"></a>00704 
<a name="l00710"></a>00710       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00711"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1ec36a29b89412455b3392fbca312a24">00711</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a1ec36a29b89412455b3392fbca312a24" title="Computes the l^1-norm of a vector.">norm_1_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00712"></a>00712                        <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;T&gt;</a> &amp; result)
<a name="l00713"></a>00713       {
<a name="l00714"></a>00714         assert(viennacl::traits::opencl_handle(vec).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec).context());
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00719"></a>00719         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec));
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         <span class="comment">// Step 1: Compute the partial work group results</span>
<a name="l00722"></a>00722         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(vec, temp, 1);
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         <span class="comment">// Step 2: Compute the partial reduction using OpenCL</span>
<a name="l00725"></a>00725         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; ksum = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;sum&quot;</span>);
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00728"></a>00728         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, work_groups);
<a name="l00729"></a>00729         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(ksum(viennacl::traits::opencl_handle(temp),
<a name="l00730"></a>00730                                     cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(temp)),
<a name="l00731"></a>00731                                     cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(temp)),
<a name="l00732"></a>00732                                     cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(temp)),
<a name="l00733"></a>00733                                     cl_uint(1),
<a name="l00734"></a>00734                                     <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00735"></a>00735                                     result)
<a name="l00736"></a>00736                               );
<a name="l00737"></a>00737       }
<a name="l00738"></a>00738 
<a name="l00744"></a>00744       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00745"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a61ed84aaf76cd26e36ef91598dc2f748">00745</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a61ed84aaf76cd26e36ef91598dc2f748" title="Computes the l^1-norm of a vector with final reduction on CPU.">norm_1_cpu</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00746"></a>00746                       T &amp; result)
<a name="l00747"></a>00747       {
<a name="l00748"></a>00748         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00749"></a>00749         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec));
<a name="l00750"></a>00750 
<a name="l00751"></a>00751         <span class="comment">// Step 1: Compute the partial work group results</span>
<a name="l00752"></a>00752         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(vec, temp, 1);
<a name="l00753"></a>00753 
<a name="l00754"></a>00754         <span class="comment">// Step 2: Now copy partial results from GPU back to CPU and run reduction there:</span>
<a name="l00755"></a>00755         <span class="keyword">typedef</span> std::vector&lt;typename viennacl::result_of::cl_type&lt;T&gt;::type&gt;  CPUVectorType;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         CPUVectorType temp_cpu(work_groups);
<a name="l00758"></a>00758         <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(temp.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), temp.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), temp_cpu.begin());
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         result = 0;
<a name="l00761"></a>00761         <span class="keywordflow">for</span> (<span class="keyword">typename</span> CPUVectorType::const_iterator it = temp_cpu.begin(); it != temp_cpu.end(); ++it)
<a name="l00762"></a>00762           result += static_cast&lt;T&gt;(*it);
<a name="l00763"></a>00763       }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 
<a name="l00775"></a>00775       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00776"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a430b9424a974bdacda10b5a323976c0a">00776</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a430b9424a974bdacda10b5a323976c0a" title="Computes the l^2-norm of a vector - implementation using OpenCL summation at second step...">norm_2_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00777"></a>00777                        <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;T&gt;</a> &amp; result)
<a name="l00778"></a>00778       {
<a name="l00779"></a>00779         assert(viennacl::traits::opencl_handle(vec).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00780"></a>00780 
<a name="l00781"></a>00781         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec).context());
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00784"></a>00784         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec));
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="comment">// Step 1: Compute the partial work group results</span>
<a name="l00787"></a>00787         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(vec, temp, 2);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789         <span class="comment">// Step 2: Reduction via OpenCL</span>
<a name="l00790"></a>00790         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; ksum = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;sum&quot;</span>);
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00793"></a>00793         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, work_groups);
<a name="l00794"></a>00794         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>( ksum(viennacl::traits::opencl_handle(temp),
<a name="l00795"></a>00795                                       cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(temp)),
<a name="l00796"></a>00796                                       cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(temp)),
<a name="l00797"></a>00797                                       cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(temp)),
<a name="l00798"></a>00798                                       cl_uint(2),
<a name="l00799"></a>00799                                       <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00800"></a>00800                                       result)
<a name="l00801"></a>00801                               );
<a name="l00802"></a>00802       }
<a name="l00803"></a>00803 
<a name="l00809"></a>00809       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00810"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a500313611da0259aa03e288bac20eccb">00810</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a500313611da0259aa03e288bac20eccb" title="Computes the l^1-norm of a vector with final reduction on CPU.">norm_2_cpu</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00811"></a>00811                       T &amp; result)
<a name="l00812"></a>00812       {
<a name="l00813"></a>00813         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00814"></a>00814         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec));
<a name="l00815"></a>00815 
<a name="l00816"></a>00816         <span class="comment">// Step 1: Compute the partial work group results</span>
<a name="l00817"></a>00817         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(vec, temp, 2);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819         <span class="comment">// Step 2: Now copy partial results from GPU back to CPU and run reduction there:</span>
<a name="l00820"></a>00820         <span class="keyword">typedef</span> std::vector&lt;typename viennacl::result_of::cl_type&lt;T&gt;::type&gt;  CPUVectorType;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822         CPUVectorType temp_cpu(work_groups);
<a name="l00823"></a>00823         <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(temp.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), temp.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), temp_cpu.begin());
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         result = 0;
<a name="l00826"></a>00826         <span class="keywordflow">for</span> (<span class="keyword">typename</span> CPUVectorType::const_iterator it = temp_cpu.begin(); it != temp_cpu.end(); ++it)
<a name="l00827"></a>00827           result += static_cast&lt;T&gt;(*it);
<a name="l00828"></a>00828         result = std::sqrt(result);
<a name="l00829"></a>00829       }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 
<a name="l00834"></a>00834 
<a name="l00840"></a>00840       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00841"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3448fa94672822135d5c8ca665543ad6">00841</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3448fa94672822135d5c8ca665543ad6" title="Computes the supremum-norm of a vector.">norm_inf_impl</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00842"></a>00842                          <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;T&gt;</a> &amp; result)
<a name="l00843"></a>00843       {
<a name="l00844"></a>00844         assert(viennacl::traits::opencl_handle(vec).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(result).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec).context());
<a name="l00847"></a>00847 
<a name="l00848"></a>00848         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00849"></a>00849         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec));
<a name="l00850"></a>00850 
<a name="l00851"></a>00851         <span class="comment">// Step 1: Compute the partial work group results</span>
<a name="l00852"></a>00852         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(vec, temp, 0);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="comment">//part 2: parallel reduction of reduced kernel:</span>
<a name="l00855"></a>00855         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; ksum = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;sum&quot;</span>);
<a name="l00856"></a>00856         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, work_groups);
<a name="l00857"></a>00857         ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, work_groups);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>( ksum(viennacl::traits::opencl_handle(temp),
<a name="l00860"></a>00860                                      cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(temp)),
<a name="l00861"></a>00861                                      cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(temp)),
<a name="l00862"></a>00862                                      cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(temp)),
<a name="l00863"></a>00863                                      cl_uint(0),
<a name="l00864"></a>00864                                      <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * ksum.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00865"></a>00865                                      result)
<a name="l00866"></a>00866                               );
<a name="l00867"></a>00867       }
<a name="l00868"></a>00868 
<a name="l00874"></a>00874       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00875"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a4fad07ab525d7540817ecd9006a8bcc8">00875</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a4fad07ab525d7540817ecd9006a8bcc8" title="Computes the supremum-norm of a vector.">norm_inf_cpu</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec,
<a name="l00876"></a>00876                         T &amp; result)
<a name="l00877"></a>00877       {
<a name="l00878"></a>00878         <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> work_groups = 128;
<a name="l00879"></a>00879         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;T&gt;</a> temp(work_groups, <a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">viennacl::traits::context</a>(vec));
<a name="l00880"></a>00880 
<a name="l00881"></a>00881         <span class="comment">// Step 1: Compute the partial work group results</span>
<a name="l00882"></a>00882         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ad44f85d3504ba0dc38d734f14ec92de8" title="Computes the partial work group results for vector norms.">norm_reduction_impl</a>(vec, temp, 0);
<a name="l00883"></a>00883 
<a name="l00884"></a>00884         <span class="comment">// Step 2: Now copy partial results from GPU back to CPU and run reduction there:</span>
<a name="l00885"></a>00885         <span class="keyword">typedef</span> std::vector&lt;typename viennacl::result_of::cl_type&lt;T&gt;::type&gt;  CPUVectorType;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887         CPUVectorType temp_cpu(work_groups);
<a name="l00888"></a>00888         <a class="code" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">viennacl::fast_copy</a>(temp.<a class="code" href="classviennacl_1_1vector__base.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like)">begin</a>(), temp.<a class="code" href="classviennacl_1_1vector__base.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like)">end</a>(), temp_cpu.begin());
<a name="l00889"></a>00889 
<a name="l00890"></a>00890         result = 0;
<a name="l00891"></a>00891         <span class="keywordflow">for</span> (<span class="keyword">typename</span> CPUVectorType::const_iterator it = temp_cpu.begin(); it != temp_cpu.end(); ++it)
<a name="l00892"></a>00892           result = std::max(result, static_cast&lt;T&gt;(*it));
<a name="l00893"></a>00893       }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 
<a name="l00897"></a>00897 
<a name="l00898"></a>00898       <span class="comment">//This function should return a CPU scalar, otherwise statements like</span>
<a name="l00899"></a>00899       <span class="comment">// vcl_rhs[index_norm_inf(vcl_rhs)]</span>
<a name="l00900"></a>00900       <span class="comment">// are ambiguous</span>
<a name="l00906"></a>00906 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00907"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae19ed387707bd0b8721dd7acb150b2d8">00907</a>       cl_uint <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae19ed387707bd0b8721dd7acb150b2d8" title="Computes the index of the first entry that is equal to the supremum-norm in modulus.">index_norm_inf</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> <span class="keyword">const</span> &amp; vec)
<a name="l00908"></a>00908       {
<a name="l00909"></a>00909         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec).context());
<a name="l00910"></a>00910         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> h = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#af87d9a54fa10355821a4c314a7b17cf2" title="Creates a memory buffer within the context.">create_memory</a>(CL_MEM_READ_WRITE, <span class="keyword">sizeof</span>(cl_uint));
<a name="l00913"></a>00913 
<a name="l00914"></a>00914         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;index_norm_inf&quot;</span>);
<a name="l00915"></a>00915         <span class="comment">//cl_uint size = static_cast&lt;cl_uint&gt;(vcl_vec.internal_size());</span>
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="comment">//TODO: Use multi-group kernel for large vector sizes</span>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>());
<a name="l00920"></a>00920         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec),
<a name="l00921"></a>00921                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec)),
<a name="l00922"></a>00922                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec)),
<a name="l00923"></a>00923                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec)),
<a name="l00924"></a>00924                                  <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cl__type.html#a565429e62c1d4fd084335146ba778e17">viennacl::result_of::cl_type&lt;T&gt;::type</a>) * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()),
<a name="l00925"></a>00925                                  <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(cl_uint) * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>()), h));
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         <span class="comment">//read value:</span>
<a name="l00928"></a>00928         cl_uint result;
<a name="l00929"></a>00929         cl_int err = clEnqueueReadBuffer(ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a86cc988061d4ef54550a572141ebbee5">get_queue</a>().<a class="code" href="classviennacl_1_1ocl_1_1command__queue.html#a8c301f0516a039dbac9b263be6e70815">handle</a>().<a class="code" href="classviennacl_1_1ocl_1_1handle.html#a0f432d9c11ccab11ef350affd8791e47">get</a>(), h.<a class="code" href="classviennacl_1_1ocl_1_1handle.html#a0f432d9c11ccab11ef350affd8791e47">get</a>(), CL_TRUE, 0, <span class="keyword">sizeof</span>(cl_uint), &amp;result, 0, NULL, NULL);
<a name="l00930"></a>00930         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00931"></a>00931         <span class="keywordflow">return</span> result;
<a name="l00932"></a>00932       }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934       <span class="comment">//TODO: Special case vec1 == vec2 allows improvement!!</span>
<a name="l00944"></a>00944 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00945"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a7cf8faf72604a859321348b7fb549420">00945</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a7cf8faf72604a859321348b7fb549420" title="Computes a plane rotation of two vectors.">plane_rotation</a>(<a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec1,
<a name="l00946"></a>00946                           <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;T&gt;</a> &amp; vec2,
<a name="l00947"></a>00947                           T alpha, T beta)
<a name="l00948"></a>00948       {
<a name="l00949"></a>00949         assert(viennacl::traits::opencl_handle(vec1).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(vec2).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Operands do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec1).context());
<a name="l00952"></a>00952         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::init</a>(ctx);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         assert(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2));
<a name="l00955"></a>00955         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;T&gt;::program_name</a>(), <span class="stringliteral">&quot;plane_rotation&quot;</span>);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(vec1),
<a name="l00958"></a>00958                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1)),
<a name="l00959"></a>00959                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1)),
<a name="l00960"></a>00960                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1)),
<a name="l00961"></a>00961                                  viennacl::traits::opencl_handle(vec2),
<a name="l00962"></a>00962                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2)),
<a name="l00963"></a>00963                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2)),
<a name="l00964"></a>00964                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2)),
<a name="l00965"></a>00965                                  viennacl::traits::opencl_handle(alpha),
<a name="l00966"></a>00966                                  viennacl::traits::opencl_handle(beta))
<a name="l00967"></a>00967                               );
<a name="l00968"></a>00968       }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     } <span class="comment">//namespace opencl</span>
<a name="l00971"></a>00971   } <span class="comment">//namespace linalg</span>
<a name="l00972"></a>00972 } <span class="comment">//namespace viennacl</span>
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:34 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
