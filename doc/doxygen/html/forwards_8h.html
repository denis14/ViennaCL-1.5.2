<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/forwards.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl/forwards.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides the forward declarations for the main types used within ViennaCL.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br/>
<code>#include &lt;cassert&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &quot;<a class="el" href="enable__if_8hpp_source.html">viennacl/meta/enable_if.hpp</a>&quot;</code><br/>
</div>
<p><a href="forwards_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__assign.html">op_assign</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing assignment.  <a href="structviennacl_1_1op__assign.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__add.html">op_inplace_add</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace addition.  <a href="structviennacl_1_1op__inplace__add.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__sub.html">op_inplace_sub</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace subtraction.  <a href="structviennacl_1_1op__inplace__sub.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__add.html">op_add</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing addition.  <a href="structviennacl_1_1op__add.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sub.html">op_sub</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing subtraction.  <a href="structviennacl_1_1op__sub.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mult.html">op_mult</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing multiplication by a scalar.  <a href="structviennacl_1_1op__mult.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__prod.html">op_prod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-vector products and element-wise multiplications.  <a href="structviennacl_1_1op__prod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mat__mat__prod.html">op_mat_mat_prod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-matrix products.  <a href="structviennacl_1_1op__mat__mat__prod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__div.html">op_div</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing division.  <a href="structviennacl_1_1op__div.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__pow.html">op_pow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the power function.  <a href="structviennacl_1_1op__pow.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary&lt; OP &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise binary operations (like multiplication) on vectors or matrices.  <a href="structviennacl_1_1op__element__binary.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__unary.html">op_element_unary&lt; OP &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise unary operations (like sin()) on vectors or matrices.  <a href="structviennacl_1_1op__element__unary.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__abs.html">op_abs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the modulus function for integers.  <a href="structviennacl_1_1op__abs.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__acos.html">op_acos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the acos() function.  <a href="structviennacl_1_1op__acos.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__asin.html">op_asin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the asin() function.  <a href="structviennacl_1_1op__asin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan.html">op_atan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan() function.  <a href="structviennacl_1_1op__atan.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan2.html">op_atan2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan2() function.  <a href="structviennacl_1_1op__atan2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__ceil.html">op_ceil</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the ceil() function.  <a href="structviennacl_1_1op__ceil.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cos.html">op_cos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cos() function.  <a href="structviennacl_1_1op__cos.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cosh.html">op_cosh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cosh() function.  <a href="structviennacl_1_1op__cosh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__exp.html">op_exp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the exp() function.  <a href="structviennacl_1_1op__exp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fabs.html">op_fabs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fabs() function.  <a href="structviennacl_1_1op__fabs.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fdim.html">op_fdim</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fdim() function.  <a href="structviennacl_1_1op__fdim.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__floor.html">op_floor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the floor() function.  <a href="structviennacl_1_1op__floor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmax.html">op_fmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmax() function.  <a href="structviennacl_1_1op__fmax.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmin.html">op_fmin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmin() function.  <a href="structviennacl_1_1op__fmin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmod.html">op_fmod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmod() function.  <a href="structviennacl_1_1op__fmod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log.html">op_log</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log() function.  <a href="structviennacl_1_1op__log.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log10.html">op_log10</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log10() function.  <a href="structviennacl_1_1op__log10.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sin.html">op_sin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sin() function.  <a href="structviennacl_1_1op__sin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sinh.html">op_sinh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sinh() function.  <a href="structviennacl_1_1op__sinh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sqrt.html">op_sqrt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sqrt() function.  <a href="structviennacl_1_1op__sqrt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tan.html">op_tan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tan() function.  <a href="structviennacl_1_1op__tan.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tanh.html">op_tanh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tanh() function.  <a href="structviennacl_1_1op__tanh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the (off-)diagonal of a matrix.  <a href="structviennacl_1_1op__matrix__diag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a matrix given by a vector placed on a certain (off-)diagonal.  <a href="structviennacl_1_1op__vector__diag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__row.html">op_row</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix row to a vector.  <a href="structviennacl_1_1op__row.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__column.html">op_column</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix column to a vector.  <a href="structviennacl_1_1op__column.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inner__prod.html">op_inner_prod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inner products of two vectors.  <a href="structviennacl_1_1op__inner__prod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__1.html">op_norm_1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 1-norm of a vector.  <a href="structviennacl_1_1op__norm__1.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__2.html">op_norm_2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 2-norm of a vector.  <a href="structviennacl_1_1op__norm__2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__inf.html">op_norm_inf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the inf-norm of a vector.  <a href="structviennacl_1_1op__norm__inf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__frobenius.html">op_norm_frobenius</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the Frobenius-norm of a matrix.  <a href="structviennacl_1_1op__norm__frobenius.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__trans.html">op_trans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing transposed matrices.  <a href="structviennacl_1_1op__trans.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__flip__sign.html">op_flip_sign</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing sign flips (for scalars only. Vectors and matrices use the standard multiplication by the scalar -1.0)  <a href="structviennacl_1_1op__flip__sign.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major__tag.html">row_major_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating row-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix.">row_major</a> type.  <a href="structviennacl_1_1row__major__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major__tag.html">column_major_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating column-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix.">row_major</a> type.  <a href="structviennacl_1_1column__major__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">column_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for column-major storage of a dense matrix.  <a href="structviennacl_1_1column__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__cpu__scalar.html">is_cpu_scalar&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a host scalar type (e.g. float, double)  <a href="structviennacl_1_1is__cpu__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__scalar.html">is_scalar&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__flip__sign__scalar.html">is_flip_sign_scalar&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type represents a sign flip on a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__flip__sign__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__scalar.html">is_any_scalar&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether the provided type represents a scalar (either host, from ViennaCL, or a flip-sign proxy)  <a href="structviennacl_1_1is__any__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__vector.html">is_any_vector&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for a type being either <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base</a> or <a class="el" href="classviennacl_1_1implicit__vector__base.html" title="Common base class for representing vectors where the entries are not all stored explicitly.">implicit_vector_base</a>.  <a href="structviennacl_1_1is__any__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__matrix.html">is_any_dense_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for either <a class="el" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base</a> or <a class="el" href="classviennacl_1_1implicit__matrix__base.html" title="Base class for representing matrices where the individual entries are not all stored explicitly...">implicit_matrix_base</a>.  <a href="structviennacl_1_1is__any__dense__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__row__major.html">is_row_major&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix has a row-major layout.  <a href="structviennacl_1_1is__row__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__compressed__matrix.html">is_compressed_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> (CSR format)  <a href="structviennacl_1_1is__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__coordinate__matrix.html">is_coordinate_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> (COO format)  <a href="structviennacl_1_1is__coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ell__matrix.html">is_ell_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is an <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros.">ell_matrix</a> (ELL format)  <a href="structviennacl_1_1is__ell__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hyb__matrix.html">is_hyb_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a> (hybrid format: ELL plus CSR)  <a href="structviennacl_1_1is__hyb__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">is_any_sparse_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is one of the sparse matrix types (<a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>, <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>, etc.)  <a href="structviennacl_1_1is__any__sparse__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__circulant__matrix.html">is_circulant_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a circulant matrix.  <a href="structviennacl_1_1is__circulant__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hankel__matrix.html">is_hankel_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Hankel matrix.  <a href="structviennacl_1_1is__hankel__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__toeplitz__matrix.html">is_toeplitz_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Toeplitz matrix.  <a href="structviennacl_1_1is__toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__vandermonde__matrix.html">is_vandermonde_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Vandermonde matrix.  <a href="structviennacl_1_1is__vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">is_any_dense_structured_matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is any of the dense structured matrix types (circulant, Hankel, etc.)  <a href="structviennacl_1_1is__any__dense__structured__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1memory__exception.html">memory_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class in case of memory errors.  <a href="classviennacl_1_1memory__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1cuda__not__available__exception.html">cuda_not_available_exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html">MATRIX_ITERATOR_INCREMENTER&lt; ROWCOL, MATRIXTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for incrementing an iterator in a dense matrix.  <a href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">no_precond</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html">viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">viennacl::tools</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace for various tools used within ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">viennacl::linalg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides all linear algebra operations which are not covered by operator overloads. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html">viennacl::linalg::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding implementation details for linear algebra routines. Usually not of interest for a library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend.html">viennacl::backend</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing routines for handling the different memory domains. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cpu__ram.html">viennacl::backend::cpu_ram</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides implementations for handling memory buffers in CPU RAM. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cpu__ram_1_1detail.html">viennacl::backend::cpu_ram::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for handling memory buffers in CPU RAM. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cuda.html">viennacl::backend::cuda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides implementations for handling CUDA memory buffers. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1cuda_1_1detail.html">viennacl::backend::cuda::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for handling CUDA memory buffers. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1detail.html">viennacl::backend::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation details for the generic memory backend interface. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1opencl.html">viennacl::backend::opencl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides implementations for handling OpenCL memory buffers. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend_1_1opencl_1_1detail.html">viennacl::backend::opencl::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for handling OpenCL memory buffers. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail.html">viennacl::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for functionality in the main viennacl-namespace. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail_1_1fft.html">viennacl::detail::fft</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper namespace for fast Fourier transforms. Not to be used directly by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail_1_1fft_1_1_f_f_t___d_a_t_a___o_r_d_e_r.html">viennacl::detail::fft::FFT_DATA_ORDER</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper namespace for fast-Fourier transformation. Deprecated. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator.html">viennacl::generator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides an OpenCL kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1autotune.html">viennacl::generator::autotune</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides the implementation for tuning the kernels for a particular device. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1detail.html">viennacl::generator::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains implementation details of the kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1profiles.html">viennacl::generator::profiles</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding the various device-specific parameters for generating the best kernels. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator_1_1utils.html">viennacl::generator::utils</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains various helper routines for kernel generation. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">viennacl::io</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides basic input-output functionality. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1detail.html">viennacl::io::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation details for IO functionality. Usually not of interest for a library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1tag.html">viennacl::io::tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding the various XML tag definitions for the kernel parameter tuning facility. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io_1_1val.html">viennacl::io::val</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace holding the various XML strings for the kernel parameter tuning facility. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda.html">viennacl::linalg::cuda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all CUDA compute kernels used by ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1cuda_1_1detail.html">viennacl::linalg::cuda::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for the CUDA linear algebra backend. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1amg.html">viennacl::linalg::detail::amg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation namespace for algebraic multigrid preconditioner. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail_1_1spai.html">viennacl::linalg::detail::spai</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation namespace for sparse approximate inverse preconditioner. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">viennacl::linalg::host_based</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html">viennacl::linalg::host_based::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for the host-based linear algebra backend. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">viennacl::linalg::kernels</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing the OpenCL kernels. Deprecated, will be moved to <a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html" title="Holds all routines providing OpenCL linear algebra operations.">viennacl::linalg::opencl</a> in future releases. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl.html">viennacl::linalg::opencl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds all routines providing OpenCL linear algebra operations. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html">viennacl::linalg::opencl::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for OpenCL-accelerated linear algebra operations. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1kernels.html">viennacl::linalg::opencl::kernels</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains the OpenCL kernel generation functions for a predefined set of functionality. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1opencl_1_1kernels_1_1detail.html">viennacl::linalg::opencl::kernels::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation details for the predefined OpenCL kernels. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">viennacl::ocl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>OpenCL backend. Manages platforms, contexts, buffers, kernels, etc. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1result__of.html">viennacl::result_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing many meta-functions. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools_1_1detail.html">viennacl::tools::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains implementation details for the tools. Usually not of interest for the library user. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">viennacl::traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing traits-information as well as generic wrappers to common routines for vectors and matrices such as <a class="el" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">size()</a> or <a class="el" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear()</a> </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler.html">viennacl::scheduler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains the scheduling functionality which allows for dynamic kernel generation as well as the fusion of multiple statements into a single kernel. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler_1_1detail.html">viennacl::scheduler::detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Implementation details for the scheduler. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler_1_1result__of.html">viennacl::scheduler::result_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper metafunctions used for the scheduler. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef basic_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef basic_slice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">slice</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">memory_types</a> { <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810">MEMORY_NOT_INITIALIZED</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c">MAIN_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001">OPENCL_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03">CUDA_MEMORY</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201">row_info_types</a> { <a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a23743f734a7f75006483fa93e9d4425a">SPARSE_ROW_NORM_INF</a> =  0, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a85db5d72f0c0ea9096cf53fcb1a330e5">SPARSE_ROW_NORM_1</a>, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a4d11d9bc162777d4b24e8e5c776af5d3">SPARSE_ROW_NORM_2</a>, 
<a class="el" href="namespaceviennacl_1_1linalg_1_1detail.html#a4740d21578da4ca92692a1076c181201a44733b01d16bdf2e70b99fbdf197ac66">SPARSE_ROW_DIAGONAL</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae90a3bfb2d1d49bb356c8f2179a685b0">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#ae90a3bfb2d1d49bb356c8f2179a685b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0d783c95a46bcb7d01000ae479a03cfc">copy</a> (const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a0d783c95a46bcb7d01000ae479a03cfc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9139574d3d99501f0ef6c3fc322e548">copy</a> (const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> (const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a815cf9646ece6cc98ec80b3f925c482d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abfe63ce6ea6eded970702b69279c37fb">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#abfe63ce6ea6eded970702b69279c37fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7b596f98d234d40fe9460d0077d1fcc3">convolve_i</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;input2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; T &gt;<br class="typebreak"/>
, const vector_base&lt; T &gt;<br class="typebreak"/>
, op_element_binary&lt; op_prod &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a28ab8924636e24b01c6bad13a7321343">element_prod</a> (vector_base&lt; T &gt; const &amp;v1, vector_base&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; T &gt;<br class="typebreak"/>
, const vector_base&lt; T &gt;<br class="typebreak"/>
, op_element_binary&lt; op_div &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3207a7759c34cfe4e961aabadd616a13">element_div</a> (vector_base&lt; T &gt; const &amp;v1, vector_base&lt; T &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab7cbb9fc8635e8ceb18dd181c0aa2324">inner_prod_impl</a> (vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - dispatcher interface.  <a href="#ab7cbb9fc8635e8ceb18dd181c0aa2324"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a84c0f006e2e4f840e0bebfd9a9fed0e8">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5006ea75a0379d56e1dd8dbf6d817a41">inner_prod_impl</a> (vector_base&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a64080f662904aa976e0767a4693211ea">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abce7fb4d0ee0a5f82313eff5b07d03cc">inner_prod_cpu</a> (vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors with the final reduction step on the CPU - dispatcher interface.  <a href="#abce7fb4d0ee0a5f82313eff5b07d03cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab92256482cf6a71434a0501847dd70fe">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abd75024e6302d26cd8f26559e9b6a31c">inner_prod_cpu</a> (vector_base&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec2, T &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 , typename S3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9c68566e658fd80448dabb02bfbf018c">inner_prod_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a546e0f416d08c99d21344dda5398859c">norm_1_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector - dispatcher interface.  <a href="#a546e0f416d08c99d21344dda5398859c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2487c579ee752a9fcc31c12d0bddf604">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acddd2a99867a55480dde2b4dba0a588c">norm_1_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU.  <a href="#acddd2a99867a55480dde2b4dba0a588c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1d55e0e715a14ef4b336c06018c38db7">norm_1_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a1d55e0e715a14ef4b336c06018c38db7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abeaca00d5581387446ab0948dde72f44">norm_2_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - dispatcher interface.  <a href="#abeaca00d5581387446ab0948dde72f44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9d1a04d42e467eb9e0cd4b3a17cfc317">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#a9d1a04d42e467eb9e0cd4b3a17cfc317"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a063fa23bfd77e19e93046d256027f438">norm_2_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - dispatcher interface.  <a href="#a063fa23bfd77e19e93046d256027f438"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a609941700fc79f0978daf50acaa93656">norm_2_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#a609941700fc79f0978daf50acaa93656"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5f7158a5f1fb8b67e2e6849b202a86a9">norm_inf_impl</a> (vector_base&lt; T &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a5f7158a5f1fb8b67e2e6849b202a86a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac8921e7938a67173daaf6c9a0e40e3e0">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector - interface for a vector expression. Creates a temporary.  <a href="#ac8921e7938a67173daaf6c9a0e40e3e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a57092218bb316cdd6e7a9e8a758f3e99">norm_inf_cpu</a> (vector_base&lt; T &gt; const &amp;vec, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector with final reduction on the CPU.  <a href="#a57092218bb316cdd6e7a9e8a758f3e99"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad0fb517b1788ab9c44ee93021c32ba3f">norm_inf_cpu</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#ad0fb517b1788ab9c44ee93021c32ba3f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afb0eb391c55fbee4c55381881fc18409">norm_frobenius_impl</a> (matrix_base&lt; T, F &gt; const &amp;A, scalar&lt; T &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius norm of a matrix - dispatcher interface.  <a href="#afb0eb391c55fbee4c55381881fc18409"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a74b07136fceb68cae137b742ec725be4">norm_frobenius_cpu</a> (matrix_base&lt; T, F &gt; const &amp;A, T &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Frobenius norm of a vector with final reduction on the CPU.  <a href="#a74b07136fceb68cae137b742ec725be4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0aa1eeb8e001a4318918cbfa023ba03d">index_norm_inf</a> (vector_base&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a0aa1eeb8e001a4318918cbfa023ba03d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vcl_size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abdcc677a25d3d7f248abced2fcd998e0">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum norm of a vector with final reduction on the CPU - interface for a vector expression. Creates a temporary.  <a href="#abdcc677a25d3d7f248abced2fcd998e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa45f913d8815ef5ca24d70443d31bd4">prod_impl</a> (const matrix_base&lt; NumericT, F &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#aaa45f913d8815ef5ca24d70443d31bd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a49db0fe7daf624d43003ec4a08f3a8a3">prod_impl</a> (const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a49db0fe7daf624d43003ec4a08f3a8a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType , class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
vector_expression&lt; const <br class="typebreak"/>
SparseMatrixType, const vector<br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae7a946e478e53f6464d1dedeb3a46c89">prod_impl</a> (const SparseMatrixType &amp;mat, const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file provides the forward declarations for the main types used within ViennaCL. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:37 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
