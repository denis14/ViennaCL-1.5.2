<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg::host_based Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>      </li>
      <li class="navelem"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html">host_based</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl::linalg::host_based Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based_1_1detail.html">detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helper functions for the host-based linear algebra backend. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notation)  <a href="#a8fff650777bb47541ee70c67a25faa00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a08c38699206e277bf5d709d0a7d652cd">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for triangular systems with multiple transposed right hand sides, i.e. A \ B^T (MATLAB notation)  <a href="#a08c38699206e277bf5d709d0a7d652cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aebc69ca6f6f56e707dfd734fa012d4cb">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for transposed triangular systems with multiple right hand sides, i.e. A^T \ B (MATLAB notation)  <a href="#aebc69ca6f6f56e707dfd734fa012d4cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8983c22febdaed6bea82107c9ee703c1">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy_A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; proxy_B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for transposed triangular systems with multiple transposed right hand sides, i.e. A^T \ B^T (MATLAB notation)  <a href="#a8983c22febdaed6bea82107c9ee703c1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a035b582c7138a65609eda6bff21eae40">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad49aa03302e698f44dbc49e81faf8c38">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#ad49aa03302e698f44dbc49e81faf8c38"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#adfca84472e63dbc714202ca8ad334f6b">am</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae021669534868a46fa9c12bc28dfc16b">ambm</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a938d7590f7d0cad34403999392e2c978">ambm_m</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a84536cf0af962f3688dc04d4411aba66">matrix_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s, bool clear=false)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad95a3b2ea4b00bae1007e468f31e5236">matrix_diagonal_assign</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, NumericT s)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac5493a4e97469b4524250d2ceccaaa2a">matrix_diag_from_vector</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, int k, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a811413a4b8f1a71ba45ec4fef6326134">matrix_diag_to_vector</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, int k, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3e4a337ad45526a3ec1c2bc0c8209033">matrix_row</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, unsigned int i, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a0b496b5209ea4553334afe9153b03814">matrix_column</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, unsigned int j, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29b57f5c2f778ce4f57def8f1ca5d174">element_op</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a>&lt; OP &gt; &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operations A = B .* C and A = B ./ C (using MATLAB syntax)  <a href="#a29b57f5c2f778ce4f57def8f1ca5d174"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a40b6232776be580875ef662a68c7df87">element_op</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;A, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__element__unary.html">op_element_unary</a>&lt; OP &gt; &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#af9f708f5debeea50a45efb78b3e1f66b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a2e3e94d4038bb010bb86023b613fa6ff">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;mat_trans, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a2e3e94d4038bb010bb86023b613fa6ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac9a523b23a6acfedb255d6bbabbe240f">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#ac9a523b23a6acfedb255d6bbabbe240f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#afe7804f787bac3c655bbde0a4d7f2f95">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#afe7804f787bac3c655bbde0a4d7f2f95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa730ef19275e56a333ea4029aa4b44c2">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#aa730ef19275e56a333ea4029aa4b44c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F1 , typename F2 , typename F3 , typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aca398a45efe3258f77a7d5cd552018f5">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F2 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#aca398a45efe3258f77a7d5cd552018f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa384630ee456868944cfa8323606e2b0">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#aa384630ee456868944cfa8323606e2b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a134c3036bc78aa3b2e391a3862a5edcf">as</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a968a4edfabb0ff2e1d0bb501841b90b9">asbs</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename ScalarType1 , typename S3 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S3 &gt;<br class="typebreak"/>
::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType1 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a><br class="typebreak"/>
&lt; ScalarType2 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a14e422765301f190830128e5422386c9">asbs_s</a> (S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value &amp;&amp;<a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a><br class="typebreak"/>
&lt; S2 &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a008702a083918762ac8a51ca2f3c332b">swap</a> (S1 &amp;s1, S2 &amp;s2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two scalars, data is copied.  <a href="#a008702a083918762ac8a51ca2f3c332b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acc0ac63dacb65197ab4db5aeb0e44df7">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#acc0ac63dacb65197ab4db5aeb0e44df7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , typename NumericT , unsigned int ALIGNMENT, typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acd0e6a78598634dea1a813eafb269a7d">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out sparse_matrix-matrix multiplication first matrix being compressed.  <a href="#acd0e6a78598634dea1a813eafb269a7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , typename NumericT , unsigned int ALIGNMENT, typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a822501f53c117d11f3bad8b932d22985">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-trans(matrix) multiplication first matrix being compressed and the second transposed.  <a href="#a822501f53c117d11f3bad8b932d22985"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae2f9a94f9f5c0e068d8126f850c7c9d9">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#ae2f9a94f9f5c0e068d8126f850c7c9d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3bda6585eb1f3a9c153537c737dd7dcd">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a3bda6585eb1f3a9c153537c737dd7dcd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad2b5d908f83ee5f0533895aed846eadf">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#ad2b5d908f83ee5f0533895aed846eadf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a1e3eabcf4e6c9aa7c2c7a942df68d409">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a1e3eabcf4e6c9aa7c2c7a942df68d409"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa7395737ad4441e78b4391c00af3c663">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#aa7395737ad4441e78b4391c00af3c663"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a92e9d5f3a337dcce673a27d12b5b8c7c">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#a92e9d5f3a337dcce673a27d12b5b8c7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a38c2e71cc1920ec5803aee5d21f98995">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a38c2e71cc1920ec5803aee5d21f98995"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a9e71fb4577e6a51a6531e35bd50ea8cf">inplace_solve</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; ScalarType, MAT_ALIGNMENT &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#a9e71fb4577e6a51a6531e35bd50ea8cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a11b48f1906ecb12900769f9aa58ca32d">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">viennacl::compressed_compressed_matrix</a>&lt; ScalarType &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a11b48f1906ecb12900769f9aa58ca32d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac823213902af7383f4fabd2f6a29ac91">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#ac823213902af7383f4fabd2f6a29ac91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT, class NumericT , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa6614a3a11d49234a8783bd3b64ee1b3">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out Compressed Matrix(COO)-Dense Matrix multiplication.  <a href="#aa6614a3a11d49234a8783bd3b64ee1b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT, class NumericT , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a0e785ca8b38f8d7b26193cc6cc36e4a4">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out Compressed Matrix(COO)-Dense Transposed Matrix multiplication.  <a href="#a0e785ca8b38f8d7b26193cc6cc36e4a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#afc2e1977cd2b6069ed9ba376bb792a98">prod_impl</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros.">ell_matrix</a>.  <a href="#afc2e1977cd2b6069ed9ba376bb792a98"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , typename NumericT , unsigned int ALIGNMENT, typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#affdbf222a5998451c2e379f997134800">prod_impl</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out ell_matrix-d_matrix multiplication.  <a href="#affdbf222a5998451c2e379f997134800"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , typename NumericT , unsigned int ALIGNMENT, typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ab28797b2134916975c5aa68efc297ed0">prod_impl</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-trans(matrix) multiplication first matrix being sparse ell and the second dense transposed.  <a href="#ab28797b2134916975c5aa68efc297ed0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ScalarType , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aea41f806a665d5b04951eb88110c729a">prod_impl</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a>.  <a href="#aea41f806a665d5b04951eb88110c729a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int ALIGNMENT, typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8edbe2f1e7bf8645257b7962ee604258">prod_impl</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; NumericT, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out sparse-matrix-dense-matrix multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a>.  <a href="#a8edbe2f1e7bf8645257b7962ee604258"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , unsigned int ALIGNMENT, typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a11745d942eea14331712994d71b386f0">prod_impl</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; NumericT, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;d_mat, <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out sparse-matrix-transposed-dense-matrix multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a>.  <a href="#a11745d942eea14331712994d71b386f0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a617cbf9eb0f3a88aff971ab66b049508">_axpy</a> (const T *, T *, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, T)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad7e5bdc48145435919a67623f54e8ede">_dot</a> (<a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, const T *, const T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#afa2d4b01b4c95465d86d804d97a22604">_dotc</a> (<a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, const T *, const T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a9aefb96d56fb6e043d0c1e616029d43b">_swap</a> (<a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, T *, T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#accbc41905fc9bf438683d5babd1de981">_copy</a> (<a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, T *, T *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acb1ad7f87afd4615a73f2e4e694c012d">_nrm2</a> (const T *, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a186586aced1407e7106fd3f7f432f582">inplace_tred2</a> (ScalarType **A, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> n, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> block_size=1, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> num_threads=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace reduction of a dense n x n row-major or column-major hermitian (or real symmetric) matrix to tridiagonal form using householder similarity transforms (preserving eigenvalues)  <a href="#a186586aced1407e7106fd3f7f432f582"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29a882acaad6a548f7fadf54598bdc42">lu_factorize_row_major</a> (ScalarType **A, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> m, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> n, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> *piv=NULL, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> block_size=8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace lu factorization of an m x n dense row-major matrix with optional partial pivoting, returning true for an even number of pivots, false for an odd number of pivots. Factorization is successful if there are no nonzero values on the diagonal.  <a href="#a29a882acaad6a548f7fadf54598bdc42"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aaa3af08473cb3a7f5116d54302c02d86">inplace_qr_col_major</a> (ScalarType **A, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> m, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> n, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> block_size=8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace qr factorization of an m x n dense column-major matrix, returning the householder normalization coefficients.  <a href="#aaa3af08473cb3a7f5116d54302c02d86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ab1ca91eea2771be83df0a807951388d3">inplace_qr_row_major</a> (ScalarType **A, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> m, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> n, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> block_size=8, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> num_threads=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace qr factorization of an m x n dense row-major matrix, returning the householder normalization coefficients.  <a href="#ab1ca91eea2771be83df0a807951388d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af05e37c76f86d33e9e7c584f5495e0bf">av</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a0652f61041eafab3078a777ed9c2f435">avbv</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename ScalarType1 , typename ScalarType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa62c4ab048cddc8e6a9b4a1a37f6060c">avbv_v</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_alpha, bool flip_sign_alpha, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>, bool reciprocal_beta, bool flip_sign_beta)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3dd84a153abaccd31996820059dce5a5">vector_assign</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, const T &amp;alpha, bool up_to_internal_size=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a constant value to a vector (-range/-slice)  <a href="#a3dd84a153abaccd31996820059dce5a5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac370a4948707c297fe7ffbc4cd532314">vector_swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#ac370a4948707c297fe7ffbc4cd532314"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a54ee137c28f964daf2115d9daa0b5f40">element_op</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, <a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a>&lt; OP &gt; &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)  <a href="#a54ee137c28f964daf2115d9daa0b5f40"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac6600d169517e2dd66c7f182334afbdb">element_op</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, <a class="el" href="structviennacl_1_1op__element__unary.html">op_element_unary</a>&lt; OP &gt; &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax)  <a href="#ac6600d169517e2dd66c7f182334afbdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3cdd8dff31ffac7296a40450b49dbf80">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec2, S3 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#a3cdd8dff31ffac7296a40450b49dbf80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a74585b0f7493cc10cbf10a20c9c37050">inner_prod_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;x, <a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; T &gt; const &amp;vec_tuple, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8edf47c18ba79b54e66c0d79f179beaf">norm_1_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^1-norm of a vector.  <a href="#a8edf47c18ba79b54e66c0d79f179beaf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3bb4cf7b8852122dc4772065f8539a59">norm_2_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the l^2-norm of a vector - implementation.  <a href="#a3bb4cf7b8852122dc4772065f8539a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5c3b448e695efcfc4ac7d0a2d924d61a">norm_inf_impl</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1, S2 &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a5c3b448e695efcfc4ac7d0a2d924d61a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a301ecb1abfd0bb20b69af133a7128e51">index_norm_inf</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a301ecb1abfd0bb20b69af133a7128e51"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a107fe04dd7a510612fc50ec0b3f4d7ef">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2, T alpha, T beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#a107fe04dd7a510612fc50ec0b3f4d7ef"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Holds all compute kernels with conventional host-based execution (buffers in CPU RAM). </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a617cbf9eb0f3a88aff971ab66b049508"></a><!-- doxytag: member="viennacl::linalg::host_based::_axpy" ref="a617cbf9eb0f3a88aff971ab66b049508" args="(const T *, T *, vcl_size_t, T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a617cbf9eb0f3a88aff971ab66b049508">_axpy</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="accbc41905fc9bf438683d5babd1de981"></a><!-- doxytag: member="viennacl::linalg::host_based::_copy" ref="accbc41905fc9bf438683d5babd1de981" args="(vcl_size_t, T *, T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#accbc41905fc9bf438683d5babd1de981">_copy</a> </td>
          <td>(</td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7e5bdc48145435919a67623f54e8ede"></a><!-- doxytag: member="viennacl::linalg::host_based::_dot" ref="ad7e5bdc48145435919a67623f54e8ede" args="(vcl_size_t, const T *, const T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad7e5bdc48145435919a67623f54e8ede">_dot</a> </td>
          <td>(</td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afa2d4b01b4c95465d86d804d97a22604"></a><!-- doxytag: member="viennacl::linalg::host_based::_dotc" ref="afa2d4b01b4c95465d86d804d97a22604" args="(vcl_size_t, const T *, const T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#afa2d4b01b4c95465d86d804d97a22604">_dotc</a> </td>
          <td>(</td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb1ad7f87afd4615a73f2e4e694c012d"></a><!-- doxytag: member="viennacl::linalg::host_based::_nrm2" ref="acb1ad7f87afd4615a73f2e4e694c012d" args="(const T *, vcl_size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#acb1ad7f87afd4615a73f2e4e694c012d">_nrm2</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9aefb96d56fb6e043d0c1e616029d43b"></a><!-- doxytag: member="viennacl::linalg::host_based::_swap" ref="a9aefb96d56fb6e043d0c1e616029d43b" args="(vcl_size_t, T *, T *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a9aefb96d56fb6e043d0c1e616029d43b">_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adfca84472e63dbc714202ca8ad334f6b"></a><!-- doxytag: member="viennacl::linalg::host_based::am" ref="adfca84472e63dbc714202ca8ad334f6b" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#adfca84472e63dbc714202ca8ad334f6b">viennacl::linalg::host_based::am</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae021669534868a46fa9c12bc28dfc16b"></a><!-- doxytag: member="viennacl::linalg::host_based::ambm" ref="ae021669534868a46fa9c12bc28dfc16b" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, vcl_size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ae021669534868a46fa9c12bc28dfc16b">viennacl::linalg::host_based::ambm</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a938d7590f7d0cad34403999392e2c978"></a><!-- doxytag: member="viennacl::linalg::host_based::ambm_m" ref="a938d7590f7d0cad34403999392e2c978" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, matrix_base&lt; NumericT, F &gt; const &amp;mat2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, matrix_base&lt; NumericT, F &gt; const &amp;mat3, ScalarType2 const &amp;beta, vcl_size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a938d7590f7d0cad34403999392e2c978">viennacl::linalg::host_based::ambm_m</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a134c3036bc78aa3b2e391a3862a5edcf"></a><!-- doxytag: member="viennacl::linalg::host_based::as" ref="a134c3036bc78aa3b2e391a3862a5edcf" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::value &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a134c3036bc78aa3b2e391a3862a5edcf">viennacl::linalg::host_based::as</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a968a4edfabb0ff2e1d0bb501841b90b9"></a><!-- doxytag: member="viennacl::linalg::host_based::asbs" ref="a968a4edfabb0ff2e1d0bb501841b90b9" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, vcl_size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::value &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a968a4edfabb0ff2e1d0bb501841b90b9">viennacl::linalg::host_based::asbs</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14e422765301f190830128e5422386c9"></a><!-- doxytag: member="viennacl::linalg::host_based::asbs_s" ref="a14e422765301f190830128e5422386c9" args="(S1 &amp;s1, S2 const &amp;s2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, S3 const &amp;s3, ScalarType2 const &amp;beta, vcl_size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S3&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;ScalarType2&gt;::value &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a14e422765301f190830128e5422386c9">viennacl::linalg::host_based::asbs_s</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 const &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 const &amp;&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af05e37c76f86d33e9e7c584f5495e0bf"></a><!-- doxytag: member="viennacl::linalg::host_based::av" ref="af05e37c76f86d33e9e7c584f5495e0bf" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af05e37c76f86d33e9e7c584f5495e0bf">viennacl::linalg::host_based::av</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0652f61041eafab3078a777ed9c2f435"></a><!-- doxytag: member="viennacl::linalg::host_based::avbv" ref="a0652f61041eafab3078a777ed9c2f435" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, vcl_size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a0652f61041eafab3078a777ed9c2f435">viennacl::linalg::host_based::avbv</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa62c4ab048cddc8e6a9b4a1a37f6060c"></a><!-- doxytag: member="viennacl::linalg::host_based::avbv_v" ref="aa62c4ab048cddc8e6a9b4a1a37f6060c" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, ScalarType1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, vector_base&lt; T &gt; const &amp;vec3, ScalarType2 const &amp;beta, vcl_size_t, bool reciprocal_beta, bool flip_sign_beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa62c4ab048cddc8e6a9b4a1a37f6060c">viennacl::linalg::host_based::avbv_v</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType2 const &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a54ee137c28f964daf2115d9daa0b5f40"></a><!-- doxytag: member="viennacl::linalg::host_based::element_op" ref="a54ee137c28f964daf2115d9daa0b5f40" args="(vector_base&lt; T &gt; &amp;vec1, vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, op_element_binary&lt; OP &gt; &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29b57f5c2f778ce4f57def8f1ca5d174">viennacl::linalg::host_based::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, op_element_binary&lt; OP &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The result vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding v2, v3 and the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6600d169517e2dd66c7f182334afbdb"></a><!-- doxytag: member="viennacl::linalg::host_based::element_op" ref="ac6600d169517e2dd66c7f182334afbdb" args="(vector_base&lt; T &gt; &amp;vec1, vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, op_element_unary&lt; OP &gt; &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29b57f5c2f778ce4f57def8f1ca5d174">viennacl::linalg::host_based::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; const vector_base&lt; T &gt;, const vector_base&lt; T &gt;, op_element_unary&lt; OP &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the element-wise operation v1 = v2 .* v3 and v1 = v2 ./ v3 (using MATLAB syntax) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The result vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding v2, v3 and the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29b57f5c2f778ce4f57def8f1ca5d174"></a><!-- doxytag: member="viennacl::linalg::host_based::element_op" ref="a29b57f5c2f778ce4f57def8f1ca5d174" args="(matrix_base&lt; NumericT, F &gt; &amp;A, matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_element_binary&lt; OP &gt; &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29b57f5c2f778ce4f57def8f1ca5d174">viennacl::linalg::host_based::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_element_binary&lt; OP &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the element-wise operations A = B .* C and A = B ./ C (using MATLAB syntax) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The result matrix (or -range, or -slice) </td></tr>
    <tr><td class="paramname">proxy</td><td>The proxy object holding B, C, and the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40b6232776be580875ef662a68c7df87"></a><!-- doxytag: member="viennacl::linalg::host_based::element_op" ref="a40b6232776be580875ef662a68c7df87" args="(matrix_base&lt; NumericT, F &gt; &amp;A, matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_element_unary&lt; OP &gt; &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29b57f5c2f778ce4f57def8f1ca5d174">viennacl::linalg::host_based::element_op</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_element_unary&lt; OP &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a301ecb1abfd0bb20b69af133a7128e51"></a><!-- doxytag: member="viennacl::linalg::host_based::index_norm_inf" ref="a301ecb1abfd0bb20b69af133a7128e51" args="(vector_base&lt; T &gt; const &amp;vec1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a301ecb1abfd0bb20b69af133a7128e51">viennacl::linalg::host_based::index_norm_inf</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result. Note that the result must be a CPU scalar (unsigned int), since gpu scalars are floating point types. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cdd8dff31ffac7296a40450b49dbf80"></a><!-- doxytag: member="viennacl::linalg::host_based::inner_prod_impl" ref="a3cdd8dff31ffac7296a40450b49dbf80" args="(vector_base&lt; T &gt; const &amp;vec1, vector_base&lt; T &gt; const &amp;vec2, S3 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3cdd8dff31ffac7296a40450b49dbf80">viennacl::linalg::host_based::inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S3 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74585b0f7493cc10cbf10a20c9c37050"></a><!-- doxytag: member="viennacl::linalg::host_based::inner_prod_impl" ref="a74585b0f7493cc10cbf10a20c9c37050" args="(vector_base&lt; T &gt; const &amp;x, vector_tuple&lt; T &gt; const &amp;vec_tuple, vector_base&lt; T &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3cdd8dff31ffac7296a40450b49dbf80">viennacl::linalg::host_based::inner_prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_tuple&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa3af08473cb3a7f5116d54302c02d86"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_qr_col_major" ref="aaa3af08473cb3a7f5116d54302c02d86" args="(ScalarType **A, vcl_size_t m, vcl_size_t n, vcl_size_t block_size=8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ScalarType&gt; <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aaa3af08473cb3a7f5116d54302c02d86">viennacl::linalg::host_based::inplace_qr_col_major</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace qr factorization of an m x n dense column-major matrix, returning the householder normalization coefficients. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense column-major matrix to be factorized </td></tr>
    <tr><td class="paramname">m</td><td>The height of the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The width of the matrix </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1ca91eea2771be83df0a807951388d3"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_qr_row_major" ref="ab1ca91eea2771be83df0a807951388d3" args="(ScalarType **A, vcl_size_t m, vcl_size_t n, vcl_size_t block_size=8, vcl_size_t num_threads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ScalarType&gt; <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ab1ca91eea2771be83df0a807951388d3">viennacl::linalg::host_based::inplace_qr_row_major</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace qr factorization of an m x n dense row-major matrix, returning the householder normalization coefficients. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense row-major matrix to be factorized </td></tr>
    <tr><td class="paramname">m</td><td>The height of the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The width of the matrix </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fff650777bb47541ee70c67a25faa00"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a8fff650777bb47541ee70c67a25faa00" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for triangular systems with multiple right hand sides, i.e. A \ B (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">B</td><td>The matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08c38699206e277bf5d709d0a7d652cd"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a08c38699206e277bf5d709d0a7d652cd" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for triangular systems with multiple transposed right hand sides, i.e. A \ B^T (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The proxy for the transposed matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebc69ca6f6f56e707dfd734fa012d4cb"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="aebc69ca6f6f56e707dfd734fa012d4cb" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_base&lt; NumericT, F2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for transposed triangular systems with multiple right hand sides, i.e. A^T \ B (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">B</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8983c22febdaed6bea82107c9ee703c1"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a8983c22febdaed6bea82107c9ee703c1" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;proxy_A, matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; proxy_B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt;&#160;</td>
          <td class="paramname"><em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for transposed triangular systems with multiple transposed right hand sides, i.e. A^T \ B^T (MATLAB notation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_A</td><td>The transposed system matrix proxy </td></tr>
    <tr><td class="paramname">proxy_B</td><td>The transposed matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a035b582c7138a65609eda6bff21eae40"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a035b582c7138a65609eda6bff21eae40" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad49aa03302e698f44dbc49e81faf8c38"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="ad49aa03302e698f44dbc49e81faf8c38" args="(const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;proxy, vector_base&lt; NumericT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The system matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2f9a94f9f5c0e068d8126f850c7c9d9"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="ae2f9a94f9f5c0e068d8126f850c7c9d9" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bda6585eb1f3a9c153537c737dd7dcd"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a3bda6585eb1f3a9c153537c737dd7dcd" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;L, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2b5d908f83ee5f0533895aed846eadf"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="ad2b5d908f83ee5f0533895aed846eadf" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e3eabcf4e6c9aa7c2c7a942df68d409"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a1e3eabcf4e6c9aa7c2c7a942df68d409" args="(compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;U, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector holding the right hand side. Is overwritten by the solution. </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7395737ad4441e78b4391c00af3c663"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="aa7395737ad4441e78b4391c00af3c663" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92e9d5f3a337dcce673a27d12b5b8c7c"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a92e9d5f3a337dcce673a27d12b5b8c7c" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::lower_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">viennacl::linalg::lower_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38c2e71cc1920ec5803aee5d21f98995"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a38c2e71cc1920ec5803aee5d21f98995" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::unit_upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">viennacl::linalg::unit_upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e71fb4577e6a51a6531e35bd50ea8cf"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_solve" ref="a9e71fb4577e6a51a6531e35bd50ea8cf" args="(matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;proxy, vector_base&lt; ScalarType &gt; &amp;vec, viennacl::linalg::upper_tag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8fff650777bb47541ee70c67a25faa00">viennacl::linalg::host_based::inplace_solve</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, const compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt;, op_trans &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy object for a transposed CSR-matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The right hand side vector </td></tr>
    <tr><td class="paramname">tag</td><td>The solver tag identifying the respective triangular solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a186586aced1407e7106fd3f7f432f582"></a><!-- doxytag: member="viennacl::linalg::host_based::inplace_tred2" ref="a186586aced1407e7106fd3f7f432f582" args="(ScalarType **A, vcl_size_t n, vcl_size_t block_size=1, vcl_size_t num_threads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a186586aced1407e7106fd3f7f432f582">viennacl::linalg::host_based::inplace_tred2</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace reduction of a dense n x n row-major or column-major hermitian (or real symmetric) matrix to tridiagonal form using householder similarity transforms (preserving eigenvalues) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense hermitian matrix to be tridiagonalized </td></tr>
    <tr><td class="paramname">n</td><td>The height and width of the hermitian matrix </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
    <tr><td class="paramname">num_threads</td><td>The number of threads to be used with OpenMP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29a882acaad6a548f7fadf54598bdc42"></a><!-- doxytag: member="viennacl::linalg::host_based::lu_factorize_row_major" ref="a29a882acaad6a548f7fadf54598bdc42" args="(ScalarType **A, vcl_size_t m, vcl_size_t n, vcl_size_t *piv=NULL, vcl_size_t block_size=8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a29a882acaad6a548f7fadf54598bdc42">viennacl::linalg::host_based::lu_factorize_row_major</a> </td>
          <td>(</td>
          <td class="paramtype">ScalarType **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t *&#160;</td>
          <td class="paramname"><em>piv</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace lu factorization of an m x n dense row-major matrix with optional partial pivoting, returning true for an even number of pivots, false for an odd number of pivots. Factorization is successful if there are no nonzero values on the diagonal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A dense row-major matrix to be factorized </td></tr>
    <tr><td class="paramname">m</td><td>The height of the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The width of the matrix </td></tr>
    <tr><td class="paramname">piv</td><td>The optional pivot vector to store the pivot indices. If piv is NULL, no partial pivoting will be performed. </td></tr>
    <tr><td class="paramname">block_size</td><td>The block size to be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84536cf0af962f3688dc04d4411aba66"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_assign" ref="a84536cf0af962f3688dc04d4411aba66" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s, bool clear=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a84536cf0af962f3688dc04d4411aba66">viennacl::linalg::host_based::matrix_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b496b5209ea4553334afe9153b03814"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_column" ref="a0b496b5209ea4553334afe9153b03814" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, unsigned int j, vector_base&lt; NumericT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a0b496b5209ea4553334afe9153b03814">viennacl::linalg::host_based::matrix_column</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5493a4e97469b4524250d2ceccaaa2a"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_diag_from_vector" ref="ac5493a4e97469b4524250d2ceccaaa2a" args="(const vector_base&lt; NumericT &gt; &amp;vec, int k, matrix_base&lt; NumericT, F &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac5493a4e97469b4524250d2ceccaaa2a">viennacl::linalg::host_based::matrix_diag_from_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a811413a4b8f1a71ba45ec4fef6326134"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_diag_to_vector" ref="a811413a4b8f1a71ba45ec4fef6326134" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, int k, vector_base&lt; NumericT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a811413a4b8f1a71ba45ec4fef6326134">viennacl::linalg::host_based::matrix_diag_to_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad95a3b2ea4b00bae1007e468f31e5236"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_diagonal_assign" ref="ad95a3b2ea4b00bae1007e468f31e5236" args="(matrix_base&lt; NumericT, F &gt; &amp;mat, NumericT s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ad95a3b2ea4b00bae1007e468f31e5236">viennacl::linalg::host_based::matrix_diagonal_assign</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericT&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e4a337ad45526a3ec1c2bc0c8209033"></a><!-- doxytag: member="viennacl::linalg::host_based::matrix_row" ref="a3e4a337ad45526a3ec1c2bc0c8209033" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, unsigned int i, vector_base&lt; NumericT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3e4a337ad45526a3ec1c2bc0c8209033">viennacl::linalg::host_based::matrix_row</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8edf47c18ba79b54e66c0d79f179beaf"></a><!-- doxytag: member="viennacl::linalg::host_based::norm_1_impl" ref="a8edf47c18ba79b54e66c0d79f179beaf" args="(vector_base&lt; T &gt; const &amp;vec1, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a8edf47c18ba79b54e66c0d79f179beaf">viennacl::linalg::host_based::norm_1_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bb4cf7b8852122dc4772065f8539a59"></a><!-- doxytag: member="viennacl::linalg::host_based::norm_2_impl" ref="a3bb4cf7b8852122dc4772065f8539a59" args="(vector_base&lt; T &gt; const &amp;vec1, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3bb4cf7b8852122dc4772065f8539a59">viennacl::linalg::host_based::norm_2_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - implementation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c3b448e695efcfc4ac7d0a2d924d61a"></a><!-- doxytag: member="viennacl::linalg::host_based::norm_inf_impl" ref="a5c3b448e695efcfc4ac7d0a2d924d61a" args="(vector_base&lt; T &gt; const &amp;vec1, S2 &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a5c3b448e695efcfc4ac7d0a2d924d61a">viennacl::linalg::host_based::norm_inf_impl</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a107fe04dd7a510612fc50ec0b3f4d7ef"></a><!-- doxytag: member="viennacl::linalg::host_based::plane_rotation" ref="a107fe04dd7a510612fc50ec0b3f4d7ef" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2, T alpha, T beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a107fe04dd7a510612fc50ec0b3f4d7ef">viennacl::linalg::host_based::plane_rotation</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
    <tr><td class="paramname">alpha</td><td>The first transformation coefficient </td></tr>
    <tr><td class="paramname">beta</td><td>The second transformation coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc0ac63dacb65197ab4db5aeb0e44df7"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="acc0ac63dacb65197ab4db5aeb0e44df7" args="(const viennacl::compressed_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd0e6a78598634dea1a813eafb269a7d"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="acd0e6a78598634dea1a813eafb269a7d" args="(const viennacl::compressed_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const viennacl::matrix_base&lt; NumericT, F1 &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out sparse_matrix-matrix multiplication first matrix being compressed. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, d_mat);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The sparse matrix </td></tr>
    <tr><td class="paramname">d_mat</td><td>The dense matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a822501f53c117d11f3bad8b932d22985"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a822501f53c117d11f3bad8b932d22985" args="(const viennacl::compressed_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F1 &gt;, const viennacl::matrix_base&lt; NumericT, F1 &gt;, viennacl::op_trans &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-trans(matrix) multiplication first matrix being compressed and the second transposed. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, trans(d_mat));</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The sparse matrix </td></tr>
    <tr><td class="paramname">d_mat</td><td>The transposed dense matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9f708f5debeea50a45efb78b3e1f66b"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="af9f708f5debeea50a45efb78b3e1f66b" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e3e94d4038bb010bb86023b613fa6ff"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a2e3e94d4038bb010bb86023b613fa6ff" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;mat_trans, const vector_base&lt; NumericT &gt; &amp;vec, vector_base&lt; NumericT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_trans</td><td>The transposed matrix proxy </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11b48f1906ecb12900769f9aa58ca32d"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a11b48f1906ecb12900769f9aa58ca32d" args="(const viennacl::compressed_compressed_matrix&lt; ScalarType &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">viennacl::compressed_compressed_matrix</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9a523b23a6acfedb255d6bbabbe240f"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="ac9a523b23a6acfedb255d6bbabbe240f" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, B); </p>

</div>
</div>
<a class="anchor" id="afe7804f787bac3c655bbde0a4d7f2f95"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="afe7804f787bac3c655bbde0a4d7f2f95" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const matrix_base&lt; NumericT, F2 &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), B); </p>

</div>
</div>
<a class="anchor" id="ac823213902af7383f4fabd2f6a29ac91"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="ac823213902af7383f4fabd2f6a29ac91" args="(const viennacl::coordinate_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6614a3a11d49234a8783bd3b64ee1b3"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aa6614a3a11d49234a8783bd3b64ee1b3" args="(const viennacl::coordinate_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const viennacl::matrix_base&lt; NumericT, F1 &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out Compressed Matrix(COO)-Dense Matrix multiplication. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, d_mat);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The Sparse Matrix (Coordinate format) </td></tr>
    <tr><td class="paramname">d_mat</td><td>The Dense Matrix </td></tr>
    <tr><td class="paramname">result</td><td>The Result Matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa730ef19275e56a333ea4029aa4b44c2"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aa730ef19275e56a333ea4029aa4b44c2" args="(const matrix_base&lt; NumericT, F1 &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, trans(B)); </p>

</div>
</div>
<a class="anchor" id="aca398a45efe3258f77a7d5cd552018f5"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aca398a45efe3258f77a7d5cd552018f5" args="(const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;B, matrix_base&lt; NumericT, F3 &gt; &amp;C, ScalarType alpha, ScalarType beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F1 &gt;, const matrix_base&lt; NumericT, F1 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix_base&lt; NumericT, F2 &gt;, const matrix_base&lt; NumericT, F2 &gt;, op_trans &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), trans(B)); </p>

</div>
</div>
<a class="anchor" id="a0e785ca8b38f8d7b26193cc6cc36e4a4"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a0e785ca8b38f8d7b26193cc6cc36e4a4" args="(const viennacl::coordinate_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F1 &gt;, const viennacl::matrix_base&lt; NumericT, F1 &gt;, viennacl::op_trans &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out Compressed Matrix(COO)-Dense Transposed Matrix multiplication. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, trans(d_mat));</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The Sparse Matrix (Coordinate format) </td></tr>
    <tr><td class="paramname">d_mat</td><td>The Dense Transposed Matrix </td></tr>
    <tr><td class="paramname">result</td><td>The Result Matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc2e1977cd2b6069ed9ba376bb792a98"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="afc2e1977cd2b6069ed9ba376bb792a98" args="(const viennacl::ell_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros.">ell_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affdbf222a5998451c2e379f997134800"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="affdbf222a5998451c2e379f997134800" args="(const viennacl::ell_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const viennacl::matrix_base&lt; NumericT, F1 &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out ell_matrix-d_matrix multiplication. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, d_mat);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The sparse(ELL) matrix </td></tr>
    <tr><td class="paramname">d_mat</td><td>The dense matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result dense matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab28797b2134916975c5aa68efc297ed0"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="ab28797b2134916975c5aa68efc297ed0" args="(const viennacl::ell_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;sp_mat, const viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F1 &gt;, const viennacl::matrix_base&lt; NumericT, F1 &gt;, viennacl::op_trans &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1ell__matrix.html">viennacl::ell_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-trans(matrix) multiplication first matrix being sparse ell and the second dense transposed. </p>
<p>Implementation of the convenience expression result = prod(sp_mat, trans(d_mat));</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sp_mat</td><td>The sparse matrix </td></tr>
    <tr><td class="paramname">d_mat</td><td>The transposed dense matrix </td></tr>
    <tr><td class="paramname">result</td><td>The result matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea41f806a665d5b04951eb88110c729a"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="aea41f806a665d5b04951eb88110c729a" args="(const viennacl::hyb_matrix&lt; ScalarType, ALIGNMENT &gt; &amp;mat, const viennacl::vector_base&lt; ScalarType &gt; &amp;vec, viennacl::vector_base&lt; ScalarType &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; ScalarType, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix </td></tr>
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
    <tr><td class="paramname">result</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8edbe2f1e7bf8645257b7962ee604258"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a8edbe2f1e7bf8645257b7962ee604258" args="(const viennacl::hyb_matrix&lt; NumericT, ALIGNMENT &gt; &amp;mat, const viennacl::matrix_base&lt; NumericT, F1 &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; NumericT, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out sparse-matrix-dense-matrix multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a>. </p>
<p>Implementation of the convenience expression C = prod(A, B);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The sparse matrix A </td></tr>
    <tr><td class="paramname">d_mat</td><td>The dense matrix B </td></tr>
    <tr><td class="paramname">result</td><td>The dense result matrix C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11745d942eea14331712994d71b386f0"></a><!-- doxytag: member="viennacl::linalg::host_based::prod_impl" ref="a11745d942eea14331712994d71b386f0" args="(const viennacl::hyb_matrix&lt; NumericT, ALIGNMENT &gt; &amp;mat, const viennacl::matrix_expression&lt; const viennacl::matrix_base&lt; NumericT, F1 &gt;, const viennacl::matrix_base&lt; NumericT, F1 &gt;, viennacl::op_trans &gt; &amp;d_mat, viennacl::matrix_base&lt; NumericT, F2 &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#af9f708f5debeea50a45efb78b3e1f66b">viennacl::linalg::host_based::prod_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1hyb__matrix.html">viennacl::hyb_matrix</a>&lt; NumericT, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F1 &gt;, <a class="el" href="structviennacl_1_1op__trans.html">viennacl::op_trans</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__base.html">viennacl::matrix_base</a>&lt; NumericT, F2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out sparse-matrix-transposed-dense-matrix multiplication with a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a>. </p>
<p>Implementation of the convenience expression C = prod(A, trans(B));</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The sparse matrix A </td></tr>
    <tr><td class="paramname">d_mat</td><td>The dense matrix B </td></tr>
    <tr><td class="paramname">result</td><td>The dense result matrix C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa384630ee456868944cfa8323606e2b0"></a><!-- doxytag: member="viennacl::linalg::host_based::scaled_rank_1_update" ref="aa384630ee456868944cfa8323606e2b0" args="(matrix_base&lt; NumericT, F &gt; &amp;mat1, S1 const &amp;alpha, vcl_size_t, bool reciprocal_alpha, bool flip_sign_alpha, const vector_base&lt; NumericT &gt; &amp;vec1, const vector_base&lt; NumericT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#aa384630ee456868944cfa8323606e2b0">viennacl::linalg::host_based::scaled_rank_1_update</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcl_size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reciprocal_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flip_sign_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>The matrix to be updated </td></tr>
    <tr><td class="paramname">alpha</td><td>The scaling factor (either a viennacl::scalar&lt;&gt;, float, or double) </td></tr>
    <tr><td class="paramname">reciprocal_alpha</td><td>Use 1/alpha instead of alpha </td></tr>
    <tr><td class="paramname">flip_sign_alpha</td><td>Use -alpha instead of alpha </td></tr>
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a008702a083918762ac8a51ca2f3c332b"></a><!-- doxytag: member="viennacl::linalg::host_based::swap" ref="a008702a083918762ac8a51ca2f3c332b" args="(S1 &amp;s1, S2 &amp;s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value &amp;&amp; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S2&gt;::value &gt;::type <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a008702a083918762ac8a51ca2f3c332b">viennacl::linalg::host_based::swap</a> </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two scalars, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>The first scalar </td></tr>
    <tr><td class="paramname">s2</td><td>The second scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dd84a153abaccd31996820059dce5a5"></a><!-- doxytag: member="viennacl::linalg::host_based::vector_assign" ref="a3dd84a153abaccd31996820059dce5a5" args="(vector_base&lt; T &gt; &amp;vec1, const T &amp;alpha, bool up_to_internal_size=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#a3dd84a153abaccd31996820059dce5a5">viennacl::linalg::host_based::vector_assign</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>up_to_internal_size</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a constant value to a vector (-range/-slice) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The vector to which the value should be assigned </td></tr>
    <tr><td class="paramname">alpha</td><td>The value to be assigned </td></tr>
    <tr><td class="paramname">up_to_internal_size</td><td>Specifies whether alpha should also be written to padded memory (mostly used for clearing the whole buffer). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac370a4948707c297fe7ffbc4cd532314"></a><!-- doxytag: member="viennacl::linalg::host_based::vector_swap" ref="ac370a4948707c297fe7ffbc4cd532314" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl_1_1linalg_1_1host__based.html#ac370a4948707c297fe7ffbc4cd532314">viennacl::linalg::host_based::vector_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector (or -range, or -slice) </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector (or -range, or -slice) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:38 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
