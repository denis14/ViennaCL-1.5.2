<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/linalg/opencl/matrix_operations.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/linalg/opencl/matrix_operations.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="opencl_2matrix__operations_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_LINALG_OPENCL_MATRIX_OPERATIONS_HPP_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_LINALG_OPENCL_MATRIX_OPERATIONS_HPP_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2014, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL.">viennacl/forwards.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="device_8hpp.html" title="Represents an OpenCL device within ViennaCL.">viennacl/ocl/device.hpp</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="ocl_2handle_8hpp.html" title="Implementation of a smart-pointer-like class for handling OpenCL handles.">viennacl/ocl/handle.hpp</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="kernel_8hpp.html" title="Representation of an OpenCL kernel in ViennaCL.">viennacl/ocl/kernel.hpp</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html" title="Implementation of the ViennaCL scalar class.">viennacl/scalar.hpp</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="vector_8hpp.html" title="The vector type with operator-overloads and proxy classes is defined here. Linear algebra operations ...">viennacl/vector.hpp</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="vector__proxy_8hpp.html" title="Proxy classes for vectors.">viennacl/vector_proxy.hpp</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html" title="Various little tools used here and there in ViennaCL.">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="enable__if_8hpp.html" title="Simple enable-if variant that uses the SFINAE pattern.">viennacl/meta/enable_if.hpp</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="predicate_8hpp.html" title="All the predicates used within ViennaCL. Checks for expressions to be vectors, etc.">viennacl/meta/predicate.hpp</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="result__of_8hpp.html" title="A collection of compile time type deductions.">viennacl/meta/result_of.hpp</a>&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="scheduler_2forwards_8h.html" title="Provides the datastructures for dealing with a single statement such as &#39;x = y + z;&#39;.">viennacl/scheduler/forwards.h</a>&quot;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="generate_8hpp.html" title="the user interface for the code generator">viennacl/generator/generate.hpp</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="size_8hpp.html" title="Generic size and resize functionality for different vector and matrix types.">viennacl/traits/size.hpp</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="start_8hpp.html" title="Extracts the underlying OpenCL start index handle from a vector, a matrix, an expression etc...">viennacl/traits/start.hpp</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="traits_2handle_8hpp.html" title="Extracts the underlying OpenCL handle from a vector, a matrix, an expression etc.">viennacl/traits/handle.hpp</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="stride_8hpp.html" title="Determines row and column increments for matrices and matrix proxies.">viennacl/traits/stride.hpp</a>&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="opencl_2common_8hpp.html" title="Common implementations shared by OpenCL-based operations.">viennacl/linalg/opencl/common.hpp</a>&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="linalg_2opencl_2kernels_2matrix_8hpp.html" title="Runtime generation of OpenCL kernels for matrix operations.">viennacl/linalg/opencl/kernels/matrix.hpp</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="matrix__element_8hpp.html" title="OpenCL kernel file for element-wise matrix operations.">viennacl/linalg/opencl/kernels/matrix_element.hpp</a>&quot;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="matrix__prod_8hpp.html" title="Runtime generation of OpenCL kernels for dense matrix-matrix products.">viennacl/linalg/opencl/kernels/matrix_prod.hpp</a>&quot;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">namespace </span>viennacl
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <span class="keyword">namespace </span>linalg
<a name="l00057"></a>00057   {
<a name="l00058"></a>00058     <span class="keyword">namespace </span>opencl
<a name="l00059"></a>00059     {
<a name="l00060"></a>00060       <span class="comment">//</span>
<a name="l00061"></a>00061       <span class="comment">// Introductory note: By convention, all dimensions are already checked in the dispatcher frontend. No need to double-check again in here!</span>
<a name="l00062"></a>00062       <span class="comment">//</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l00065"></a>00065                 <span class="keyword">typename</span> ScalarType1&gt;
<a name="l00066"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a7ea7c2e60fca7e8ded820125c886fb2f">00066</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a7ea7c2e60fca7e8ded820125c886fb2f">am</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat1,
<a name="l00067"></a>00067               <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; mat2, ScalarType1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha)
<a name="l00068"></a>00068       {
<a name="l00069"></a>00069         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat1).context());
<a name="l00072"></a>00072         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00073"></a>00073         KernelClass::init(ctx);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(),
<a name="l00078"></a>00078                                                    (<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> ? <span class="stringliteral">&quot;am_cpu&quot;</span> : <span class="stringliteral">&quot;am_gpu&quot;</span>));
<a name="l00079"></a>00079         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat1),
<a name="l00080"></a>00080                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat1)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat1)),
<a name="l00081"></a>00081                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat1)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat1)),
<a name="l00082"></a>00082                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat1)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat1)),
<a name="l00083"></a>00083                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat1)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat1)),
<a name="l00084"></a>00084 
<a name="l00085"></a>00085                                 viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(alpha)),
<a name="l00086"></a>00086                                 options_alpha,
<a name="l00087"></a>00087                                 viennacl::traits::opencl_handle(mat2),
<a name="l00088"></a>00088                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat2)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat2)),
<a name="l00089"></a>00089                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat2)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat2)),
<a name="l00090"></a>00090                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat2)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat2))
<a name="l00091"></a>00091                                 )
<a name="l00092"></a>00092                               );
<a name="l00093"></a>00093       }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l00097"></a>00097                 <span class="keyword">typename</span> ScalarType1, <span class="keyword">typename</span> ScalarType2&gt;
<a name="l00098"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a97ed4554ada37642e71e943c06467bc5">00098</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a97ed4554ada37642e71e943c06467bc5">ambm</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat1,
<a name="l00099"></a>00099                 <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; mat2, ScalarType1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha,
<a name="l00100"></a>00100                 <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; mat3, ScalarType2 <span class="keyword">const</span> &amp; beta,  <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_beta,  <span class="keywordtype">bool</span> reciprocal_beta,  <span class="keywordtype">bool</span> flip_sign_beta)
<a name="l00101"></a>00101       {
<a name="l00102"></a>00102         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat1).context());
<a name="l00105"></a>00105         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00106"></a>00106         KernelClass::init(ctx);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         std::string kernel_name;
<a name="l00109"></a>00109         <span class="keywordflow">if</span>      ( <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp;  <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00110"></a>00110           kernel_name = <span class="stringliteral">&quot;ambm_cpu_cpu&quot;</span>;
<a name="l00111"></a>00111         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; !<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00112"></a>00112           kernel_name = <span class="stringliteral">&quot;ambm_cpu_gpu&quot;</span>;
<a name="l00113"></a>00113         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp;  <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00114"></a>00114           kernel_name = <span class="stringliteral">&quot;ambm_gpu_cpu&quot;</span>;
<a name="l00115"></a>00115         <span class="keywordflow">else</span>
<a name="l00116"></a>00116           kernel_name = <span class="stringliteral">&quot;ambm_gpu_gpu&quot;</span>;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00119"></a>00119         cl_uint options_beta  = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_beta,  reciprocal_beta,  flip_sign_beta);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), kernel_name);
<a name="l00122"></a>00122         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat1),
<a name="l00123"></a>00123                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat1)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat1)),
<a name="l00124"></a>00124                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat1)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat1)),
<a name="l00125"></a>00125                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat1)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat1)),
<a name="l00126"></a>00126                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat1)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat1)),
<a name="l00127"></a>00127 
<a name="l00128"></a>00128                                 viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(alpha)),
<a name="l00129"></a>00129                                 options_alpha,
<a name="l00130"></a>00130                                 viennacl::traits::opencl_handle(mat2),
<a name="l00131"></a>00131                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat2)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat2)),
<a name="l00132"></a>00132                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat2)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat2)),
<a name="l00133"></a>00133                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat2)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat2)),
<a name="l00134"></a>00134 
<a name="l00135"></a>00135                                 viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(beta)),
<a name="l00136"></a>00136                                 options_beta,
<a name="l00137"></a>00137                                 viennacl::traits::opencl_handle(mat3),
<a name="l00138"></a>00138                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat3)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat3)),
<a name="l00139"></a>00139                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat3)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat3)),
<a name="l00140"></a>00140                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat3)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat3))
<a name="l00141"></a>00141                                 )
<a name="l00142"></a>00142                               );
<a name="l00143"></a>00143       }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00146"></a>00146       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F,
<a name="l00147"></a>00147                 <span class="keyword">typename</span> ScalarType1, <span class="keyword">typename</span> ScalarType2&gt;
<a name="l00148"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a508aa8c68d3dd28f0a59f459f2f10436">00148</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a508aa8c68d3dd28f0a59f459f2f10436">ambm_m</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat1,
<a name="l00149"></a>00149                   <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; mat2, ScalarType1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha,
<a name="l00150"></a>00150                   <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> <span class="keyword">const</span> &amp; mat3, ScalarType2 <span class="keyword">const</span> &amp; beta,  <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_beta,  <span class="keywordtype">bool</span> reciprocal_beta,  <span class="keywordtype">bool</span> flip_sign_beta)
<a name="l00151"></a>00151       {
<a name="l00152"></a>00152         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat1).context());
<a name="l00155"></a>00155         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00156"></a>00156         KernelClass::init(ctx);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         std::string kernel_name;
<a name="l00159"></a>00159         <span class="keywordflow">if</span>      ( <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp;  <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00160"></a>00160           kernel_name = <span class="stringliteral">&quot;ambm_m_cpu_cpu&quot;</span>;
<a name="l00161"></a>00161         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp; !<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00162"></a>00162           kernel_name = <span class="stringliteral">&quot;ambm_m_cpu_gpu&quot;</span>;
<a name="l00163"></a>00163         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType1&gt;::value</a> &amp;&amp;  <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;ScalarType2&gt;::value</a>)
<a name="l00164"></a>00164           kernel_name = <span class="stringliteral">&quot;ambm_m_gpu_cpu&quot;</span>;
<a name="l00165"></a>00165         <span class="keywordflow">else</span>
<a name="l00166"></a>00166           kernel_name = <span class="stringliteral">&quot;ambm_m_gpu_gpu&quot;</span>;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00169"></a>00169         cl_uint options_beta  = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_beta,  reciprocal_beta,  flip_sign_beta);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), kernel_name);
<a name="l00172"></a>00172         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat1),
<a name="l00173"></a>00173                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat1)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat1)),
<a name="l00174"></a>00174                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat1)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat1)),
<a name="l00175"></a>00175                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat1)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat1)),
<a name="l00176"></a>00176                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat1)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat1)),
<a name="l00177"></a>00177 
<a name="l00178"></a>00178                                 viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(alpha)),
<a name="l00179"></a>00179                                 options_alpha,
<a name="l00180"></a>00180                                 viennacl::traits::opencl_handle(mat2),
<a name="l00181"></a>00181                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat2)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat2)),
<a name="l00182"></a>00182                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat2)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat2)),
<a name="l00183"></a>00183                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat2)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat2)),
<a name="l00184"></a>00184 
<a name="l00185"></a>00185                                 viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(beta)),
<a name="l00186"></a>00186                                 options_beta,
<a name="l00187"></a>00187                                 viennacl::traits::opencl_handle(mat3),
<a name="l00188"></a>00188                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat3)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat3)),
<a name="l00189"></a>00189                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat3)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat3)),
<a name="l00190"></a>00190                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat3)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat3))
<a name="l00191"></a>00191                                 )
<a name="l00192"></a>00192                               );
<a name="l00193"></a>00193       }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 
<a name="l00197"></a>00197       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00198"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3b64c40750f7c38ce433cc98780f8add">00198</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3b64c40750f7c38ce433cc98780f8add">matrix_assign</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat, NumericT s, <span class="keywordtype">bool</span> <a class="code" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear</a> = <span class="keyword">false</span>)
<a name="l00199"></a>00199       {
<a name="l00200"></a>00200         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00203"></a>00203         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00204"></a>00204         KernelClass::init(ctx);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         value_type alpha = <span class="keyword">static_cast&lt;</span>value_type<span class="keyword">&gt;</span>(s);
<a name="l00207"></a>00207 
<a name="l00208"></a>00208         cl_uint s1 = <a class="code" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear</a> ? cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat)) : cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat));
<a name="l00209"></a>00209         cl_uint s2 = <a class="code" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear</a> ? cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat)) : cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat));
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;assign_cpu&quot;</span>);
<a name="l00212"></a>00212         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat),
<a name="l00213"></a>00213                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat)),
<a name="l00214"></a>00214                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat)),
<a name="l00215"></a>00215                                  s1,                                               s2,
<a name="l00216"></a>00216                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat)),
<a name="l00217"></a>00217                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(alpha))
<a name="l00218"></a>00218                                 )
<a name="l00219"></a>00219                               );
<a name="l00220"></a>00220       }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00223"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#abad0214892ec7c665b37bdfaf3829bc0">00223</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#abad0214892ec7c665b37bdfaf3829bc0">matrix_diagonal_assign</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat, NumericT s)
<a name="l00224"></a>00224       {
<a name="l00225"></a>00225         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00228"></a>00228         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00229"></a>00229         KernelClass::init(ctx);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231         value_type alpha = <span class="keyword">static_cast&lt;</span>value_type<span class="keyword">&gt;</span>(s);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;diagonal_assign_cpu&quot;</span>);
<a name="l00234"></a>00234         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat),
<a name="l00235"></a>00235                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat)),
<a name="l00236"></a>00236                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat)),
<a name="l00237"></a>00237                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat)),
<a name="l00238"></a>00238                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat)),
<a name="l00239"></a>00239                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;value_type&gt;(alpha))
<a name="l00240"></a>00240                                 )
<a name="l00241"></a>00241                               );
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00245"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adc94f041bf1634da4d27af94affedd1a">00245</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adc94f041bf1634da4d27af94affedd1a">matrix_diag_from_vector</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec, <span class="keywordtype">int</span> k, <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat)
<a name="l00246"></a>00246       {
<a name="l00247"></a>00247         <span class="comment">// Step 1: set everything to zero</span>
<a name="l00248"></a>00248         <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a3b64c40750f7c38ce433cc98780f8add">matrix_assign</a>(mat, NumericT(0));
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         <span class="comment">// Step 2: set the diagonal:</span>
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         <span class="comment">// reuse vector ambm kernel for assigning the elements:</span>
<a name="l00253"></a>00253         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00254"></a>00254         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;NumericT&gt;</a>  KernelClass;
<a name="l00255"></a>00255         KernelClass::init(ctx);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         cl_uint options_alpha = 0;
<a name="l00258"></a>00258         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_mat;
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__row__major.html" title="Helper class for checking whether a matrix has a row-major layout.">viennacl::is_row_major&lt;F&gt;::value</a>)
<a name="l00260"></a>00260         {
<a name="l00261"></a>00261           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_row_index = 0;
<a name="l00262"></a>00262           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_col_index = 0;
<a name="l00263"></a>00263           <span class="keywordflow">if</span> (k &lt; 0)
<a name="l00264"></a>00264             first_row_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(-k);
<a name="l00265"></a>00265           <span class="keywordflow">else</span>
<a name="l00266"></a>00266             first_col_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(k);
<a name="l00267"></a>00267           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint( (<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + first_row_index * <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat)
<a name="l00268"></a>00268                                     + <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) + first_col_index * <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00269"></a>00269           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat) + <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00270"></a>00270           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00271"></a>00271           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00272"></a>00272         }
<a name="l00273"></a>00273         <span class="keywordflow">else</span>
<a name="l00274"></a>00274         {
<a name="l00275"></a>00275           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_row_index = 0;
<a name="l00276"></a>00276           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_col_index = 0;
<a name="l00277"></a>00277           <span class="keywordflow">if</span> (k &lt; 0)
<a name="l00278"></a>00278             first_row_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(-k);
<a name="l00279"></a>00279           <span class="keywordflow">else</span>
<a name="l00280"></a>00280             first_col_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(k);
<a name="l00281"></a>00281           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(   <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + first_row_index * <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)
<a name="l00282"></a>00282                                     + (<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) + first_col_index * <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat)) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat));
<a name="l00283"></a>00283           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat) + <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat));
<a name="l00284"></a>00284           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00285"></a>00285           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec;
<a name="l00289"></a>00289         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec));
<a name="l00290"></a>00290         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec));
<a name="l00291"></a>00291         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00292"></a>00292         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; kern = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;av_cpu&quot;</span>);
<a name="l00295"></a>00295         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(kern(viennacl::traits::opencl_handle(mat),
<a name="l00296"></a>00296                                     size_mat,
<a name="l00297"></a>00297 
<a name="l00298"></a>00298                                     viennacl::traits::opencl_handle(NumericT(1)),
<a name="l00299"></a>00299                                     options_alpha,
<a name="l00300"></a>00300                                     viennacl::traits::opencl_handle(vec),
<a name="l00301"></a>00301                                     size_vec)
<a name="l00302"></a>00302                               );
<a name="l00303"></a>00303       }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00306"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f23d7b8679acf1ee6e850aeda2ad87f">00306</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f23d7b8679acf1ee6e850aeda2ad87f">matrix_diag_to_vector</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat, <span class="keywordtype">int</span> k, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec)
<a name="l00307"></a>00307       {
<a name="l00308"></a>00308         <span class="comment">// reuse vector ambm kernel for assigning the elements:</span>
<a name="l00309"></a>00309         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00310"></a>00310         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;NumericT&gt;</a>  KernelClass;
<a name="l00311"></a>00311         KernelClass::init(ctx);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313         cl_uint options_alpha = 0;
<a name="l00314"></a>00314         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_mat;
<a name="l00315"></a>00315         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__row__major.html" title="Helper class for checking whether a matrix has a row-major layout.">viennacl::is_row_major&lt;F&gt;::value</a>)
<a name="l00316"></a>00316         {
<a name="l00317"></a>00317           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_row_index = 0;
<a name="l00318"></a>00318           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_col_index = 0;
<a name="l00319"></a>00319           <span class="keywordflow">if</span> (k &lt; 0)
<a name="l00320"></a>00320             first_row_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(-k);
<a name="l00321"></a>00321           <span class="keywordflow">else</span>
<a name="l00322"></a>00322             first_col_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(k);
<a name="l00323"></a>00323           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint( (<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + first_row_index * <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat)
<a name="l00324"></a>00324                                     + <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) + first_col_index * <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00325"></a>00325           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat) + <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00326"></a>00326           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00327"></a>00327           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329         <span class="keywordflow">else</span>
<a name="l00330"></a>00330         {
<a name="l00331"></a>00331           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_row_index = 0;
<a name="l00332"></a>00332           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> first_col_index = 0;
<a name="l00333"></a>00333           <span class="keywordflow">if</span> (k &lt; 0)
<a name="l00334"></a>00334             first_row_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(-k);
<a name="l00335"></a>00335           <span class="keywordflow">else</span>
<a name="l00336"></a>00336             first_col_index = <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>(k);
<a name="l00337"></a>00337           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(   <a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + first_row_index * <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)
<a name="l00338"></a>00338                                     + (<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) + first_col_index * <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat)) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat));
<a name="l00339"></a>00339           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat) + <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat));
<a name="l00340"></a>00340           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00341"></a>00341           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec;
<a name="l00345"></a>00345         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec));
<a name="l00346"></a>00346         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec));
<a name="l00347"></a>00347         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00348"></a>00348         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 
<a name="l00351"></a>00351         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; kern = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;av_cpu&quot;</span>);
<a name="l00352"></a>00352         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(kern(viennacl::traits::opencl_handle(vec),
<a name="l00353"></a>00353                                     size_vec,
<a name="l00354"></a>00354 
<a name="l00355"></a>00355                                     viennacl::traits::opencl_handle(NumericT(1)),
<a name="l00356"></a>00356                                     options_alpha,
<a name="l00357"></a>00357                                     viennacl::traits::opencl_handle(mat),
<a name="l00358"></a>00358                                     size_mat)
<a name="l00359"></a>00359                               );
<a name="l00360"></a>00360       }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00363"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ab08e5ac18770f6986292f001f5b3cf39">00363</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ab08e5ac18770f6986292f001f5b3cf39">matrix_row</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec)
<a name="l00364"></a>00364       {
<a name="l00365"></a>00365         <span class="comment">// reuse vector ambm kernel for assigning the elements:</span>
<a name="l00366"></a>00366         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00367"></a>00367         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;NumericT&gt;</a>  KernelClass;
<a name="l00368"></a>00368         KernelClass::init(ctx);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         cl_uint options_alpha = 0;
<a name="l00371"></a>00371         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_mat;
<a name="l00372"></a>00372         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__row__major.html" title="Helper class for checking whether a matrix has a row-major layout.">viennacl::is_row_major&lt;F&gt;::value</a>)
<a name="l00373"></a>00373         {
<a name="l00374"></a>00374           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint((<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + i * <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat) + <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat));
<a name="l00375"></a>00375           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00376"></a>00376           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00377"></a>00377           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00378"></a>00378         }
<a name="l00379"></a>00379         <span class="keywordflow">else</span>
<a name="l00380"></a>00380         {
<a name="l00381"></a>00381           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint((<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + i * <a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)) + <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat));
<a name="l00382"></a>00382           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat));
<a name="l00383"></a>00383           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00384"></a>00384           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00385"></a>00385         }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec;
<a name="l00388"></a>00388         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec));
<a name="l00389"></a>00389         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec));
<a name="l00390"></a>00390         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00391"></a>00391         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 
<a name="l00394"></a>00394         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; kern = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;av_cpu&quot;</span>);
<a name="l00395"></a>00395         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(kern(viennacl::traits::opencl_handle(vec),
<a name="l00396"></a>00396                                     size_vec,
<a name="l00397"></a>00397 
<a name="l00398"></a>00398                                     viennacl::traits::opencl_handle(NumericT(1)),
<a name="l00399"></a>00399                                     options_alpha,
<a name="l00400"></a>00400                                     viennacl::traits::opencl_handle(mat),
<a name="l00401"></a>00401                                     size_mat)
<a name="l00402"></a>00402                               );
<a name="l00403"></a>00403       }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00406"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa56da2b229799dda87c3de3416b3fae6">00406</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#aa56da2b229799dda87c3de3416b3fae6">matrix_column</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j, <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec)
<a name="l00407"></a>00407       {
<a name="l00408"></a>00408         <span class="comment">// reuse vector ambm kernel for assigning the elements:</span>
<a name="l00409"></a>00409         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00410"></a>00410         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1vector.html" title="Main kernel class for generating OpenCL kernels for operations on/with viennacl::vector&lt;&gt; without inv...">viennacl::linalg::opencl::kernels::vector&lt;NumericT&gt;</a>  KernelClass;
<a name="l00411"></a>00411         KernelClass::init(ctx);
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         cl_uint options_alpha = 0;
<a name="l00414"></a>00414         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_mat;
<a name="l00415"></a>00415         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__row__major.html" title="Helper class for checking whether a matrix has a row-major layout.">viennacl::is_row_major&lt;F&gt;::value</a>)
<a name="l00416"></a>00416         {
<a name="l00417"></a>00417           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat) + <a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) + j * <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00418"></a>00418           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat) * <a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat));
<a name="l00419"></a>00419           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00420"></a>00420           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422         <span class="keywordflow">else</span>
<a name="l00423"></a>00423         {
<a name="l00424"></a>00424           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat) + (<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat) + j * <a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat)) * <a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat));
<a name="l00425"></a>00425           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat));
<a name="l00426"></a>00426           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00427"></a>00427           size_mat.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430         <a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html" title="Helper class for packing four cl_uint numbers into a uint4 type for access inside an OpenCL kernel...">viennacl::ocl::packed_cl_uint</a> size_vec;
<a name="l00431"></a>00431         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a9cd8c2278eaf6d9d1a14c5d5880889d3" title="Starting value of the integer stride.">start</a>  = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec));
<a name="l00432"></a>00432         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a91e8b3e7e092538511386502e87b02d1" title="Increment between integers.">stride</a> = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec));
<a name="l00433"></a>00433         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#abe860bfc50dfb79de6cd9fc790b7a540" title="Number of values in the stride.">size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec));
<a name="l00434"></a>00434         size_vec.<a class="code" href="structviennacl_1_1ocl_1_1packed__cl__uint.html#a73d724fcbd5011ce6668e9dc59e22d2d" title="Internal length of the buffer. Might be larger than &#39;size&#39; due to padding.">internal_size</a>   = cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0cd530f8a76a5fb3d60a9230bea30bca" title="Helper routine for obtaining the buffer length of a ViennaCL vector.">viennacl::traits::internal_size</a>(vec));
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; kern = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;av_cpu&quot;</span>);
<a name="l00438"></a>00438         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(kern(viennacl::traits::opencl_handle(vec),
<a name="l00439"></a>00439                                     size_vec,
<a name="l00440"></a>00440 
<a name="l00441"></a>00441                                     viennacl::traits::opencl_handle(NumericT(1)),
<a name="l00442"></a>00442                                     options_alpha,
<a name="l00443"></a>00443                                     viennacl::traits::opencl_handle(mat),
<a name="l00444"></a>00444                                     size_mat)
<a name="l00445"></a>00445                               );
<a name="l00446"></a>00446       }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 
<a name="l00449"></a>00449       <span class="comment">//</span>
<a name="l00451"></a>00451 <span class="comment"></span>      <span class="comment">//</span>
<a name="l00452"></a>00452 
<a name="l00453"></a>00453       <span class="comment">// Binary operations A = B .* C and A = B ./ C</span>
<a name="l00459"></a>00459 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F, <span class="keyword">typename</span> OP&gt;
<a name="l00460"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f303555920a75cf584b894ddbb5c8c7">00460</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f303555920a75cf584b894ddbb5c8c7" title="Implementation of binary element-wise operations A = OP(B,C)">element_op</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F&gt;</a> &amp; A,
<a name="l00461"></a>00461                       <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F&gt;</a>, <a class="code" href="structviennacl_1_1op__element__binary.html" title="A tag class representing element-wise binary operations (like multiplication) on vectors or matrices...">op_element_binary&lt;OP&gt;</a> &gt; <span class="keyword">const</span> &amp; proxy)
<a name="l00462"></a>00462       {
<a name="l00463"></a>00463         assert(viennacl::traits::opencl_handle(A).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.lhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00464"></a>00464         assert(viennacl::traits::opencl_handle(A).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.rhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00465"></a>00465 
<a name="l00466"></a>00466         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(A).context());
<a name="l00467"></a>00467         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;T, F&gt;</a>  KernelClass;
<a name="l00468"></a>00468         KernelClass::init(ctx);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.get_kernel(KernelClass::program_name(), <span class="stringliteral">&quot;element_op&quot;</span>);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         cl_uint op_type = 2; <span class="comment">//0: product, 1: division, 2: power</span>
<a name="l00473"></a>00473         <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__division.html" title="Helper metafunction for checking whether the provided type is viennacl::op_div (for division)...">viennacl::is_division&lt;OP&gt;::value</a>)
<a name="l00474"></a>00474           op_type = 1;
<a name="l00475"></a>00475         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="structviennacl_1_1is__product.html" title="Helper metafunction for checking whether the provided type is viennacl::op_prod (for products/multipl...">viennacl::is_product&lt;OP&gt;::value</a>)
<a name="l00476"></a>00476           op_type = 0;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(A),
<a name="l00479"></a>00479                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(A)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(A)),
<a name="l00480"></a>00480                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(A)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(A)),
<a name="l00481"></a>00481                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A)),
<a name="l00482"></a>00482                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(A)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(A)),
<a name="l00483"></a>00483 
<a name="l00484"></a>00484                                 viennacl::traits::opencl_handle(proxy.lhs()),
<a name="l00485"></a>00485                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy.lhs())),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy.lhs())),
<a name="l00486"></a>00486                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy.lhs())),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy.lhs())),
<a name="l00487"></a>00487                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy.lhs())),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy.lhs())),
<a name="l00488"></a>00488 
<a name="l00489"></a>00489                                 viennacl::traits::opencl_handle(proxy.rhs()),
<a name="l00490"></a>00490                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy.rhs())),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy.rhs())),
<a name="l00491"></a>00491                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy.rhs())),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy.rhs())),
<a name="l00492"></a>00492                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy.rhs())),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy.rhs())),
<a name="l00493"></a>00493 
<a name="l00494"></a>00494                                 op_type)
<a name="l00495"></a>00495                               );
<a name="l00496"></a>00496       }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499       <span class="comment">// Unary operations</span>
<a name="l00500"></a>00500 
<a name="l00506"></a>00506       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F, <span class="keyword">typename</span> OP&gt;
<a name="l00507"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a324f491b1a020b7ea6deb9f589ff346e">00507</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9f303555920a75cf584b894ddbb5c8c7" title="Implementation of binary element-wise operations A = OP(B,C)">element_op</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F&gt;</a> &amp; A,
<a name="l00508"></a>00508                       <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a>&lt;<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;T, F&gt;</a>, <a class="code" href="structviennacl_1_1op__element__unary.html" title="A tag class representing element-wise unary operations (like sin()) on vectors or matrices...">op_element_unary&lt;OP&gt;</a> &gt; <span class="keyword">const</span> &amp; proxy)
<a name="l00509"></a>00509       {
<a name="l00510"></a>00510         assert(viennacl::traits::opencl_handle(A).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.lhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00511"></a>00511         assert(viennacl::traits::opencl_handle(A).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() == viennacl::traits::opencl_handle(proxy.rhs()).<a class="code" href="namespaceviennacl_1_1traits.html#a6707f5dab8f482170d2046a605f46ef8" title="Returns an ID for the currently active memory domain of an object.">context</a>() &amp;&amp; bool(<span class="stringliteral">&quot;Vectors do not reside in the same OpenCL context. Automatic migration not yet supported!&quot;</span>));
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(A).context());
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix__element.html" title="Main kernel class for generating OpenCL kernels for elementwise-operations such as element_sin() on/w...">viennacl::linalg::opencl::kernels::matrix_element&lt;T, F&gt;::init</a>(ctx);
<a name="l00516"></a>00516         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.get_kernel(<a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix__element.html" title="Main kernel class for generating OpenCL kernels for elementwise-operations such as element_sin() on/w...">viennacl::linalg::opencl::kernels::matrix_element&lt;T, F&gt;::program_name</a>(), <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#aaeb876e922457f997cd0e7f2a51c4e1d">detail::op_to_string</a>(OP()) + <span class="stringliteral">&quot;_assign&quot;</span>);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(A),
<a name="l00519"></a>00519                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(A)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(A)),
<a name="l00520"></a>00520                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(A)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(A)),
<a name="l00521"></a>00521                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A)),
<a name="l00522"></a>00522                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(A)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(A)),
<a name="l00523"></a>00523 
<a name="l00524"></a>00524                                  viennacl::traits::opencl_handle(proxy.lhs()),
<a name="l00525"></a>00525                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(proxy.lhs())),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(proxy.lhs())),
<a name="l00526"></a>00526                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(proxy.lhs())),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(proxy.lhs())),
<a name="l00527"></a>00527                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(proxy.lhs())),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(proxy.lhs())))
<a name="l00528"></a>00528                               );
<a name="l00529"></a>00529       }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 
<a name="l00532"></a>00532       <span class="comment">//</span>
<a name="l00534"></a>00534 <span class="comment"></span>      <span class="comment">//</span>
<a name="l00535"></a>00535 
<a name="l00536"></a>00536       <span class="comment">// A * x</span>
<a name="l00537"></a>00537 
<a name="l00546"></a>00546       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00547"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c">00547</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c" title="Carries out matrix-vector multiplication.">prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat,
<a name="l00548"></a>00548                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec,
<a name="l00549"></a>00549                            <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; result)
<a name="l00550"></a>00550       {
<a name="l00551"></a>00551         <span class="keyword">typedef</span> NumericT        value_type;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat).context());
<a name="l00554"></a>00554         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00555"></a>00555         KernelClass::init(ctx);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         assert(mat.<a class="code" href="classviennacl_1_1matrix__base.html#a608bdfa643e5a437579aac288fb98f96" title="Returns the number of columns.">size2</a>() == vec.<a class="code" href="classviennacl_1_1vector__base.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector)">size</a>());
<a name="l00558"></a>00558         <span class="comment">// Inplace matrix-vector products like x = prod(A, x) are currently illegal: Introduce a temporary like y = prod(A, x); x = y; instead</span>
<a name="l00559"></a>00559         assert(<a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(vec) != <a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(result) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;No direct inplace matrix-vector product possible. Introduce a temporary!&quot;</span>));
<a name="l00560"></a>00560         <span class="comment">//result.resize(mat.size1());</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;vec_mul&quot;</span>);
<a name="l00563"></a>00563         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat),
<a name="l00564"></a>00564                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat)),         cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat)),
<a name="l00565"></a>00565                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat)),        cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat)),
<a name="l00566"></a>00566                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat)),
<a name="l00567"></a>00567                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat)), cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat)),
<a name="l00568"></a>00568 
<a name="l00569"></a>00569                                 viennacl::traits::opencl_handle(vec),
<a name="l00570"></a>00570                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec)),
<a name="l00571"></a>00571                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec)),
<a name="l00572"></a>00572                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec)),
<a name="l00573"></a>00573 
<a name="l00574"></a>00574                                 viennacl::traits::opencl_handle(result),
<a name="l00575"></a>00575                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result)),
<a name="l00576"></a>00576                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00577"></a>00577                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(result)),
<a name="l00578"></a>00578 
<a name="l00579"></a>00579                                 <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(value_type) * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>())
<a name="l00580"></a>00580                               ) );
<a name="l00581"></a>00581       }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 
<a name="l00584"></a>00584       <span class="comment">// trans(A) * x</span>
<a name="l00585"></a>00585 
<a name="l00594"></a>00594       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F&gt;
<a name="l00595"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a972c6ffd063ee24ec70d673ba401f47d">00595</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c" title="Carries out matrix-vector multiplication.">prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; &amp; mat_trans,
<a name="l00596"></a>00596                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec,
<a name="l00597"></a>00597                            <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; result)
<a name="l00598"></a>00598       {
<a name="l00599"></a>00599         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat_trans) == <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(result)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size check failed for transposed matrix-vector product: size1(A^T) == size(result)&quot;</span>));
<a name="l00600"></a>00600         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat_trans) == <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size check failed for transposed matrix-vector product: size2(A^T) == size(x)&quot;</span>));  <span class="comment">//remember: mat is transposed!</span>
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 
<a name="l00603"></a>00603         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(vec).context());
<a name="l00604"></a>00604         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00605"></a>00605         KernelClass::init(ctx);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         <span class="comment">// Inplace matrix-vector products like x = prod(A, x) are currently illegal: Introduce a temporary like y = prod(A, x); x = y; instead</span>
<a name="l00609"></a>00609         assert(<a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(vec) != <a class="code" href="namespaceviennacl_1_1traits.html#ae39853b7f291a697e119a139439178fb" title="Returns the generic memory handle of an object. Non-const version.">viennacl::traits::handle</a>(result) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;No direct inplace transposed matrix-vector product possible. Introduce a temporary!&quot;</span>));
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <span class="stringliteral">&quot;trans_vec_mul&quot;</span>);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat_trans.lhs()),
<a name="l00614"></a>00614                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat_trans.lhs())),         cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat_trans.lhs())),
<a name="l00615"></a>00615                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat_trans.lhs())),        cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat_trans.lhs())),
<a name="l00616"></a>00616                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat_trans.lhs())),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat_trans.lhs())),
<a name="l00617"></a>00617                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat_trans.lhs())), cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat_trans.lhs())),
<a name="l00618"></a>00618 
<a name="l00619"></a>00619                                 viennacl::traits::opencl_handle(vec),
<a name="l00620"></a>00620                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec)),
<a name="l00621"></a>00621                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec)),
<a name="l00622"></a>00622                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec)),
<a name="l00623"></a>00623 
<a name="l00624"></a>00624                                 viennacl::traits::opencl_handle(result),
<a name="l00625"></a>00625                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(result)),
<a name="l00626"></a>00626                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(result)),
<a name="l00627"></a>00627                                 cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(result)),
<a name="l00628"></a>00628 
<a name="l00629"></a>00629                                 <a class="code" href="classviennacl_1_1ocl_1_1local__mem.html" title="A class representing local (shared) OpenCL memory. Typically used as kernel argument.">viennacl::ocl::local_mem</a>(<span class="keyword">sizeof</span>(NumericT) * k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>())
<a name="l00630"></a>00630                               ) );
<a name="l00631"></a>00631       }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 
<a name="l00634"></a>00634       <span class="comment">//</span>
<a name="l00636"></a>00636 <span class="comment"></span>      <span class="comment">//</span>
<a name="l00637"></a>00637 
<a name="l00638"></a>00638       <span class="keyword">namespace </span>detail
<a name="l00639"></a>00639       {
<a name="l00640"></a>00640         <span class="comment">// C = A * B and possibly transposed variants</span>
<a name="l00641"></a>00641         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00642"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a354f1f950ef4442ed4c2cb98bf8eed2d">00642</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a354f1f950ef4442ed4c2cb98bf8eed2d">prod_slow_kernel</a>(<span class="keyword">const</span> T1 &amp; A,
<a name="l00643"></a>00643                               <span class="keyword">const</span> T2 &amp; B,
<a name="l00644"></a>00644                               T3 &amp; C,
<a name="l00645"></a>00645                               ScalarType alpha,
<a name="l00646"></a>00646                               ScalarType beta,
<a name="l00647"></a>00647                               std::string kernel_name)
<a name="l00648"></a>00648         {
<a name="l00649"></a>00649           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cpu__value__type.html#af2881e25afe8aad2d19886ce9bb1b0ea">viennacl::result_of::cpu_value_type&lt; typename T1::value_type &gt;::type</a>   cpu_value_type;
<a name="l00650"></a>00650           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1orientation__functor.html#a4f95bd439c6f020fa6f84a100436c917">viennacl::result_of::orientation_functor&lt;T1&gt;::type</a>   orientation_A;
<a name="l00651"></a>00651           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1orientation__functor.html#a4f95bd439c6f020fa6f84a100436c917">viennacl::result_of::orientation_functor&lt;T2&gt;::type</a>   orientation_B;
<a name="l00652"></a>00652           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1orientation__functor.html#a4f95bd439c6f020fa6f84a100436c917">viennacl::result_of::orientation_functor&lt;T3&gt;::type</a>   orientation_C;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654           <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(A).context());
<a name="l00655"></a>00655 
<a name="l00656"></a>00656           <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix__prod.html" title="Main kernel class for the generation of matrix-matrix product kernels C = A * B.">viennacl::linalg::opencl::kernels::matrix_prod&lt;cpu_value_type, orientation_A, orientation_B, orientation_C&gt;</a>    KernelClass;
<a name="l00657"></a>00657           KernelClass::init(ctx);
<a name="l00658"></a>00658 
<a name="l00659"></a>00659           <span class="comment">//std::cout &lt;&lt; &quot;KernelClass::program_name() : &quot; &lt;&lt; KernelClass::program_name() &lt;&lt; std::endl;</span>
<a name="l00660"></a>00660           <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), kernel_name);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, viennacl::tools::align_to_multiple&lt;unsigned int&gt;(static_cast&lt;unsigned int&gt;(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C)), 16));
<a name="l00663"></a>00663           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(1, viennacl::tools::align_to_multiple&lt;unsigned int&gt;(static_cast&lt;unsigned int&gt;(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C)), 16));
<a name="l00664"></a>00664           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, 16);
<a name="l00665"></a>00665           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(1, 16);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667           cpu_value_type cl_alpha = <span class="keyword">static_cast&lt;</span>cpu_value_type<span class="keyword">&gt;</span>(alpha);
<a name="l00668"></a>00668           cpu_value_type cl_beta  = <span class="keyword">static_cast&lt;</span>cpu_value_type<span class="keyword">&gt;</span>(beta);
<a name="l00669"></a>00669 
<a name="l00670"></a>00670           <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(cl_alpha,
<a name="l00671"></a>00671                                   viennacl::traits::opencl_handle(A),
<a name="l00672"></a>00672                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(A)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(A)),
<a name="l00673"></a>00673                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(A)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(A)),
<a name="l00674"></a>00674                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A)),
<a name="l00675"></a>00675                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(A)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(A)),
<a name="l00676"></a>00676 
<a name="l00677"></a>00677                                   viennacl::traits::opencl_handle(B),
<a name="l00678"></a>00678                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(B)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(B)),
<a name="l00679"></a>00679                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(B)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(B)),
<a name="l00680"></a>00680                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B)),
<a name="l00681"></a>00681                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(B)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(B)),
<a name="l00682"></a>00682 
<a name="l00683"></a>00683                                   cl_beta,
<a name="l00684"></a>00684                                   viennacl::traits::opencl_handle(C),
<a name="l00685"></a>00685                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(C)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(C)),
<a name="l00686"></a>00686                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(C)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(C)),
<a name="l00687"></a>00687                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C)),
<a name="l00688"></a>00688                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(C)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(C))
<a name="l00689"></a>00689                                   )
<a name="l00690"></a>00690                                 );
<a name="l00691"></a>00691         }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693         <span class="comment">// C = A * B, using fast kernel for NVIDIA</span>
<a name="l00694"></a>00694         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00695"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a616147797999a21b400d263f9401a9cc">00695</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a616147797999a21b400d263f9401a9cc">prod_fast_kernel</a>(<span class="keyword">const</span> T1 &amp; A,
<a name="l00696"></a>00696                               <span class="keyword">const</span> T2 &amp; B,
<a name="l00697"></a>00697                               T3 &amp; C,
<a name="l00698"></a>00698                               ScalarType alpha,
<a name="l00699"></a>00699                               ScalarType beta,
<a name="l00700"></a>00700                               std::string kernel_name)
<a name="l00701"></a>00701         {
<a name="l00702"></a>00702           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1cpu__value__type.html#af2881e25afe8aad2d19886ce9bb1b0ea">viennacl::result_of::cpu_value_type&lt; typename T1::value_type &gt;::type</a>   cpu_value_type;
<a name="l00703"></a>00703           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1orientation__functor.html#a4f95bd439c6f020fa6f84a100436c917">viennacl::result_of::orientation_functor&lt;T1&gt;::type</a>   orientation_A;
<a name="l00704"></a>00704           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1orientation__functor.html#a4f95bd439c6f020fa6f84a100436c917">viennacl::result_of::orientation_functor&lt;T2&gt;::type</a>   orientation_B;
<a name="l00705"></a>00705           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1result__of_1_1orientation__functor.html#a4f95bd439c6f020fa6f84a100436c917">viennacl::result_of::orientation_functor&lt;T3&gt;::type</a>   orientation_C;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707           <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(A).context());
<a name="l00708"></a>00708 
<a name="l00709"></a>00709           <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix__prod.html" title="Main kernel class for the generation of matrix-matrix product kernels C = A * B.">viennacl::linalg::opencl::kernels::matrix_prod&lt;cpu_value_type, orientation_A, orientation_B, orientation_C&gt;</a>    KernelClass;
<a name="l00710"></a>00710           KernelClass::init(ctx);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712           <span class="comment">//std::cout &lt;&lt; &quot;KernelClass::program_name() : &quot; &lt;&lt; KernelClass::program_name() &lt;&lt; std::endl;</span>
<a name="l00713"></a>00713           <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), kernel_name);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(0, <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C) / 4); <span class="comment">//column blocks</span>
<a name="l00716"></a>00716           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a5fc10ff06a4c4a904541e76e0ebbd681" title="Returns the global work size at the respective dimension.">global_work_size</a>(1, <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C) / 4); <span class="comment">//row blocks</span>
<a name="l00717"></a>00717           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(0, 16);  <span class="comment">//columns</span>
<a name="l00718"></a>00718           k.<a class="code" href="classviennacl_1_1ocl_1_1kernel.html#a472a962c660c23be47f842ab8c9fe66f" title="Returns the local work size at the respective dimension.">local_work_size</a>(1, 4);   <span class="comment">//rows</span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720           cpu_value_type cl_alpha = <span class="keyword">static_cast&lt;</span>cpu_value_type<span class="keyword">&gt;</span>(alpha);
<a name="l00721"></a>00721           cpu_value_type cl_beta  = <span class="keyword">static_cast&lt;</span>cpu_value_type<span class="keyword">&gt;</span>(beta);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723           <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(cl_alpha,
<a name="l00724"></a>00724                                   viennacl::traits::opencl_handle(A),
<a name="l00725"></a>00725                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(A)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(A)),
<a name="l00726"></a>00726                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(A)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(A)),
<a name="l00727"></a>00727                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A)),
<a name="l00728"></a>00728                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(A)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(A)),
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                                   viennacl::traits::opencl_handle(B),
<a name="l00731"></a>00731                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(B)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(B)),
<a name="l00732"></a>00732                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(B)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(B)),
<a name="l00733"></a>00733                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B)),
<a name="l00734"></a>00734                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(B)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(B)),
<a name="l00735"></a>00735 
<a name="l00736"></a>00736                                   cl_beta,
<a name="l00737"></a>00737                                   viennacl::traits::opencl_handle(C),
<a name="l00738"></a>00738                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(C)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(C)),
<a name="l00739"></a>00739                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(C)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(C)),
<a name="l00740"></a>00740                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C)),
<a name="l00741"></a>00741                                   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(C)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(C))
<a name="l00742"></a>00742                                   )
<a name="l00743"></a>00743                                 );
<a name="l00744"></a>00744         }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00747"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#acf83f7f82d77a022af92f81519c1c513">00747</a>         <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#acf83f7f82d77a022af92f81519c1c513">prod</a>(<span class="keyword">const</span> T1 &amp; A,
<a name="l00748"></a>00748                   <span class="keyword">const</span> T2 &amp; B,
<a name="l00749"></a>00749                   T3 &amp; C,
<a name="l00750"></a>00750                   ScalarType alpha,
<a name="l00751"></a>00751                   ScalarType beta,
<a name="l00752"></a>00752                   std::string fast_kernel_name,
<a name="l00753"></a>00753                   std::string slow_kernel_name)
<a name="l00754"></a>00754         {
<a name="l00755"></a>00755           <span class="keywordflow">if</span> (   (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A) &lt; 64)
<a name="l00756"></a>00756               || (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A) &lt; 64)
<a name="l00757"></a>00757               || (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B) &lt; 64)
<a name="l00758"></a>00758               || (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B) &lt; 64) )   <span class="comment">//there is most likely not enough to compute, rendering kernel launch overhead considerable</span>
<a name="l00759"></a>00759           {
<a name="l00760"></a>00760             <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a354f1f950ef4442ed4c2cb98bf8eed2d">prod_slow_kernel</a>(A, B, C, alpha, beta, slow_kernel_name);
<a name="l00761"></a>00761           }
<a name="l00762"></a>00762           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (   (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A) % 64 == 0)
<a name="l00763"></a>00763                    &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A) % 64 == 0)
<a name="l00764"></a>00764                    &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B) % 64 == 0)
<a name="l00765"></a>00765                    &amp;&amp; (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B) % 64 == 0) )   <span class="comment">// allows the use of the fast NVIDIA kernel</span>
<a name="l00766"></a>00766           {
<a name="l00767"></a>00767             <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a616147797999a21b400d263f9401a9cc">prod_fast_kernel</a>(A, B, C, alpha, beta, fast_kernel_name);
<a name="l00768"></a>00768             <span class="comment">//prod_slow_kernel(A, B, C, slow_kernel_name);</span>
<a name="l00769"></a>00769           }
<a name="l00770"></a>00770           <span class="keywordflow">else</span> <span class="comment">//TODO: use four kernels</span>
<a name="l00771"></a>00771           {
<a name="l00772"></a>00772             <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a354f1f950ef4442ed4c2cb98bf8eed2d">prod_slow_kernel</a>(A, B, C, alpha, beta, slow_kernel_name);
<a name="l00773"></a>00773           }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775         }
<a name="l00776"></a>00776       } <span class="comment">// namespace detail</span>
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 
<a name="l00784"></a>00784       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00785"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adf6bc839f4dbacf60f69e70ff55a5ab5">00785</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c" title="Carries out matrix-vector multiplication.">prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; A,
<a name="l00786"></a>00786                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a> &amp; B,
<a name="l00787"></a>00787                            <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a> &amp; C,
<a name="l00788"></a>00788                      ScalarType alpha,
<a name="l00789"></a>00789                      ScalarType beta)
<a name="l00790"></a>00790       {
<a name="l00791"></a>00791         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(A, B): size1(A) != size1(C)&quot;</span>));
<a name="l00792"></a>00792         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(A, B): size2(A) != size1(B)&quot;</span>));
<a name="l00793"></a>00793         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(A, B): size2(B) != size2(C)&quot;</span>));
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordtype">bool</span> A_not_aligned = (A.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0) ||(A.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0);
<a name="l00796"></a>00796         <span class="keywordtype">bool</span> B_not_aligned = (B.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0) ||(B.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0);
<a name="l00797"></a>00797         <span class="keywordtype">bool</span> C_not_aligned = (C.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0) ||(C.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0);
<a name="l00798"></a>00798         <span class="comment">// Inplace matrix-vector products like B = prod(A, B) are currently illegal: Introduce a temporary like C = prod(A, B); B = C; instead</span>
<a name="l00799"></a>00799         <span class="comment">/*assert(  (viennacl::traits::handle(C) != viennacl::traits::handle(A))</span>
<a name="l00800"></a>00800 <span class="comment">              &amp;&amp; (viennacl::traits::handle(C) != viennacl::traits::handle(B))</span>
<a name="l00801"></a>00801 <span class="comment">              &amp;&amp; bool(&quot;No direct inplace matrix-matrix product possible. Introduce a temporary!&quot;));*/</span>
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="keywordflow">if</span>(A_not_aligned || A.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || A.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || A.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || A.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1
<a name="l00804"></a>00804          ||B_not_aligned || B.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || B.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || B.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || B.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1
<a name="l00805"></a>00805          ||C_not_aligned || C.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || C.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1)
<a name="l00806"></a>00806           <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#acf83f7f82d77a022af92f81519c1c513">detail::prod</a>(A, B, C, alpha, beta, <span class="stringliteral">&quot;prod16_AA&quot;</span>, <span class="stringliteral">&quot;prod_AA&quot;</span>);
<a name="l00807"></a>00807         <span class="keywordflow">else</span>{
<a name="l00808"></a>00808           <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression&lt;const matrix_base&lt;NumericT, F1&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <a class="code" href="structviennacl_1_1op__mat__mat__prod.html" title="A tag class representing matrix-matrix products.">op_mat_mat_prod</a>&gt; ProdType;
<a name="l00809"></a>00809           <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">viennacl::generator::generate_enqueue_statement</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a>(C, <a class="code" href="structviennacl_1_1op__assign.html" title="A tag class representing assignment.">viennacl::op_assign</a>(),alpha*ProdType(A,B)+beta*C));
<a name="l00810"></a>00810         }
<a name="l00811"></a>00811       }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 
<a name="l00820"></a>00820       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00821"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a554ee1a9856fb109afab7f5a5fa80e90">00821</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c" title="Carries out matrix-vector multiplication.">prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>,
<a name="l00822"></a>00822                                                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>,
<a name="l00823"></a>00823                                                         <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; &amp; A,
<a name="l00824"></a>00824                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a> &amp; B,
<a name="l00825"></a>00825                            <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a> &amp; C,
<a name="l00826"></a>00826                      ScalarType alpha,
<a name="l00827"></a>00827                      ScalarType beta)
<a name="l00828"></a>00828       {
<a name="l00829"></a>00829         <span class="comment">//std::cout &lt;&lt; &quot;size2(A): &quot; &lt;&lt; viennacl::traits::size2(A.lhs()) &lt;&lt; std::endl;</span>
<a name="l00830"></a>00830         <span class="comment">//std::cout &lt;&lt; &quot;size1(C): &quot; &lt;&lt; viennacl::traits::size1(C) &lt;&lt; std::endl;</span>
<a name="l00831"></a>00831         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A.lhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(trans(A), B): size2(A) != size1(C)&quot;</span>));
<a name="l00832"></a>00832         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A.lhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(trans(A), B): size1(A) != size1(B)&quot;</span>));
<a name="l00833"></a>00833         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B)       == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(trans(A), B): size2(B) != size2(C)&quot;</span>));
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         <span class="comment">// Inplace matrix-vector products like B = prod(A, B) are currently illegal: Introduce a temporary like C = prod(A, B); B = C; instead</span>
<a name="l00836"></a>00836         <span class="comment">/*assert(  (viennacl::traits::handle(C) != viennacl::traits::handle(A.lhs()))</span>
<a name="l00837"></a>00837 <span class="comment">              &amp;&amp; (viennacl::traits::handle(C) != viennacl::traits::handle(B))</span>
<a name="l00838"></a>00838 <span class="comment">              &amp;&amp; bool(&quot;No direct inplace matrix-matrix product possible. Introduce a temporary!&quot;));*/</span>
<a name="l00839"></a>00839 
<a name="l00840"></a>00840         <span class="keywordtype">bool</span> A_not_aligned = (A.lhs().internal_size1()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0) ||(A.lhs().internal_size2()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0);
<a name="l00841"></a>00841         <span class="keywordtype">bool</span> B_not_aligned = (B.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0) ||(B.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0);
<a name="l00842"></a>00842         <span class="keywordtype">bool</span> C_not_aligned = (C.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0) ||(C.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="keywordflow">if</span>(A_not_aligned || A.lhs().start1() &gt; 0 || A.lhs().start2() &gt; 0 || A.lhs().stride1() &gt; 1 || A.lhs().stride2() &gt; 1
<a name="l00846"></a>00846          ||B_not_aligned || B.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || B.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || B.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || B.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1
<a name="l00847"></a>00847          ||C_not_aligned || C.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || C.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1)
<a name="l00848"></a>00848           <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#acf83f7f82d77a022af92f81519c1c513">detail::prod</a>(A.lhs(), B, C, alpha, beta, <span class="stringliteral">&quot;prod16_TA&quot;</span>, <span class="stringliteral">&quot;prod_TA&quot;</span>);
<a name="l00849"></a>00849         <span class="keywordflow">else</span>{
<a name="l00850"></a>00850           <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression&lt; const matrix_base&lt;NumericT, F1&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; LhsType;
<a name="l00851"></a>00851           <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression&lt;LhsType, const matrix_base&lt;NumericT, F2&gt;</a>, <a class="code" href="structviennacl_1_1op__mat__mat__prod.html" title="A tag class representing matrix-matrix products.">op_mat_mat_prod</a>&gt; ProdType;
<a name="l00852"></a>00852           <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">viennacl::generator::generate_enqueue_statement</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a>(C, <a class="code" href="structviennacl_1_1op__assign.html" title="A tag class representing assignment.">viennacl::op_assign</a>(),alpha*ProdType(A,B)+beta*C));
<a name="l00853"></a>00853         }
<a name="l00854"></a>00854       }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 
<a name="l00864"></a>00864       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00865"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a9d5857a76f559b9af33ffaa9a0d131a4">00865</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c" title="Carries out matrix-vector multiplication.">prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a> &amp; A,
<a name="l00866"></a>00866                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; &amp; B,
<a name="l00867"></a>00867                            <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a> &amp; C,
<a name="l00868"></a>00868                      ScalarType alpha,
<a name="l00869"></a>00869                      ScalarType beta)
<a name="l00870"></a>00870       {
<a name="l00871"></a>00871         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A)       == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C))       &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(A, trans(B)): size1(A) != size1(C)&quot;</span>));
<a name="l00872"></a>00872         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A)       == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B.lhs())) &amp;&amp; bool(<span class="stringliteral">&quot;Size mismatch in C = prod(A, trans(B)): size2(A) != size2(B)&quot;</span>));
<a name="l00873"></a>00873         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B.lhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C))       &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(A, trans(B)): size1(B) != size2(C)&quot;</span>));
<a name="l00874"></a>00874 
<a name="l00875"></a>00875         <span class="keywordtype">bool</span> A_not_aligned = (A.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0) ||(A.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0);
<a name="l00876"></a>00876         <span class="keywordtype">bool</span> B_not_aligned = (B.lhs().internal_size1()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0) ||(B.lhs().internal_size2()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0);
<a name="l00877"></a>00877         <span class="keywordtype">bool</span> C_not_aligned = (C.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0) ||(C.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         <span class="comment">// Inplace matrix-vector products like B = prod(A, B) are currently illegal: Introduce a temporary like C = prod(A, B); B = C; instead</span>
<a name="l00880"></a>00880         <span class="comment">/*assert(  (viennacl::traits::handle(C) != viennacl::traits::handle(A))</span>
<a name="l00881"></a>00881 <span class="comment">              &amp;&amp; (viennacl::traits::handle(C) != viennacl::traits::handle(B.lhs()))</span>
<a name="l00882"></a>00882 <span class="comment">              &amp;&amp; bool(&quot;No direct inplace matrix-matrix product possible. Introduce a temporary!&quot;));*/</span>
<a name="l00883"></a>00883 
<a name="l00884"></a>00884         <span class="keywordflow">if</span>(A_not_aligned || A.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || A.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || A.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || A.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1
<a name="l00885"></a>00885          ||B_not_aligned || B.lhs().start1() &gt; 0 || B.lhs().start2() &gt; 0 || B.lhs().stride1() &gt; 1 || B.lhs().stride2() &gt; 1
<a name="l00886"></a>00886          ||C_not_aligned || C.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || C.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1)
<a name="l00887"></a>00887           <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#acf83f7f82d77a022af92f81519c1c513">detail::prod</a>(A, B.lhs(), C, alpha, beta, <span class="stringliteral">&quot;prod16_AT&quot;</span>, <span class="stringliteral">&quot;prod_AT&quot;</span>);
<a name="l00888"></a>00888         <span class="keywordflow">else</span>{
<a name="l00889"></a>00889           <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression&lt; const matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; RhsType;
<a name="l00890"></a>00890           <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression&lt;const matrix_base&lt;NumericT, F1&gt;</a>, RhsType, <a class="code" href="structviennacl_1_1op__mat__mat__prod.html" title="A tag class representing matrix-matrix products.">op_mat_mat_prod</a>&gt; ProdType;
<a name="l00891"></a>00891           <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">viennacl::generator::generate_enqueue_statement</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a>(C, <a class="code" href="structviennacl_1_1op__assign.html" title="A tag class representing assignment.">viennacl::op_assign</a>(),alpha*ProdType(A,B)+beta*C));
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893       }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 
<a name="l00896"></a>00896 
<a name="l00902"></a>00902       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2, <span class="keyword">typename</span> F3, <span class="keyword">typename</span> ScalarType &gt;
<a name="l00903"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#ae24f8d8a654308c7eee6b2c252d5aff5">00903</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#adcbfc4c4d10aa70e33bddf25ac1bd59c" title="Carries out matrix-vector multiplication.">prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; &amp; A,
<a name="l00904"></a>00904                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; &amp; B,
<a name="l00905"></a>00905                      <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;</a> &amp; C,
<a name="l00906"></a>00906                      ScalarType alpha,
<a name="l00907"></a>00907                      ScalarType beta)
<a name="l00908"></a>00908       {
<a name="l00909"></a>00909         assert(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(A.lhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(C)       &amp;&amp; bool(<span class="stringliteral">&quot;Size mismatch in C = prod(trans(A), trans(B)): size2(A) != size1(C)&quot;</span>));
<a name="l00910"></a>00910         assert(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(A.lhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(B.lhs()) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in C = prod(trans(A), trans(B)): size1(A) != size2(B)&quot;</span>));
<a name="l00911"></a>00911         assert(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(B.lhs()) == <a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(C)       &amp;&amp; bool(<span class="stringliteral">&quot;Size mismatch in C = prod(trans(A), trans(B)): size1(B) != size2(C)&quot;</span>));
<a name="l00912"></a>00912 
<a name="l00913"></a>00913         <span class="keywordtype">bool</span> A_not_aligned = (A.lhs().internal_size1()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0) ||(A.lhs().internal_size2()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;::alignment</a>&gt;0);
<a name="l00914"></a>00914         <span class="keywordtype">bool</span> B_not_aligned = (B.lhs().internal_size1()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0) ||(B.lhs().internal_size2()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;::alignment</a>&gt;0);
<a name="l00915"></a>00915         <span class="keywordtype">bool</span> C_not_aligned = (C.<a class="code" href="classviennacl_1_1matrix__base.html#a21887a4bdce3a40e4a7a55786dd757be" title="Returns the internal number of rows. Usually required for launching OpenCL kernels only...">internal_size1</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0) ||(C.<a class="code" href="classviennacl_1_1matrix__base.html#a8dd14d60fb098f4d951518bb37b846ba" title="Returns the internal number of columns. Usually required for launching OpenCL kernels only...">internal_size2</a>()%<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F3&gt;::alignment</a>&gt;0);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="comment">// Inplace matrix-vector products like B = prod(A, B) are currently illegal: Introduce a temporary like C = prod(A, B); B = C; instead</span>
<a name="l00918"></a>00918         <span class="comment">/*assert(  (viennacl::traits::handle(C) != viennacl::traits::handle(A.lhs()))</span>
<a name="l00919"></a>00919 <span class="comment">              &amp;&amp; (viennacl::traits::handle(C) != viennacl::traits::handle(B.lhs()))</span>
<a name="l00920"></a>00920 <span class="comment">              &amp;&amp; bool(&quot;No direct inplace matrix-matrix product possible. Introduce a temporary!&quot;));*/</span>
<a name="l00921"></a>00921 
<a name="l00922"></a>00922         <span class="keywordflow">if</span>(A_not_aligned || A.lhs().start1() &gt; 0 || A.lhs().start2() &gt; 0 || A.lhs().stride1() &gt; 1 || A.lhs().stride2() &gt; 1
<a name="l00923"></a>00923          ||B_not_aligned || B.lhs().start1() &gt; 0 || B.lhs().start2() &gt; 0 || B.lhs().stride1() &gt; 1 || B.lhs().stride2() &gt; 1
<a name="l00924"></a>00924          ||C_not_aligned || C.<a class="code" href="classviennacl_1_1matrix__base.html#a9bcd27e19871c257c75cb16c4b9469de" title="Returns the number of rows.">start1</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#ab9bdda4a57b0abb5e0942ebe1231c602" title="Returns the number of columns.">start2</a>() &gt; 0 || C.<a class="code" href="classviennacl_1_1matrix__base.html#af5ef35c5fe740ded67f04091f0be7787" title="Returns the number of rows.">stride1</a>() &gt; 1 || C.<a class="code" href="classviennacl_1_1matrix__base.html#a7ff411c6dbaea89f63bf81bbca1601dc" title="Returns the number of columns.">stride2</a>() &gt; 1)
<a name="l00925"></a>00925           <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#acf83f7f82d77a022af92f81519c1c513">detail::prod</a>(A.lhs(), B.lhs(), C, alpha, beta, <span class="stringliteral">&quot;prod16_TT&quot;</span>, <span class="stringliteral">&quot;prod_TT&quot;</span>);
<a name="l00926"></a>00926         <span class="keywordflow">else</span>{
<a name="l00927"></a>00927           <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression&lt; const matrix_base&lt;NumericT, F1&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F1&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; LhsType;
<a name="l00928"></a>00928           <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">viennacl::matrix_expression&lt; const matrix_base&lt;NumericT, F2&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F2&gt;</a>, <a class="code" href="structviennacl_1_1op__trans.html" title="A tag class representing transposed matrices.">op_trans</a>&gt; RhsType;
<a name="l00929"></a>00929           <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression&lt;LhsType, RhsType, op_mat_mat_prod&gt;</a> ProdType;
<a name="l00930"></a>00930           <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">viennacl::generator::generate_enqueue_statement</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a>(C, <a class="code" href="structviennacl_1_1op__assign.html" title="A tag class representing assignment.">viennacl::op_assign</a>(),alpha*ProdType(A,B)+beta*C));
<a name="l00931"></a>00931         }
<a name="l00932"></a>00932       }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 
<a name="l00936"></a>00936 
<a name="l00937"></a>00937       <span class="comment">//</span>
<a name="l00939"></a>00939 <span class="comment"></span>      <span class="comment">//</span>
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 
<a name="l00954"></a>00954       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> F, <span class="keyword">typename</span> S1&gt;
<a name="l00955"></a><a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a26e29c2826a37e8aa26be59dda39e2b2">00955</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl.html#a26e29c2826a37e8aa26be59dda39e2b2" title="The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update...">scaled_rank_1_update</a>(<a class="code" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base&lt;NumericT, F&gt;</a> &amp; mat1,
<a name="l00956"></a>00956                                 S1 <span class="keyword">const</span> &amp; alpha, <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> len_alpha, <span class="keywordtype">bool</span> reciprocal_alpha, <span class="keywordtype">bool</span> flip_sign_alpha,
<a name="l00957"></a>00957                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec1,
<a name="l00958"></a>00958                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base&lt;NumericT&gt;</a> &amp; vec2)
<a name="l00959"></a>00959       {
<a name="l00960"></a>00960         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in scaled_rank_1_update: size1(A) != size(v1)&quot;</span>));
<a name="l00961"></a>00961         assert( (<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat1) == <a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2)) &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Size mismatch in scaled_rank_1_update: size2(A) != size(v2)&quot;</span>));
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp; ctx = <span class="keyword">const_cast&lt;</span><a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> &amp;<span class="keyword">&gt;</span>(viennacl::traits::opencl_handle(mat1).context());
<a name="l00964"></a>00964         <span class="keyword">typedef</span> <a class="code" href="structviennacl_1_1linalg_1_1opencl_1_1kernels_1_1matrix.html" title="Main kernel class for generating OpenCL kernels for operations on/with dense matrix objects of type v...">viennacl::linalg::opencl::kernels::matrix&lt;NumericT, F&gt;</a>  KernelClass;
<a name="l00965"></a>00965         KernelClass::init(ctx);
<a name="l00966"></a>00966 
<a name="l00967"></a>00967         cl_uint options_alpha = <a class="code" href="namespaceviennacl_1_1linalg_1_1opencl_1_1detail.html#a685282399bcfb05ee912c02fed7f922f">detail::make_options</a>(len_alpha, reciprocal_alpha, flip_sign_alpha);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = ctx.<a class="code" href="classviennacl_1_1ocl_1_1context.html#a113db299ce90d5a8f23aa9645c6b0bc4" title="Convenience function for retrieving the kernel of a program directly from the context.">get_kernel</a>(KernelClass::program_name(), <a class="code" href="structviennacl_1_1is__cpu__scalar.html" title="Helper struct for checking whether a type is a host scalar type (e.g. float, double)">viennacl::is_cpu_scalar&lt;S1&gt;::value</a> ? <span class="stringliteral">&quot;scaled_rank1_update_cpu&quot;</span> : <span class="stringliteral">&quot;scaled_rank1_update_gpu&quot;</span>);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(k(viennacl::traits::opencl_handle(mat1),
<a name="l00972"></a>00972                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ae601425decc5f1a8763ab5272e9e492f">viennacl::traits::start1</a>(mat1)),           cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ac53fc8cc9836953dc87aaaaa56f382c2">viennacl::traits::start2</a>(mat1)),
<a name="l00973"></a>00973                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0d4d5d35fa844934e00ae133f8a04f18">viennacl::traits::stride1</a>(mat1)),          cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a092f4e3cdf7d24da44c926f0b93d141e">viennacl::traits::stride2</a>(mat1)),
<a name="l00974"></a>00974                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">viennacl::traits::size1</a>(mat1)),            cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">viennacl::traits::size2</a>(mat1)),
<a name="l00975"></a>00975                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a0f401bffef0c3ad2066866ba5edfc18b" title="Helper routine for obtaining the internal number of entries per row of a ViennaCL matrix...">viennacl::traits::internal_size1</a>(mat1)),   cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#ada384e6d4801b4183bbb58241b7ee164" title="Helper routine for obtaining the internal number of entries per column of a ViennaCL matrix...">viennacl::traits::internal_size2</a>(mat1)),
<a name="l00976"></a>00976 
<a name="l00977"></a>00977                                  viennacl::traits::opencl_handle(viennacl::tools::promote_if_host_scalar&lt;NumericT&gt;(alpha)),
<a name="l00978"></a>00978                                  options_alpha,
<a name="l00979"></a>00979 
<a name="l00980"></a>00980                                  viennacl::traits::opencl_handle(vec1),
<a name="l00981"></a>00981                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec1)),
<a name="l00982"></a>00982                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec1)),
<a name="l00983"></a>00983                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec1)),
<a name="l00984"></a>00984 
<a name="l00985"></a>00985                                  viennacl::traits::opencl_handle(vec2),
<a name="l00986"></a>00986                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a68603a1e1ca1bfb6d107831ba5096786">viennacl::traits::start</a>(vec2)),
<a name="l00987"></a>00987                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#a09997870f4802fa5d4ac2c43cf4020d1">viennacl::traits::stride</a>(vec2)),
<a name="l00988"></a>00988                                  cl_uint(<a class="code" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">viennacl::traits::size</a>(vec2))
<a name="l00989"></a>00989                                 )
<a name="l00990"></a>00990                               );
<a name="l00991"></a>00991       }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     } <span class="comment">// namespace opencl</span>
<a name="l00994"></a>00994   } <span class="comment">//namespace linalg</span>
<a name="l00995"></a>00995 } <span class="comment">//namespace viennacl</span>
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:33 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
