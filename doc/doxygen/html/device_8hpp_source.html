<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/ocl/device.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/ocl/device.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="device_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_OCL_DEVICE_HPP_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_OCL_DEVICE_HPP_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2014, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="preprocessor">#ifdef __APPLE__</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#include &lt;OpenCL/cl.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#else</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#include &lt;CL/cl.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#endif</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="preprocessor">#include&lt;stdio.h&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="device__utils_8hpp.html" title="Various utility implementations for dispatching with respect to the different devices available on th...">viennacl/ocl/device_utils.hpp</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="ocl_2handle_8hpp.html" title="Implementation of a smart-pointer-like class for handling OpenCL handles.">viennacl/ocl/handle.hpp</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="error_8hpp.html" title="Error handling for the OpenCL layer of ViennaCL.">viennacl/ocl/error.hpp</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="keyword">namespace </span>viennacl
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043   <span class="keyword">namespace </span>ocl
<a name="l00044"></a>00044   {
<a name="l00045"></a>00045 
<a name="l00049"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html">00049</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1ocl_1_1device.html" title="A class representing a compute device (e.g. a GPU)">device</a>
<a name="l00050"></a>00050     {
<a name="l00051"></a>00051       <span class="keyword">public</span>:
<a name="l00052"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#aa6214b6ab6f2d943669af7dd76cef3a2">00052</a>         <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#aa6214b6ab6f2d943669af7dd76cef3a2">device</a>() : device_(0) { flush_cache(); }
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a17858dabba4d274000c38bc42de8487c">00054</a>         <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#aa6214b6ab6f2d943669af7dd76cef3a2">device</a>(cl_device_id dev) : device_(dev)
<a name="l00055"></a>00055         {
<a name="l00056"></a>00056 <span class="preprocessor">          #if defined(VIENNACL_DEBUG_ALL) || defined(VIENNACL_DEBUG_DEVICE)</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;ViennaCL: Creating device object (CTOR with cl_device_id)&quot;</span> &lt;&lt; std::endl;
<a name="l00058"></a>00058 <span class="preprocessor">          #endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>          flush_cache();
<a name="l00060"></a>00060         }
<a name="l00061"></a>00061 
<a name="l00062"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a58ac501d01e9cb8eac21a831e8f0874c">00062</a>         <a class="code" href="classviennacl_1_1ocl_1_1device.html#aa6214b6ab6f2d943669af7dd76cef3a2">device</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html" title="A class representing a compute device (e.g. a GPU)">device</a> &amp; other) : device_(0)
<a name="l00063"></a>00063         {
<a name="l00064"></a>00064 <span class="preprocessor">          #if defined(VIENNACL_DEBUG_ALL) || defined(VIENNACL_DEBUG_DEVICE)</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;ViennaCL: Creating device object (Copy CTOR)&quot;</span> &lt;&lt; std::endl;
<a name="l00066"></a>00066 <span class="preprocessor">          #endif</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (device_ != other.device_)
<a name="l00068"></a>00068           {
<a name="l00069"></a>00069             device_ = other.device_;
<a name="l00070"></a>00070             flush_cache();
<a name="l00071"></a>00071           }
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 
<a name="l00075"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a8309715ac80d84b3d33928d7447b5258">00075</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8309715ac80d84b3d33928d7447b5258" title="The default compute device address space size specified as an unsigned integer value in bits...">address_bits</a>()<span class="keyword"> const</span>
<a name="l00076"></a>00076 <span class="keyword">        </span>{
<a name="l00077"></a>00077           <span class="keywordflow">if</span> (!address_bits_valid_)
<a name="l00078"></a>00078           {
<a name="l00079"></a>00079             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_ADDRESS_BITS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;address_bits_), NULL);
<a name="l00080"></a>00080             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00081"></a>00081             address_bits_valid_ = <span class="keyword">true</span>;
<a name="l00082"></a>00082           }
<a name="l00083"></a>00083           <span class="keywordflow">return</span> address_bits_;
<a name="l00084"></a>00084         }
<a name="l00085"></a>00085 
<a name="l00087"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f220d225a572fc920524892902aac60">00087</a>         cl_bool <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f220d225a572fc920524892902aac60" title="Is CL_TRUE if the device is available and CL_FALSE if the device is not available.">available</a>()<span class="keyword"> const</span>
<a name="l00088"></a>00088 <span class="keyword">        </span>{
<a name="l00089"></a>00089           <span class="keywordflow">if</span> (!available_valid_)
<a name="l00090"></a>00090           {
<a name="l00091"></a>00091             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_AVAILABLE, <span class="keyword">sizeof</span>(cl_bool), static_cast&lt;void *&gt;(&amp;available_), NULL);
<a name="l00092"></a>00092             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00093"></a>00093             available_valid_ = <span class="keyword">true</span>;
<a name="l00094"></a>00094           }
<a name="l00095"></a>00095           <span class="keywordflow">return</span> available_;
<a name="l00096"></a>00096         }
<a name="l00097"></a>00097 
<a name="l00099"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f365008733eabcd519578beb099b0d7">00099</a>         cl_bool <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f365008733eabcd519578beb099b0d7" title="Is CL_FALSE if the implementation does not have a compiler available to compile the program source...">compiler_available</a>()<span class="keyword"> const</span>
<a name="l00100"></a>00100 <span class="keyword">        </span>{
<a name="l00101"></a>00101           <span class="keywordflow">if</span> (!compiler_available_valid_)
<a name="l00102"></a>00102           {
<a name="l00103"></a>00103             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_COMPILER_AVAILABLE , <span class="keyword">sizeof</span>(cl_bool), static_cast&lt;void *&gt;(&amp;compiler_available_), NULL);
<a name="l00104"></a>00104             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00105"></a>00105             compiler_available_valid_ = <span class="keyword">true</span>;
<a name="l00106"></a>00106           }
<a name="l00107"></a>00107           <span class="keywordflow">return</span> compiler_available_;
<a name="l00108"></a>00108         }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="preprocessor">#ifdef CL_DEVICE_DOUBLE_FP_CONFIG</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>
<a name="l00124"></a>00124         cl_device_fp_config double_fp_config()<span class="keyword"> const</span>
<a name="l00125"></a>00125 <span class="keyword">        </span>{
<a name="l00126"></a>00126           <span class="keywordflow">if</span> (!double_fp_config_valid_)
<a name="l00127"></a>00127           {
<a name="l00128"></a>00128             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_DOUBLE_FP_CONFIG, <span class="keyword">sizeof</span>(cl_device_fp_config), static_cast&lt;void *&gt;(&amp;double_fp_config_), NULL);
<a name="l00129"></a>00129             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00130"></a>00130             double_fp_config_valid_ = <span class="keyword">true</span>;
<a name="l00131"></a>00131           }
<a name="l00132"></a>00132           <span class="keywordflow">return</span> double_fp_config_;
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134 <span class="preprocessor">#endif</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00137"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a186dc1deea58169fb2044c13e952bf0b">00137</a>         cl_bool <a class="code" href="classviennacl_1_1ocl_1_1device.html#a186dc1deea58169fb2044c13e952bf0b" title="Is CL_TRUE if the OpenCL device is a little endian device and CL_FALSE otherwise.">endian_little</a>()<span class="keyword"> const</span>
<a name="l00138"></a>00138 <span class="keyword">        </span>{
<a name="l00139"></a>00139           <span class="keywordflow">if</span> (!endian_little_valid_)
<a name="l00140"></a>00140           {
<a name="l00141"></a>00141             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_ENDIAN_LITTLE, <span class="keyword">sizeof</span>(cl_bool), static_cast&lt;void *&gt;(&amp;endian_little_), NULL);
<a name="l00142"></a>00142             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00143"></a>00143             endian_little_valid_ = <span class="keyword">true</span>;
<a name="l00144"></a>00144           }
<a name="l00145"></a>00145           <span class="keywordflow">return</span> endian_little_;
<a name="l00146"></a>00146         }
<a name="l00147"></a>00147 
<a name="l00149"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ac11837beee79843ef898d9cf12652474">00149</a>         cl_bool <a class="code" href="classviennacl_1_1ocl_1_1device.html#ac11837beee79843ef898d9cf12652474" title="Is CL_TRUE if the device implements error correction for all accesses to compute device memory (globa...">error_correction_support</a>()<span class="keyword"> const</span>
<a name="l00150"></a>00150 <span class="keyword">        </span>{
<a name="l00151"></a>00151           <span class="keywordflow">if</span> (!error_correction_support_valid_)
<a name="l00152"></a>00152           {
<a name="l00153"></a>00153             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_ERROR_CORRECTION_SUPPORT , <span class="keyword">sizeof</span>(cl_bool), static_cast&lt;void *&gt;(&amp;error_correction_support_), NULL);
<a name="l00154"></a>00154             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00155"></a>00155             error_correction_support_valid_ = <span class="keyword">true</span>;
<a name="l00156"></a>00156           }
<a name="l00157"></a>00157           <span class="keywordflow">return</span> error_correction_support_;
<a name="l00158"></a>00158         }
<a name="l00159"></a>00159 
<a name="l00167"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a2ce02d6139f3833916c66fdd883b6a8d">00167</a>         cl_device_exec_capabilities <a class="code" href="classviennacl_1_1ocl_1_1device.html#a2ce02d6139f3833916c66fdd883b6a8d" title="Describes the execution capabilities of the device.">execution_capabilities</a>()<span class="keyword"> const</span>
<a name="l00168"></a>00168 <span class="keyword">        </span>{
<a name="l00169"></a>00169           <span class="keywordflow">if</span> (!execution_capabilities_valid_)
<a name="l00170"></a>00170           {
<a name="l00171"></a>00171             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_EXECUTION_CAPABILITIES  , <span class="keyword">sizeof</span>(cl_device_exec_capabilities), static_cast&lt;void *&gt;(&amp;execution_capabilities_), NULL);
<a name="l00172"></a>00172             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00173"></a>00173             execution_capabilities_valid_ = <span class="keyword">true</span>;
<a name="l00174"></a>00174           }
<a name="l00175"></a>00175           <span class="keywordflow">return</span> execution_capabilities_;
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177 
<a name="l00189"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378">00189</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378" title="Returns a space-separated list of extension names (the extension names themselves do not contain any ...">extensions</a>()<span class="keyword"> const</span>
<a name="l00190"></a>00190 <span class="keyword">        </span>{
<a name="l00191"></a>00191           <span class="keywordflow">if</span> (!extensions_valid_)
<a name="l00192"></a>00192           {
<a name="l00193"></a>00193             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_EXTENSIONS, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 2048, static_cast&lt;void *&gt;(&amp;extensions_), NULL);
<a name="l00194"></a>00194             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00195"></a>00195             extensions_valid_ = <span class="keyword">true</span>;
<a name="l00196"></a>00196           }
<a name="l00197"></a>00197           <span class="keywordflow">return</span> extensions_;
<a name="l00198"></a>00198         }
<a name="l00199"></a>00199 
<a name="l00201"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad1fc58e70bbf8de4ce006f2b20fe5247">00201</a>         cl_ulong <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad1fc58e70bbf8de4ce006f2b20fe5247" title="Size of global memory cache in bytes.">global_mem_cache_size</a>()<span class="keyword"> const</span>
<a name="l00202"></a>00202 <span class="keyword">        </span>{
<a name="l00203"></a>00203           <span class="keywordflow">if</span> (!global_mem_cache_size_valid_)
<a name="l00204"></a>00204           {
<a name="l00205"></a>00205             cl_int err = clGetDeviceInfo(device_,  CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, <span class="keyword">sizeof</span>(cl_ulong), static_cast&lt;void *&gt;(&amp;global_mem_cache_size_), NULL);
<a name="l00206"></a>00206             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00207"></a>00207             global_mem_cache_size_valid_ = <span class="keyword">true</span>;
<a name="l00208"></a>00208           }
<a name="l00209"></a>00209           <span class="keywordflow">return</span> global_mem_cache_size_;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211 
<a name="l00213"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ae4afa4cd9be93609dbd0bb79345368e4">00213</a>         cl_device_mem_cache_type <a class="code" href="classviennacl_1_1ocl_1_1device.html#ae4afa4cd9be93609dbd0bb79345368e4" title="Type of global memory cache supported. Valid values are: CL_NONE, CL_READ_ONLY_CACHE, and CL_READ_WRITE_CACHE.">global_mem_cache_type</a>()<span class="keyword"> const</span>
<a name="l00214"></a>00214 <span class="keyword">        </span>{
<a name="l00215"></a>00215           <span class="keywordflow">if</span> (!global_mem_cache_type_valid_)
<a name="l00216"></a>00216           {
<a name="l00217"></a>00217             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, <span class="keyword">sizeof</span>(cl_device_mem_cache_type), static_cast&lt;void *&gt;(&amp;global_mem_cache_type_), NULL);
<a name="l00218"></a>00218             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00219"></a>00219             global_mem_cache_type_valid_ = <span class="keyword">true</span>;
<a name="l00220"></a>00220           }
<a name="l00221"></a>00221           <span class="keywordflow">return</span> global_mem_cache_type_;
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223 
<a name="l00225"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a6c21e467f78c1a7a37d51a303729d5a2">00225</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a6c21e467f78c1a7a37d51a303729d5a2" title="Size of global memory cache in bytes.">global_mem_cacheline_size</a>()<span class="keyword"> const</span>
<a name="l00226"></a>00226 <span class="keyword">        </span>{
<a name="l00227"></a>00227           <span class="keywordflow">if</span> (!global_mem_cacheline_size_valid_)
<a name="l00228"></a>00228           {
<a name="l00229"></a>00229             cl_int err = clGetDeviceInfo(device_,  CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;global_mem_cacheline_size_), NULL);
<a name="l00230"></a>00230             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00231"></a>00231             global_mem_cacheline_size_valid_ = <span class="keyword">true</span>;
<a name="l00232"></a>00232           }
<a name="l00233"></a>00233           <span class="keywordflow">return</span> global_mem_cacheline_size_;
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235 
<a name="l00237"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad45acc1aefd8535b948f28cbdc11f1c9">00237</a>         cl_ulong <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad45acc1aefd8535b948f28cbdc11f1c9" title="Size of global memory in bytes.">global_mem_size</a>()<span class="keyword"> const</span>
<a name="l00238"></a>00238 <span class="keyword">        </span>{
<a name="l00239"></a>00239           <span class="keywordflow">if</span> (!global_mem_size_valid_)
<a name="l00240"></a>00240           {
<a name="l00241"></a>00241             cl_int err = clGetDeviceInfo(device_,  CL_DEVICE_GLOBAL_MEM_SIZE, <span class="keyword">sizeof</span>(cl_ulong), static_cast&lt;void *&gt;(&amp;global_mem_size_), NULL);
<a name="l00242"></a>00242             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00243"></a>00243             global_mem_size_valid_ = <span class="keyword">true</span>;
<a name="l00244"></a>00244           }
<a name="l00245"></a>00245           <span class="keywordflow">return</span> global_mem_size_;
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="preprocessor">#ifdef CL_DEVICE_HALF_FP_CONFIG</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span>
<a name="l00261"></a>00261         cl_device_fp_config half_fp_config()<span class="keyword"> const</span>
<a name="l00262"></a>00262 <span class="keyword">        </span>{
<a name="l00263"></a>00263           <span class="keywordflow">if</span> (!half_fp_config_valid_)
<a name="l00264"></a>00264           {
<a name="l00265"></a>00265             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_HALF_FP_CONFIG, <span class="keyword">sizeof</span>(cl_device_fp_config), static_cast&lt;void *&gt;(&amp;half_fp_config_), NULL);
<a name="l00266"></a>00266             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00267"></a>00267             half_fp_config_valid_ = <span class="keyword">true</span>;
<a name="l00268"></a>00268           }
<a name="l00269"></a>00269           <span class="keywordflow">return</span> half_fp_config_;
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271 <span class="preprocessor">#endif</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span>
<a name="l00274"></a>00274 <span class="preprocessor">#ifdef CL_DEVICE_HOST_UNIFIED_MEMORY</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>        cl_bool host_unified_memory()<span class="keyword"> const</span>
<a name="l00276"></a>00276 <span class="keyword">        </span>{
<a name="l00277"></a>00277           <span class="keywordflow">if</span> (!host_unified_memory_valid_)
<a name="l00278"></a>00278           {
<a name="l00279"></a>00279             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_HOST_UNIFIED_MEMORY, <span class="keyword">sizeof</span>(cl_bool), static_cast&lt;void *&gt;(&amp;host_unified_memory_), NULL);
<a name="l00280"></a>00280             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00281"></a>00281             host_unified_memory_valid_ = <span class="keyword">true</span>;
<a name="l00282"></a>00282           }
<a name="l00283"></a>00283           <span class="keywordflow">return</span> host_unified_memory_;
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285 <span class="preprocessor">#endif</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00288"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#af6a152b64e7f80a18df3aafc9303e4bd">00288</a>         cl_bool <a class="code" href="classviennacl_1_1ocl_1_1device.html#af6a152b64e7f80a18df3aafc9303e4bd" title="Is CL_TRUE if the device and the host have a unified memory subsystem and is CL_FALSE otherwise...">image_support</a>()<span class="keyword"> const</span>
<a name="l00289"></a>00289 <span class="keyword">        </span>{
<a name="l00290"></a>00290           <span class="keywordflow">if</span> (!image_support_valid_)
<a name="l00291"></a>00291           {
<a name="l00292"></a>00292             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_IMAGE_SUPPORT, <span class="keyword">sizeof</span>(cl_bool), static_cast&lt;void *&gt;(&amp;image_support_), NULL);
<a name="l00293"></a>00293             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00294"></a>00294             image_support_valid_ = <span class="keyword">true</span>;
<a name="l00295"></a>00295           }
<a name="l00296"></a>00296           <span class="keywordflow">return</span> image_support_;
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298 
<a name="l00300"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a27c69153da9c199b28607cd6fe539720">00300</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a27c69153da9c199b28607cd6fe539720" title="Max height of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image2d_max_height</a>()<span class="keyword"> const</span>
<a name="l00301"></a>00301 <span class="keyword">        </span>{
<a name="l00302"></a>00302           <span class="keywordflow">if</span> (!image2d_max_height_valid_)
<a name="l00303"></a>00303           {
<a name="l00304"></a>00304             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_IMAGE2D_MAX_HEIGHT, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;image2d_max_height_), NULL);
<a name="l00305"></a>00305             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00306"></a>00306             image2d_max_height_valid_ = <span class="keyword">true</span>;
<a name="l00307"></a>00307           }
<a name="l00308"></a>00308           <span class="keywordflow">return</span> image2d_max_height_;
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310 
<a name="l00312"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a891f1c8a5008296e36c5243c6b553157">00312</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a891f1c8a5008296e36c5243c6b553157" title="Max width of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image2d_max_width</a>()<span class="keyword"> const</span>
<a name="l00313"></a>00313 <span class="keyword">        </span>{
<a name="l00314"></a>00314           <span class="keywordflow">if</span> (!image2d_max_width_valid_)
<a name="l00315"></a>00315           {
<a name="l00316"></a>00316             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_IMAGE2D_MAX_WIDTH, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;image2d_max_width_), NULL);
<a name="l00317"></a>00317             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00318"></a>00318             image2d_max_width_valid_ = <span class="keyword">true</span>;
<a name="l00319"></a>00319           }
<a name="l00320"></a>00320           <span class="keywordflow">return</span> image2d_max_width_;
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322 
<a name="l00324"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#acd51b91e6ef23771cb6f5f5bfddac634">00324</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#acd51b91e6ef23771cb6f5f5bfddac634" title="Max depth of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image3d_max_depth</a>()<span class="keyword"> const</span>
<a name="l00325"></a>00325 <span class="keyword">        </span>{
<a name="l00326"></a>00326           <span class="keywordflow">if</span> (!image3d_max_depth_valid_)
<a name="l00327"></a>00327           {
<a name="l00328"></a>00328             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_IMAGE3D_MAX_DEPTH, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;image3d_max_depth_), NULL);
<a name="l00329"></a>00329             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00330"></a>00330             image3d_max_depth_valid_ = <span class="keyword">true</span>;
<a name="l00331"></a>00331           }
<a name="l00332"></a>00332           <span class="keywordflow">return</span> image3d_max_depth_;
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334 
<a name="l00336"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a1350aeecc36ebcecc7535695117f87fe">00336</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1350aeecc36ebcecc7535695117f87fe" title="Max height of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image3d_max_height</a>()<span class="keyword"> const</span>
<a name="l00337"></a>00337 <span class="keyword">        </span>{
<a name="l00338"></a>00338           <span class="keywordflow">if</span> (!image3d_max_height_valid_)
<a name="l00339"></a>00339           {
<a name="l00340"></a>00340             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_IMAGE3D_MAX_HEIGHT, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;image3d_max_height_), NULL);
<a name="l00341"></a>00341             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00342"></a>00342             image3d_max_height_valid_ = <span class="keyword">true</span>;
<a name="l00343"></a>00343           }
<a name="l00344"></a>00344           <span class="keywordflow">return</span> image3d_max_height_;
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346 
<a name="l00348"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad1e0b838ced23bfd058a80b64af96281">00348</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad1e0b838ced23bfd058a80b64af96281" title="Max width of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image3d_max_width</a>()<span class="keyword"> const</span>
<a name="l00349"></a>00349 <span class="keyword">        </span>{
<a name="l00350"></a>00350           <span class="keywordflow">if</span> (!image3d_max_width_valid_)
<a name="l00351"></a>00351           {
<a name="l00352"></a>00352             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_IMAGE3D_MAX_WIDTH, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;image3d_max_width_), NULL);
<a name="l00353"></a>00353             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00354"></a>00354             image3d_max_width_valid_ = <span class="keyword">true</span>;
<a name="l00355"></a>00355           }
<a name="l00356"></a>00356           <span class="keywordflow">return</span> image3d_max_width_;
<a name="l00357"></a>00357         }
<a name="l00358"></a>00358 
<a name="l00360"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a089c660aee310ef2c01aa5171239f7de">00360</a>         cl_ulong <a class="code" href="classviennacl_1_1ocl_1_1device.html#a089c660aee310ef2c01aa5171239f7de" title="Size of local memory arena in bytes. The minimum value is 32 KB.">local_mem_size</a>()<span class="keyword"> const</span>
<a name="l00361"></a>00361 <span class="keyword">        </span>{
<a name="l00362"></a>00362           <span class="keywordflow">if</span> (!local_mem_size_valid_)
<a name="l00363"></a>00363           {
<a name="l00364"></a>00364             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_LOCAL_MEM_SIZE, <span class="keyword">sizeof</span>(cl_ulong), static_cast&lt;void *&gt;(&amp;local_mem_size_), NULL);
<a name="l00365"></a>00365             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00366"></a>00366             local_mem_size_valid_ = <span class="keyword">true</span>;
<a name="l00367"></a>00367           }
<a name="l00368"></a>00368           <span class="keywordflow">return</span> local_mem_size_;
<a name="l00369"></a>00369         }
<a name="l00370"></a>00370 
<a name="l00372"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a8091787f68d0b4fec54982ac60ff0e58">00372</a>         cl_device_local_mem_type <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8091787f68d0b4fec54982ac60ff0e58" title="Type of local memory supported. This can be set to CL_LOCAL implying dedicated local memory storage s...">local_mem_type</a>()<span class="keyword"> const</span>
<a name="l00373"></a>00373 <span class="keyword">        </span>{
<a name="l00374"></a>00374           <span class="keywordflow">if</span> (!local_mem_type_valid_)
<a name="l00375"></a>00375           {
<a name="l00376"></a>00376             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_LOCAL_MEM_TYPE, <span class="keyword">sizeof</span>(cl_device_local_mem_type), static_cast&lt;void *&gt;(&amp;local_mem_type_), NULL);
<a name="l00377"></a>00377             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00378"></a>00378             local_mem_type_valid_ = <span class="keyword">true</span>;
<a name="l00379"></a>00379           }
<a name="l00380"></a>00380           <span class="keywordflow">return</span> local_mem_type_;
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382 
<a name="l00384"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ab3f87b373439a4d280102b3323a3646c">00384</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#ab3f87b373439a4d280102b3323a3646c" title="Maximum configured clock frequency of the device in MHz.">max_clock_frequency</a>()<span class="keyword"> const</span>
<a name="l00385"></a>00385 <span class="keyword">        </span>{
<a name="l00386"></a>00386           <span class="keywordflow">if</span> (!max_clock_frequency_valid_)
<a name="l00387"></a>00387           {
<a name="l00388"></a>00388             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_CLOCK_FREQUENCY, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_clock_frequency_), NULL);
<a name="l00389"></a>00389             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00390"></a>00390             max_clock_frequency_valid_ = <span class="keyword">true</span>;
<a name="l00391"></a>00391           }
<a name="l00392"></a>00392           <span class="keywordflow">return</span> max_clock_frequency_;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394 
<a name="l00396"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ab2a44bd7f2d691fa15460928af757d99">00396</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#ab2a44bd7f2d691fa15460928af757d99" title="The number of parallel compute cores on the OpenCL device. The minimum value is 1.">max_compute_units</a>()<span class="keyword"> const</span>
<a name="l00397"></a>00397 <span class="keyword">        </span>{
<a name="l00398"></a>00398           <span class="keywordflow">if</span> (!max_compute_units_valid_)
<a name="l00399"></a>00399           {
<a name="l00400"></a>00400             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_COMPUTE_UNITS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_compute_units_), NULL);
<a name="l00401"></a>00401             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00402"></a>00402             max_compute_units_valid_ = <span class="keyword">true</span>;
<a name="l00403"></a>00403           }
<a name="l00404"></a>00404           <span class="keywordflow">return</span> max_compute_units_;
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406 
<a name="l00408"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a692f1cbba0e5ec45a36546e7d3566b17">00408</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a692f1cbba0e5ec45a36546e7d3566b17" title="Max number of arguments declared with the __constant qualifier in a kernel. The minimum value is 8...">max_constant_args</a>()<span class="keyword"> const</span>
<a name="l00409"></a>00409 <span class="keyword">        </span>{
<a name="l00410"></a>00410           <span class="keywordflow">if</span> (!max_constant_args_valid_)
<a name="l00411"></a>00411           {
<a name="l00412"></a>00412             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_CONSTANT_ARGS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_constant_args_), NULL);
<a name="l00413"></a>00413             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00414"></a>00414             max_constant_args_valid_ = <span class="keyword">true</span>;
<a name="l00415"></a>00415           }
<a name="l00416"></a>00416           <span class="keywordflow">return</span> max_constant_args_;
<a name="l00417"></a>00417         }
<a name="l00418"></a>00418 
<a name="l00420"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#aa2d0aa7e89b3bd75bf363f427bb8cf05">00420</a>         cl_ulong <a class="code" href="classviennacl_1_1ocl_1_1device.html#aa2d0aa7e89b3bd75bf363f427bb8cf05" title="Max size in bytes of a constant buffer allocation. The minimum value is 64 KB.">max_constant_buffer_size</a>()<span class="keyword"> const</span>
<a name="l00421"></a>00421 <span class="keyword">        </span>{
<a name="l00422"></a>00422           <span class="keywordflow">if</span> (!max_constant_buffer_size_valid_)
<a name="l00423"></a>00423           {
<a name="l00424"></a>00424             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, <span class="keyword">sizeof</span>(cl_ulong), static_cast&lt;void *&gt;(&amp;max_constant_buffer_size_), NULL);
<a name="l00425"></a>00425             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00426"></a>00426             max_constant_buffer_size_valid_ = <span class="keyword">true</span>;
<a name="l00427"></a>00427           }
<a name="l00428"></a>00428           <span class="keywordflow">return</span> max_constant_buffer_size_;
<a name="l00429"></a>00429         }
<a name="l00430"></a>00430 
<a name="l00432"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a76e80ea0f77a23879abaf577db0f28bd">00432</a>         cl_ulong <a class="code" href="classviennacl_1_1ocl_1_1device.html#a76e80ea0f77a23879abaf577db0f28bd" title="Max size of memory object allocation in bytes. The minimum value is max(1/4th of CL_DEVICE_GLOBAL_MEM...">max_mem_alloc_size</a>()<span class="keyword"> const</span>
<a name="l00433"></a>00433 <span class="keyword">        </span>{
<a name="l00434"></a>00434           <span class="keywordflow">if</span> (!max_mem_alloc_size_valid_)
<a name="l00435"></a>00435           {
<a name="l00436"></a>00436             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_MEM_ALLOC_SIZE, <span class="keyword">sizeof</span>(cl_ulong), static_cast&lt;void *&gt;(&amp;max_mem_alloc_size_), NULL);
<a name="l00437"></a>00437             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00438"></a>00438             max_mem_alloc_size_valid_ = <span class="keyword">true</span>;
<a name="l00439"></a>00439           }
<a name="l00440"></a>00440           <span class="keywordflow">return</span> max_mem_alloc_size_;
<a name="l00441"></a>00441         }
<a name="l00442"></a>00442 
<a name="l00447"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a1ec4f9908f272af3158d54ef5368ff3b">00447</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1ec4f9908f272af3158d54ef5368ff3b" title="Max size in bytes of the arguments that can be passed to a kernel. The minimum value is 1024...">max_parameter_size</a>()<span class="keyword"> const</span>
<a name="l00448"></a>00448 <span class="keyword">        </span>{
<a name="l00449"></a>00449           <span class="keywordflow">if</span> (!max_parameter_size_valid_)
<a name="l00450"></a>00450           {
<a name="l00451"></a>00451             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_PARAMETER_SIZE, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;max_parameter_size_), NULL);
<a name="l00452"></a>00452             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00453"></a>00453             max_parameter_size_valid_ = <span class="keyword">true</span>;
<a name="l00454"></a>00454           }
<a name="l00455"></a>00455           <span class="keywordflow">return</span> max_parameter_size_;
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457 
<a name="l00459"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad49d0c2c2041cedf8a0e3f63e0b729b8">00459</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad49d0c2c2041cedf8a0e3f63e0b729b8" title="Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL...">max_read_image_args</a>()<span class="keyword"> const</span>
<a name="l00460"></a>00460 <span class="keyword">        </span>{
<a name="l00461"></a>00461           <span class="keywordflow">if</span> (!max_read_image_args_valid_)
<a name="l00462"></a>00462           {
<a name="l00463"></a>00463             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_READ_IMAGE_ARGS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_read_image_args_), NULL);
<a name="l00464"></a>00464             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00465"></a>00465             max_read_image_args_valid_ = <span class="keyword">true</span>;
<a name="l00466"></a>00466           }
<a name="l00467"></a>00467           <span class="keywordflow">return</span> max_read_image_args_;
<a name="l00468"></a>00468         }
<a name="l00469"></a>00469 
<a name="l00471"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#abab1724b923609c7f0aa17b0d59e5e81">00471</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#abab1724b923609c7f0aa17b0d59e5e81" title="Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL...">max_samplers</a>()<span class="keyword"> const</span>
<a name="l00472"></a>00472 <span class="keyword">        </span>{
<a name="l00473"></a>00473           <span class="keywordflow">if</span> (!max_samplers_valid_)
<a name="l00474"></a>00474           {
<a name="l00475"></a>00475             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_SAMPLERS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_samplers_), NULL);
<a name="l00476"></a>00476             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00477"></a>00477             max_samplers_valid_ = <span class="keyword">true</span>;
<a name="l00478"></a>00478           }
<a name="l00479"></a>00479           <span class="keywordflow">return</span> max_samplers_;
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481 
<a name="l00483"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a49dafae1d5a718f0825eefd245b14683">00483</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a49dafae1d5a718f0825eefd245b14683" title="Maximum number of work-items in a work-group executing a kernel using the data parallel execution mod...">max_work_group_size</a>()<span class="keyword"> const</span>
<a name="l00484"></a>00484 <span class="keyword">        </span>{
<a name="l00485"></a>00485           <span class="keywordflow">if</span> (!max_work_group_size_valid_)
<a name="l00486"></a>00486           {
<a name="l00487"></a>00487             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_WORK_GROUP_SIZE, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;max_work_group_size_), NULL);
<a name="l00488"></a>00488             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00489"></a>00489             max_work_group_size_valid_ = <span class="keyword">true</span>;
<a name="l00490"></a>00490           }
<a name="l00491"></a>00491           <span class="keywordflow">return</span> max_work_group_size_;
<a name="l00492"></a>00492         }
<a name="l00493"></a>00493 
<a name="l00495"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a9a996b0b90a0ce4abebfe13d68634ca1">00495</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a9a996b0b90a0ce4abebfe13d68634ca1" title="Maximum dimensions that specify the global and local work-item IDs used by the data parallel executio...">max_work_item_dimensions</a>()<span class="keyword"> const</span>
<a name="l00496"></a>00496 <span class="keyword">        </span>{
<a name="l00497"></a>00497           <span class="keywordflow">if</span> (!max_work_item_dimensions_valid_)
<a name="l00498"></a>00498           {
<a name="l00499"></a>00499             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_work_item_dimensions_), NULL);
<a name="l00500"></a>00500             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00501"></a>00501             max_work_item_dimensions_valid_ = <span class="keyword">true</span>;
<a name="l00502"></a>00502           }
<a name="l00503"></a>00503           <span class="keywordflow">return</span> max_work_item_dimensions_;
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505 
<a name="l00510"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a1b3b4141030035fe9f4898495f22e11e">00510</a>         std::vector&lt;size_t&gt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1b3b4141030035fe9f4898495f22e11e" title="Maximum number of work-items that can be specified in each dimension of the work-group.">max_work_item_sizes</a>()<span class="keyword"> const</span>
<a name="l00511"></a>00511 <span class="keyword">        </span>{
<a name="l00512"></a>00512           std::vector&lt;size_t&gt; result(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a9a996b0b90a0ce4abebfe13d68634ca1" title="Maximum dimensions that specify the global and local work-item IDs used by the data parallel executio...">max_work_item_dimensions</a>());
<a name="l00513"></a>00513 
<a name="l00514"></a>00514           assert(result.size() &lt; 16 &amp;&amp; bool(<span class="stringliteral">&quot;Supported work item dimensions exceed available capacity!&quot;</span>));
<a name="l00515"></a>00515 
<a name="l00516"></a>00516           <span class="keywordflow">if</span> (!max_work_item_sizes_valid_)
<a name="l00517"></a>00517           {
<a name="l00518"></a>00518             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_WORK_ITEM_SIZES, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>) * 16, static_cast&lt;void *&gt;(&amp;max_work_item_sizes_), NULL);
<a name="l00519"></a>00519             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00520"></a>00520             max_work_item_sizes_valid_ = <span class="keyword">true</span>;
<a name="l00521"></a>00521           }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523           <span class="keywordflow">for</span> (<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> i=0; i&lt;result.size(); ++i)
<a name="l00524"></a>00524             result[i] = max_work_item_sizes_[i];
<a name="l00525"></a>00525 
<a name="l00526"></a>00526           <span class="keywordflow">return</span> result;
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528 
<a name="l00530"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad373bfe54f24f176f898af2e02c4f6a1">00530</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad373bfe54f24f176f898af2e02c4f6a1" title="Max number of simultaneous image objects that can be written to by a kernel. The minimum value is 8 i...">max_write_image_args</a>()<span class="keyword"> const</span>
<a name="l00531"></a>00531 <span class="keyword">        </span>{
<a name="l00532"></a>00532           <span class="keywordflow">if</span> (!max_write_image_args_valid_)
<a name="l00533"></a>00533           {
<a name="l00534"></a>00534             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MAX_WRITE_IMAGE_ARGS, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;max_write_image_args_), NULL);
<a name="l00535"></a>00535             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00536"></a>00536             max_write_image_args_valid_ = <span class="keyword">true</span>;
<a name="l00537"></a>00537           }
<a name="l00538"></a>00538           <span class="keywordflow">return</span> max_write_image_args_;
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540 
<a name="l00542"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#af06975359d57fe421bfe1b57b0073956">00542</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#af06975359d57fe421bfe1b57b0073956" title="Describes the alignment in bits of the base address of any allocated memory object.">mem_base_addr_align</a>()<span class="keyword"> const</span>
<a name="l00543"></a>00543 <span class="keyword">        </span>{
<a name="l00544"></a>00544           <span class="keywordflow">if</span> (!mem_base_addr_align_valid_)
<a name="l00545"></a>00545           {
<a name="l00546"></a>00546             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MEM_BASE_ADDR_ALIGN, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;mem_base_addr_align_), NULL);
<a name="l00547"></a>00547             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00548"></a>00548             mem_base_addr_align_valid_ = <span class="keyword">true</span>;
<a name="l00549"></a>00549           }
<a name="l00550"></a>00550           <span class="keywordflow">return</span> mem_base_addr_align_;
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552 
<a name="l00554"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a11526ca6bb6e66405ec0e51dafe167dd">00554</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a11526ca6bb6e66405ec0e51dafe167dd" title="The smallest alignment in bytes which can be used for any data type.">min_data_type_align_size</a>()<span class="keyword"> const</span>
<a name="l00555"></a>00555 <span class="keyword">        </span>{
<a name="l00556"></a>00556           <span class="keywordflow">if</span> (!min_data_type_align_size_valid_)
<a name="l00557"></a>00557           {
<a name="l00558"></a>00558             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;min_data_type_align_size_), NULL);
<a name="l00559"></a>00559             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00560"></a>00560             min_data_type_align_size_valid_ = <span class="keyword">true</span>;
<a name="l00561"></a>00561           }
<a name="l00562"></a>00562           <span class="keywordflow">return</span> min_data_type_align_size_;
<a name="l00563"></a>00563         }
<a name="l00564"></a>00564 
<a name="l00566"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07">00566</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07" title="Device name string.">name</a>()<span class="keyword"> const</span>
<a name="l00567"></a>00567 <span class="keyword">        </span>{
<a name="l00568"></a>00568           <span class="keywordflow">if</span> (!name_valid_)
<a name="l00569"></a>00569           {
<a name="l00570"></a>00570             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NAME, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 256, static_cast&lt;void *&gt;(name_), NULL);
<a name="l00571"></a>00571             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00572"></a>00572             name_valid_ = <span class="keyword">true</span>;
<a name="l00573"></a>00573           }
<a name="l00574"></a>00574           <span class="keywordflow">return</span> name_;
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576 
<a name="l00578"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#afe5ac2e026232fe02cbcf50bcf453d5c">00578</a>         <a class="code" href="namespaceviennacl_1_1ocl.html#adb83837b11c9bec5603b76a0012e24e8">device_architecture_family</a> <a class="code" href="classviennacl_1_1ocl_1_1device.html#afe5ac2e026232fe02cbcf50bcf453d5c" title="Device architecture family.">architecture_family</a>()<span class="keyword"> const</span>
<a name="l00579"></a>00579 <span class="keyword">        </span>{
<a name="l00580"></a>00580           <span class="keywordflow">if</span>( !architecture_family_valid_)
<a name="l00581"></a>00581           {
<a name="l00582"></a>00582             architecture_family_ = get_device_architecture(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a1575318b34ec417067780eb43514f37d" title="A unique device vendor identifier. An example of a unique device identifier could be the PCIe ID...">vendor_id</a>(), <a class="code" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07" title="Device name string.">name</a>());
<a name="l00583"></a>00583             architecture_family_valid_ = <span class="keyword">true</span>;
<a name="l00584"></a>00584           }
<a name="l00585"></a>00585           <span class="keywordflow">return</span> architecture_family_;
<a name="l00586"></a>00586         }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR</span>
<a name="l00589"></a>00589 <span class="preprocessor"></span>
<a name="l00590"></a>00590         cl_uint native_vector_width_char()<span class="keyword"> const</span>
<a name="l00591"></a>00591 <span class="keyword">        </span>{
<a name="l00592"></a>00592           <span class="keywordflow">if</span> (!native_vector_width_char_valid_)
<a name="l00593"></a>00593           {
<a name="l00594"></a>00594             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_char_), NULL);
<a name="l00595"></a>00595             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00596"></a>00596             native_vector_width_char_valid_ = <span class="keyword">true</span>;
<a name="l00597"></a>00597           }
<a name="l00598"></a>00598           <span class="keywordflow">return</span> native_vector_width_char_;
<a name="l00599"></a>00599         }
<a name="l00600"></a>00600 <span class="preprocessor">#endif</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span>
<a name="l00602"></a>00602 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT</span>
<a name="l00603"></a>00603 <span class="preprocessor"></span>
<a name="l00604"></a>00604         cl_uint native_vector_width_short()<span class="keyword"> const</span>
<a name="l00605"></a>00605 <span class="keyword">        </span>{
<a name="l00606"></a>00606           <span class="keywordflow">if</span> (!native_vector_width_short_valid_)
<a name="l00607"></a>00607           {
<a name="l00608"></a>00608             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_short_), NULL);
<a name="l00609"></a>00609             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00610"></a>00610             native_vector_width_short_valid_ = <span class="keyword">true</span>;
<a name="l00611"></a>00611           }
<a name="l00612"></a>00612           <span class="keywordflow">return</span> native_vector_width_short_;
<a name="l00613"></a>00613         }
<a name="l00614"></a>00614 <span class="preprocessor">#endif</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span>
<a name="l00616"></a>00616 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_INT</span>
<a name="l00617"></a>00617 <span class="preprocessor"></span>
<a name="l00618"></a>00618         cl_uint native_vector_width_int()<span class="keyword"> const</span>
<a name="l00619"></a>00619 <span class="keyword">        </span>{
<a name="l00620"></a>00620           <span class="keywordflow">if</span> (!native_vector_width_int_valid_)
<a name="l00621"></a>00621           {
<a name="l00622"></a>00622             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_int_), NULL);
<a name="l00623"></a>00623             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00624"></a>00624             native_vector_width_int_valid_ = <span class="keyword">true</span>;
<a name="l00625"></a>00625           }
<a name="l00626"></a>00626           <span class="keywordflow">return</span> native_vector_width_int_;
<a name="l00627"></a>00627         }
<a name="l00628"></a>00628 <span class="preprocessor">#endif</span>
<a name="l00629"></a>00629 <span class="preprocessor"></span>
<a name="l00630"></a>00630 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span>
<a name="l00632"></a>00632         cl_uint native_vector_width_long()<span class="keyword"> const</span>
<a name="l00633"></a>00633 <span class="keyword">        </span>{
<a name="l00634"></a>00634           <span class="keywordflow">if</span> (!native_vector_width_long_valid_)
<a name="l00635"></a>00635           {
<a name="l00636"></a>00636             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_long_), NULL);
<a name="l00637"></a>00637             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00638"></a>00638             native_vector_width_long_valid_ = <span class="keyword">true</span>;
<a name="l00639"></a>00639           }
<a name="l00640"></a>00640           <span class="keywordflow">return</span> native_vector_width_long_;
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642 <span class="preprocessor">#endif</span>
<a name="l00643"></a>00643 <span class="preprocessor"></span>
<a name="l00644"></a>00644 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT</span>
<a name="l00645"></a>00645 <span class="preprocessor"></span>
<a name="l00646"></a>00646         cl_uint native_vector_width_float()<span class="keyword"> const</span>
<a name="l00647"></a>00647 <span class="keyword">        </span>{
<a name="l00648"></a>00648           <span class="keywordflow">if</span> (!native_vector_width_float_valid_)
<a name="l00649"></a>00649           {
<a name="l00650"></a>00650             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_float_), NULL);
<a name="l00651"></a>00651             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00652"></a>00652             native_vector_width_float_valid_ = <span class="keyword">true</span>;
<a name="l00653"></a>00653           }
<a name="l00654"></a>00654           <span class="keywordflow">return</span> native_vector_width_float_;
<a name="l00655"></a>00655         }
<a name="l00656"></a>00656 <span class="preprocessor">#endif</span>
<a name="l00657"></a>00657 <span class="preprocessor"></span>
<a name="l00658"></a>00658 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span>
<a name="l00663"></a>00663         cl_uint native_vector_width_double()<span class="keyword"> const</span>
<a name="l00664"></a>00664 <span class="keyword">        </span>{
<a name="l00665"></a>00665           <span class="keywordflow">if</span> (!native_vector_width_double_valid_)
<a name="l00666"></a>00666           {
<a name="l00667"></a>00667             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_double_), NULL);
<a name="l00668"></a>00668             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00669"></a>00669             native_vector_width_double_valid_ = <span class="keyword">true</span>;
<a name="l00670"></a>00670           }
<a name="l00671"></a>00671           <span class="keywordflow">return</span> native_vector_width_double_;
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673 <span class="preprocessor">#endif</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>
<a name="l00675"></a>00675 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF</span>
<a name="l00676"></a>00676 <span class="preprocessor"></span>
<a name="l00680"></a>00680         cl_uint native_vector_width_half()<span class="keyword"> const</span>
<a name="l00681"></a>00681 <span class="keyword">        </span>{
<a name="l00682"></a>00682           <span class="keywordflow">if</span> (!native_vector_width_half_valid_)
<a name="l00683"></a>00683           {
<a name="l00684"></a>00684             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;native_vector_width_half_), NULL);
<a name="l00685"></a>00685             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00686"></a>00686             native_vector_width_half_valid_ = <span class="keyword">true</span>;
<a name="l00687"></a>00687           }
<a name="l00688"></a>00688           <span class="keywordflow">return</span> native_vector_width_half_;
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690 <span class="preprocessor">#endif</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span>
<a name="l00692"></a>00692 <span class="preprocessor">#if CL_DEVICE_OPENCL_C_VERSION</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>
<a name="l00701"></a>00701         std::string opencl_c_version()<span class="keyword"> const</span>
<a name="l00702"></a>00702 <span class="keyword">        </span>{
<a name="l00703"></a>00703           <span class="keywordflow">if</span> (!opencl_c_version_valid_)
<a name="l00704"></a>00704           {
<a name="l00705"></a>00705             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_OPENCL_C_VERSION, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 128, static_cast&lt;void *&gt;(opencl_c_version_), NULL);
<a name="l00706"></a>00706             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00707"></a>00707             opencl_c_version_valid_ = <span class="keyword">true</span>;
<a name="l00708"></a>00708           }
<a name="l00709"></a>00709           <span class="keywordflow">return</span> opencl_c_version_;
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711 <span class="preprocessor">#endif</span>
<a name="l00712"></a>00712 <span class="preprocessor"></span>
<a name="l00714"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#adc00f11c541e009faf21e1a93592cdbd">00714</a>         cl_platform_id <a class="code" href="classviennacl_1_1ocl_1_1device.html#adc00f11c541e009faf21e1a93592cdbd" title="The platform associated with this device.">platform</a>()<span class="keyword"> const</span>
<a name="l00715"></a>00715 <span class="keyword">        </span>{
<a name="l00716"></a>00716           <span class="keywordflow">if</span> (!platform_valid_)
<a name="l00717"></a>00717           {
<a name="l00718"></a>00718             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PLATFORM, <span class="keyword">sizeof</span>(cl_platform_id), static_cast&lt;void *&gt;(&amp;platform_), NULL);
<a name="l00719"></a>00719             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00720"></a>00720             platform_valid_ = <span class="keyword">true</span>;
<a name="l00721"></a>00721           }
<a name="l00722"></a>00722           <span class="keywordflow">return</span> platform_;
<a name="l00723"></a>00723         }
<a name="l00724"></a>00724 
<a name="l00726"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a88376a162cd1a0d5c61a5051918a7df7">00726</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a88376a162cd1a0d5c61a5051918a7df7" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_char</a>()<span class="keyword"> const</span>
<a name="l00727"></a>00727 <span class="keyword">        </span>{
<a name="l00728"></a>00728           <span class="keywordflow">if</span> (!preferred_vector_width_char_valid_)
<a name="l00729"></a>00729           {
<a name="l00730"></a>00730             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_char_), NULL);
<a name="l00731"></a>00731             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00732"></a>00732             preferred_vector_width_char_valid_ = <span class="keyword">true</span>;
<a name="l00733"></a>00733           }
<a name="l00734"></a>00734           <span class="keywordflow">return</span> preferred_vector_width_char_;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736 
<a name="l00738"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a43e57454609654363908d5d1bff67e11">00738</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a43e57454609654363908d5d1bff67e11" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_short</a>()<span class="keyword"> const</span>
<a name="l00739"></a>00739 <span class="keyword">        </span>{
<a name="l00740"></a>00740           <span class="keywordflow">if</span> (!preferred_vector_width_short_valid_)
<a name="l00741"></a>00741           {
<a name="l00742"></a>00742             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_short_), NULL);
<a name="l00743"></a>00743             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00744"></a>00744             preferred_vector_width_short_valid_ = <span class="keyword">true</span>;
<a name="l00745"></a>00745           }
<a name="l00746"></a>00746           <span class="keywordflow">return</span> preferred_vector_width_short_;
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748 
<a name="l00750"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a0d9ba534766a629f6d83242ec20d9c7d">00750</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a0d9ba534766a629f6d83242ec20d9c7d" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_int</a>()<span class="keyword"> const</span>
<a name="l00751"></a>00751 <span class="keyword">        </span>{
<a name="l00752"></a>00752           <span class="keywordflow">if</span> (!preferred_vector_width_int_valid_)
<a name="l00753"></a>00753           {
<a name="l00754"></a>00754             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_int_), NULL);
<a name="l00755"></a>00755             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00756"></a>00756             preferred_vector_width_int_valid_ = <span class="keyword">true</span>;
<a name="l00757"></a>00757           }
<a name="l00758"></a>00758           <span class="keywordflow">return</span> preferred_vector_width_int_;
<a name="l00759"></a>00759         }
<a name="l00760"></a>00760 
<a name="l00762"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a7ca95e17c171318c3fcab76bcaeccc9e">00762</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a7ca95e17c171318c3fcab76bcaeccc9e" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_long</a>()<span class="keyword"> const</span>
<a name="l00763"></a>00763 <span class="keyword">        </span>{
<a name="l00764"></a>00764           <span class="keywordflow">if</span> (!preferred_vector_width_long_valid_)
<a name="l00765"></a>00765           {
<a name="l00766"></a>00766             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_long_), NULL);
<a name="l00767"></a>00767             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00768"></a>00768             preferred_vector_width_long_valid_ = <span class="keyword">true</span>;
<a name="l00769"></a>00769           }
<a name="l00770"></a>00770           <span class="keywordflow">return</span> preferred_vector_width_long_;
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772 
<a name="l00774"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a035903cebad6b26df51ae4ee8d95d898">00774</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a035903cebad6b26df51ae4ee8d95d898" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_float</a>()<span class="keyword"> const</span>
<a name="l00775"></a>00775 <span class="keyword">        </span>{
<a name="l00776"></a>00776           <span class="keywordflow">if</span> (!preferred_vector_width_float_valid_)
<a name="l00777"></a>00777           {
<a name="l00778"></a>00778             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_float_), NULL);
<a name="l00779"></a>00779             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00780"></a>00780             preferred_vector_width_float_valid_ = <span class="keyword">true</span>;
<a name="l00781"></a>00781           }
<a name="l00782"></a>00782           <span class="keywordflow">return</span> preferred_vector_width_float_;
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784 
<a name="l00789"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a7409d792a832e9adc3d003aabe181e1c">00789</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a7409d792a832e9adc3d003aabe181e1c" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_double</a>()<span class="keyword"> const</span>
<a name="l00790"></a>00790 <span class="keyword">        </span>{
<a name="l00791"></a>00791           <span class="keywordflow">if</span> (!preferred_vector_width_double_valid_)
<a name="l00792"></a>00792           {
<a name="l00793"></a>00793             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_double_), NULL);
<a name="l00794"></a>00794             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00795"></a>00795             preferred_vector_width_double_valid_ = <span class="keyword">true</span>;
<a name="l00796"></a>00796           }
<a name="l00797"></a>00797           <span class="keywordflow">return</span> preferred_vector_width_double_;
<a name="l00798"></a>00798         }
<a name="l00799"></a>00799 
<a name="l00804"></a>00804 <span class="preprocessor">#ifdef CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>        cl_uint preferred_vector_width_half()<span class="keyword"> const</span>
<a name="l00806"></a>00806 <span class="keyword">        </span>{
<a name="l00807"></a>00807           <span class="keywordflow">if</span> (!preferred_vector_width_half_valid_)
<a name="l00808"></a>00808           {
<a name="l00809"></a>00809             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;preferred_vector_width_half_), NULL);
<a name="l00810"></a>00810             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00811"></a>00811             preferred_vector_width_half_valid_ = <span class="keyword">true</span>;
<a name="l00812"></a>00812           }
<a name="l00813"></a>00813           <span class="keywordflow">return</span> preferred_vector_width_half_;
<a name="l00814"></a>00814         }
<a name="l00815"></a>00815 <span class="preprocessor">#endif</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span>
<a name="l00823"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#abaed2e4ea123afab890a1ee3d825aaef">00823</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#abaed2e4ea123afab890a1ee3d825aaef" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">profile</a>()<span class="keyword"> const</span>
<a name="l00824"></a>00824 <span class="keyword">        </span>{
<a name="l00825"></a>00825           <span class="keywordflow">if</span> (!profile_valid_)
<a name="l00826"></a>00826           {
<a name="l00827"></a>00827             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PROFILE, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 32, static_cast&lt;void *&gt;(profile_), NULL);
<a name="l00828"></a>00828             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00829"></a>00829             profile_valid_ = <span class="keyword">true</span>;
<a name="l00830"></a>00830           }
<a name="l00831"></a>00831           <span class="keywordflow">return</span> profile_;
<a name="l00832"></a>00832         }
<a name="l00833"></a>00833 
<a name="l00835"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#afd92d6ae0f09c371d207fdacf72bb775">00835</a>         <span class="keywordtype">size_t</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#afd92d6ae0f09c371d207fdacf72bb775" title="Describes the resolution of device timer. This is measured in nanoseconds.">profiling_timer_resolution</a>()<span class="keyword"> const</span>
<a name="l00836"></a>00836 <span class="keyword">        </span>{
<a name="l00837"></a>00837           <span class="keywordflow">if</span> (!profiling_timer_resolution_valid_)
<a name="l00838"></a>00838           {
<a name="l00839"></a>00839             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_PROFILING_TIMER_RESOLUTION, <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>), static_cast&lt;void *&gt;(&amp;profiling_timer_resolution_), NULL);
<a name="l00840"></a>00840             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00841"></a>00841             profiling_timer_resolution_valid_ = <span class="keyword">true</span>;
<a name="l00842"></a>00842           }
<a name="l00843"></a>00843           <span class="keywordflow">return</span> profiling_timer_resolution_;
<a name="l00844"></a>00844         }
<a name="l00845"></a>00845 
<a name="l00854"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a632b3e9d82280ba91a1147544efad604">00854</a>         cl_command_queue_properties <a class="code" href="classviennacl_1_1ocl_1_1device.html#a632b3e9d82280ba91a1147544efad604" title="Describes the command-queue properties supported by the device.">queue_properties</a>()<span class="keyword"> const</span>
<a name="l00855"></a>00855 <span class="keyword">        </span>{
<a name="l00856"></a>00856           <span class="keywordflow">if</span> (!queue_properties_valid_)
<a name="l00857"></a>00857           {
<a name="l00858"></a>00858             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_QUEUE_PROPERTIES, <span class="keyword">sizeof</span>(cl_command_queue_properties), static_cast&lt;void *&gt;(&amp;queue_properties_), NULL);
<a name="l00859"></a>00859             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00860"></a>00860             queue_properties_valid_ = <span class="keyword">true</span>;
<a name="l00861"></a>00861           }
<a name="l00862"></a>00862           <span class="keywordflow">return</span> queue_properties_;
<a name="l00863"></a>00863         }
<a name="l00864"></a>00864 
<a name="l00878"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#adef66e00159d69c443e5dcc90d9b6772">00878</a>         cl_device_fp_config <a class="code" href="classviennacl_1_1ocl_1_1device.html#adef66e00159d69c443e5dcc90d9b6772" title="Describes single precision floating-point capability of the OpenCL device.">single_fp_config</a>()<span class="keyword"> const</span>
<a name="l00879"></a>00879 <span class="keyword">        </span>{
<a name="l00880"></a>00880           <span class="keywordflow">if</span> (!single_fp_config_valid_)
<a name="l00881"></a>00881           {
<a name="l00882"></a>00882             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_SINGLE_FP_CONFIG, <span class="keyword">sizeof</span>(cl_device_fp_config), static_cast&lt;void *&gt;(&amp;single_fp_config_), NULL);
<a name="l00883"></a>00883             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00884"></a>00884             single_fp_config_valid_ = <span class="keyword">true</span>;
<a name="l00885"></a>00885           }
<a name="l00886"></a>00886           <span class="keywordflow">return</span> single_fp_config_;
<a name="l00887"></a>00887         }
<a name="l00888"></a>00888 
<a name="l00893"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a30cb8b6361720dfb6c7ce63d1c347e41">00893</a>         cl_device_type <a class="code" href="classviennacl_1_1ocl_1_1device.html#a30cb8b6361720dfb6c7ce63d1c347e41" title="The OpenCL device type.">type</a>()<span class="keyword"> const</span>
<a name="l00894"></a>00894 <span class="keyword">        </span>{
<a name="l00895"></a>00895           <span class="keywordflow">if</span> (!type_valid_)
<a name="l00896"></a>00896           {
<a name="l00897"></a>00897             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_TYPE, <span class="keyword">sizeof</span>(cl_device_type), static_cast&lt;void *&gt;(&amp;type_), NULL);
<a name="l00898"></a>00898             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00899"></a>00899             type_valid_ = <span class="keyword">true</span>;
<a name="l00900"></a>00900           }
<a name="l00901"></a>00901           <span class="keywordflow">return</span> type_;
<a name="l00902"></a>00902         }
<a name="l00903"></a>00903 
<a name="l00905"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a5c6eb4b06ab73aea8614531b04a44d5b">00905</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a5c6eb4b06ab73aea8614531b04a44d5b" title="Vendor name string.">vendor</a>()<span class="keyword"> const</span>
<a name="l00906"></a>00906 <span class="keyword">        </span>{
<a name="l00907"></a>00907           <span class="keywordflow">if</span> (!vendor_valid_)
<a name="l00908"></a>00908           {
<a name="l00909"></a>00909             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_VENDOR, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 256, static_cast&lt;void *&gt;(vendor_), NULL);
<a name="l00910"></a>00910             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00911"></a>00911             vendor_valid_ = <span class="keyword">true</span>;
<a name="l00912"></a>00912           }
<a name="l00913"></a>00913           <span class="keywordflow">return</span> vendor_;
<a name="l00914"></a>00914         }
<a name="l00915"></a>00915 
<a name="l00917"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a1575318b34ec417067780eb43514f37d">00917</a>         cl_uint <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1575318b34ec417067780eb43514f37d" title="A unique device vendor identifier. An example of a unique device identifier could be the PCIe ID...">vendor_id</a>()<span class="keyword"> const</span>
<a name="l00918"></a>00918 <span class="keyword">        </span>{
<a name="l00919"></a>00919           <span class="keywordflow">if</span> (!vendor_id_valid_)
<a name="l00920"></a>00920           {
<a name="l00921"></a>00921             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_VENDOR_ID, <span class="keyword">sizeof</span>(cl_uint), static_cast&lt;void *&gt;(&amp;vendor_id_), NULL);
<a name="l00922"></a>00922             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00923"></a>00923             vendor_id_valid_ = <span class="keyword">true</span>;
<a name="l00924"></a>00924           }
<a name="l00925"></a>00925           <span class="keywordflow">return</span> vendor_id_;
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927 
<a name="l00929"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a74fde2dcc73016d9f02eba2a83ca5e9b">00929</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a74fde2dcc73016d9f02eba2a83ca5e9b" title="Vendor name string.">version</a>()<span class="keyword"> const</span>
<a name="l00930"></a>00930 <span class="keyword">        </span>{
<a name="l00931"></a>00931           <span class="keywordflow">if</span> (!version_valid_)
<a name="l00932"></a>00932           {
<a name="l00933"></a>00933             cl_int err = clGetDeviceInfo(device_, CL_DEVICE_VERSION, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 256, static_cast&lt;void *&gt;(version_), NULL);
<a name="l00934"></a>00934             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00935"></a>00935             version_valid_ = <span class="keyword">true</span>;
<a name="l00936"></a>00936           }
<a name="l00937"></a>00937           <span class="keywordflow">return</span> version_;
<a name="l00938"></a>00938         }
<a name="l00939"></a>00939 
<a name="l00941"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a662b75f96a75aad23ec28c7c55b64d88">00941</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a662b75f96a75aad23ec28c7c55b64d88" title="Vendor name string.">driver_version</a>()<span class="keyword"> const</span>
<a name="l00942"></a>00942 <span class="keyword">        </span>{
<a name="l00943"></a>00943           <span class="keywordflow">if</span> (!driver_version_valid_)
<a name="l00944"></a>00944           {
<a name="l00945"></a>00945             cl_int err = clGetDeviceInfo(device_, CL_DRIVER_VERSION, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * 256, static_cast&lt;void *&gt;(driver_version_), NULL);
<a name="l00946"></a>00946             <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00947"></a>00947             driver_version_valid_ = <span class="keyword">true</span>;
<a name="l00948"></a>00948           }
<a name="l00949"></a>00949           <span class="keywordflow">return</span> driver_version_;
<a name="l00950"></a>00950         }
<a name="l00951"></a>00951 
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 
<a name="l00956"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ab61c1a1216e3f4a8537c6b7bd8a36634">00956</a>         <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#ab61c1a1216e3f4a8537c6b7bd8a36634" title="ViennaCL convenience function: Returns true if the device supports double precision.">double_support</a>()<span class="keyword"> const</span>
<a name="l00957"></a>00957 <span class="keyword">        </span>{
<a name="l00958"></a>00958           std::string ext = <a class="code" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378" title="Returns a space-separated list of extension names (the extension names themselves do not contain any ...">extensions</a>();
<a name="l00959"></a>00959 
<a name="l00960"></a>00960           <span class="keywordflow">if</span> (ext.find(<span class="stringliteral">&quot;cl_khr_fp64&quot;</span>) != std::string::npos || ext.find(<span class="stringliteral">&quot;cl_amd_fp64&quot;</span>) != std::string::npos)
<a name="l00961"></a>00961             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00964"></a>00964         }
<a name="l00965"></a>00965 
<a name="l00967"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a36eb84a793487af78b6a620b418efb6a">00967</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a36eb84a793487af78b6a620b418efb6a" title="ViennaCL convenience function: Returns the device extension which enables double precision (usually c...">double_support_extension</a>()<span class="keyword"> const</span>
<a name="l00968"></a>00968 <span class="keyword">        </span>{
<a name="l00969"></a>00969           std::string ext = <a class="code" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378" title="Returns a space-separated list of extension names (the extension names themselves do not contain any ...">extensions</a>();
<a name="l00970"></a>00970 
<a name="l00971"></a>00971           <span class="keywordflow">if</span> (ext.find(<span class="stringliteral">&quot;cl_amd_fp64&quot;</span>) != std::string::npos) <span class="comment">//AMD extension</span>
<a name="l00972"></a>00972             <span class="keywordflow">return</span> <span class="stringliteral">&quot;cl_amd_fp64&quot;</span>;
<a name="l00973"></a>00973 
<a name="l00974"></a>00974           <span class="keywordflow">if</span> (ext.find(<span class="stringliteral">&quot;cl_khr_fp64&quot;</span>) != std::string::npos) <span class="comment">//Khronos-certified standard extension for double precision</span>
<a name="l00975"></a>00975             <span class="keywordflow">return</span> <span class="stringliteral">&quot;cl_khr_fp64&quot;</span>;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977           <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00978"></a>00978         }
<a name="l00979"></a>00979 
<a name="l00981"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad710a9f9e2cff5a4fe874545102c4c06">00981</a>         cl_device_id <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad710a9f9e2cff5a4fe874545102c4c06" title="Returns the OpenCL device id.">id</a>()<span class="keyword"> const</span>
<a name="l00982"></a>00982 <span class="keyword">        </span>{
<a name="l00983"></a>00983           assert(device_ != 0 &amp;&amp; <span class="keywordtype">bool</span>(<span class="stringliteral">&quot;Device ID invalid!&quot;</span>));
<a name="l00984"></a>00984           <span class="keywordflow">return</span> device_;
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986 
<a name="l00995"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a2471dfe5b4c8e8992fc08d4520aa8b43">00995</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#a2471dfe5b4c8e8992fc08d4520aa8b43" title="Returns an info string with a few properties of the device. Use full_info() to get all details...">info</a>(<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> indent = 0, <span class="keywordtype">char</span> indent_char = <span class="charliteral">&#39; &#39;</span>)<span class="keyword"> const</span>
<a name="l00996"></a>00996 <span class="keyword">        </span>{
<a name="l00997"></a>00997           std::string line_indent(indent, indent_char);
<a name="l00998"></a>00998           std::ostringstream oss;
<a name="l00999"></a>00999           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Name:                &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07" title="Device name string.">name</a>() &lt;&lt; std::endl;
<a name="l01000"></a>01000           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Vendor:              &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a5c6eb4b06ab73aea8614531b04a44d5b" title="Vendor name string.">vendor</a>() &lt;&lt; std::endl;
<a name="l01001"></a>01001           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Type:                &quot;</span> &lt;&lt; device_type_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a30cb8b6361720dfb6c7ce63d1c347e41" title="The OpenCL device type.">type</a>()) &lt;&lt; std::endl;
<a name="l01002"></a>01002           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Available:           &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f220d225a572fc920524892902aac60" title="Is CL_TRUE if the device is available and CL_FALSE if the device is not available.">available</a>() &lt;&lt; std::endl;
<a name="l01003"></a>01003           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Compute Units:   &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ab2a44bd7f2d691fa15460928af757d99" title="The number of parallel compute cores on the OpenCL device. The minimum value is 1.">max_compute_units</a>() &lt;&lt; std::endl;
<a name="l01004"></a>01004           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Work Group Size: &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a49dafae1d5a718f0825eefd245b14683" title="Maximum number of work-items in a work-group executing a kernel using the data parallel execution mod...">max_work_group_size</a>() &lt;&lt; std::endl;
<a name="l01005"></a>01005           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Global Mem Size:     &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad45acc1aefd8535b948f28cbdc11f1c9" title="Size of global memory in bytes.">global_mem_size</a>() &lt;&lt; std::endl;
<a name="l01006"></a>01006           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Local Mem Size:      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a089c660aee310ef2c01aa5171239f7de" title="Size of local memory arena in bytes. The minimum value is 32 KB.">local_mem_size</a>() &lt;&lt; std::endl;
<a name="l01007"></a>01007           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Local Mem Type:      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8091787f68d0b4fec54982ac60ff0e58" title="Type of local memory supported. This can be set to CL_LOCAL implying dedicated local memory storage s...">local_mem_type</a>() &lt;&lt; std::endl;
<a name="l01008"></a>01008 <span class="preprocessor">#ifdef CL_DEVICE_HOST_UNIFIED_MEMORY</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Host Unified Memory: &quot;</span> &lt;&lt; host_unified_memory() &lt;&lt; std::endl;
<a name="l01010"></a>01010 <span class="preprocessor">#endif</span>
<a name="l01011"></a>01011 <span class="preprocessor"></span>
<a name="l01012"></a>01012           <span class="keywordflow">return</span> oss.str();
<a name="l01013"></a>01013         }
<a name="l01014"></a>01014 
<a name="l01020"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#ad7b04f6f02a8917e0a7da57897e8815d">01020</a>         std::string <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad7b04f6f02a8917e0a7da57897e8815d" title="Returns an info string with all device properties defined in the OpenCL 1.1 standard, listed in alphabetical order. Use info() for a short overview.">full_info</a>(<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> indent = 0, <span class="keywordtype">char</span> indent_char = <span class="charliteral">&#39; &#39;</span>)<span class="keyword"> const</span>
<a name="l01021"></a>01021 <span class="keyword">        </span>{
<a name="l01022"></a>01022           std::string line_indent(indent, indent_char);
<a name="l01023"></a>01023           std::ostringstream oss;
<a name="l01024"></a>01024           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Address Bits:                  &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8309715ac80d84b3d33928d7447b5258" title="The default compute device address space size specified as an unsigned integer value in bits...">address_bits</a>() &lt;&lt; std::endl;
<a name="l01025"></a>01025           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Available:                     &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f220d225a572fc920524892902aac60" title="Is CL_TRUE if the device is available and CL_FALSE if the device is not available.">available</a>() &lt;&lt; std::endl;
<a name="l01026"></a>01026           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Compiler Available:            &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a8f365008733eabcd519578beb099b0d7" title="Is CL_FALSE if the implementation does not have a compiler available to compile the program source...">compiler_available</a>() &lt;&lt; std::endl;
<a name="l01027"></a>01027 <span class="preprocessor">#ifdef CL_DEVICE_DOUBLE_FP_CONFIG</span>
<a name="l01028"></a>01028 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Double FP Config:              &quot;</span> &lt;&lt; fp_config_to_string(double_fp_config()) &lt;&lt; std::endl;
<a name="l01029"></a>01029 <span class="preprocessor">#endif</span>
<a name="l01030"></a>01030 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Endian Little:                 &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a186dc1deea58169fb2044c13e952bf0b" title="Is CL_TRUE if the OpenCL device is a little endian device and CL_FALSE otherwise.">endian_little</a>() &lt;&lt; std::endl;
<a name="l01031"></a>01031           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Error Correction Support:      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ac11837beee79843ef898d9cf12652474" title="Is CL_TRUE if the device implements error correction for all accesses to compute device memory (globa...">error_correction_support</a>() &lt;&lt; std::endl;
<a name="l01032"></a>01032           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Execution Capabilities:        &quot;</span> &lt;&lt; exec_capabilities_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a2ce02d6139f3833916c66fdd883b6a8d" title="Describes the execution capabilities of the device.">execution_capabilities</a>()) &lt;&lt; std::endl;
<a name="l01033"></a>01033           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Extensions:                    &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a13c05d46e01b83a17a635e4873ad8378" title="Returns a space-separated list of extension names (the extension names themselves do not contain any ...">extensions</a>() &lt;&lt; std::endl;
<a name="l01034"></a>01034           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Global Mem Cache Size:         &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad1fc58e70bbf8de4ce006f2b20fe5247" title="Size of global memory cache in bytes.">global_mem_cache_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01035"></a>01035           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Global Mem Cache Type:         &quot;</span> &lt;&lt; mem_cache_type_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#ae4afa4cd9be93609dbd0bb79345368e4" title="Type of global memory cache supported. Valid values are: CL_NONE, CL_READ_ONLY_CACHE, and CL_READ_WRITE_CACHE.">global_mem_cache_type</a>()) &lt;&lt; std::endl;
<a name="l01036"></a>01036           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Global Mem Cacheline Size:     &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a6c21e467f78c1a7a37d51a303729d5a2" title="Size of global memory cache in bytes.">global_mem_cacheline_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01037"></a>01037           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Global Mem Size:               &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad45acc1aefd8535b948f28cbdc11f1c9" title="Size of global memory in bytes.">global_mem_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01038"></a>01038 <span class="preprocessor">#ifdef CL_DEVICE_HALF_FP_CONFIG</span>
<a name="l01039"></a>01039 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Half PF Config:                &quot;</span> &lt;&lt; fp_config_to_string(half_fp_config()) &lt;&lt; std::endl;
<a name="l01040"></a>01040 <span class="preprocessor">#endif</span>
<a name="l01041"></a>01041 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_HOST_UNIFIED_MEMORY</span>
<a name="l01042"></a>01042 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Host Unified Memory:           &quot;</span> &lt;&lt; host_unified_memory() &lt;&lt; std::endl;
<a name="l01043"></a>01043 <span class="preprocessor">#endif</span>
<a name="l01044"></a>01044 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Image Support:                 &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#af6a152b64e7f80a18df3aafc9303e4bd" title="Is CL_TRUE if the device and the host have a unified memory subsystem and is CL_FALSE otherwise...">image_support</a>() &lt;&lt; std::endl;
<a name="l01045"></a>01045           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Image2D Max Height:            &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a27c69153da9c199b28607cd6fe539720" title="Max height of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image2d_max_height</a>() &lt;&lt; std::endl;
<a name="l01046"></a>01046           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Image2D Max Width:             &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a891f1c8a5008296e36c5243c6b553157" title="Max width of 2D image in pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image2d_max_width</a>() &lt;&lt; std::endl;
<a name="l01047"></a>01047           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Image3D Max Depth:             &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#acd51b91e6ef23771cb6f5f5bfddac634" title="Max depth of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image3d_max_depth</a>() &lt;&lt; std::endl;
<a name="l01048"></a>01048           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Image3D Max Height:            &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1350aeecc36ebcecc7535695117f87fe" title="Max height of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image3d_max_height</a>() &lt;&lt; std::endl;
<a name="l01049"></a>01049           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Image3D Max Width:             &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad1e0b838ced23bfd058a80b64af96281" title="Max width of 3D image in pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE...">image3d_max_width</a>() &lt;&lt; std::endl;
<a name="l01050"></a>01050           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Local Mem Size:                &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a089c660aee310ef2c01aa5171239f7de" title="Size of local memory arena in bytes. The minimum value is 32 KB.">local_mem_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01051"></a>01051           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Local Mem Type:                &quot;</span> &lt;&lt; local_mem_type_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a8091787f68d0b4fec54982ac60ff0e58" title="Type of local memory supported. This can be set to CL_LOCAL implying dedicated local memory storage s...">local_mem_type</a>()) &lt;&lt; std::endl;
<a name="l01052"></a>01052           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Clock Frequency:           &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ab3f87b373439a4d280102b3323a3646c" title="Maximum configured clock frequency of the device in MHz.">max_clock_frequency</a>() &lt;&lt; <span class="stringliteral">&quot; MHz&quot;</span> &lt;&lt; std::endl;
<a name="l01053"></a>01053           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Compute Units:             &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ab2a44bd7f2d691fa15460928af757d99" title="The number of parallel compute cores on the OpenCL device. The minimum value is 1.">max_compute_units</a>() &lt;&lt; std::endl;
<a name="l01054"></a>01054           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Constant Args:             &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a692f1cbba0e5ec45a36546e7d3566b17" title="Max number of arguments declared with the __constant qualifier in a kernel. The minimum value is 8...">max_constant_args</a>() &lt;&lt; std::endl;
<a name="l01055"></a>01055           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Constant Buffer Size:      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#aa2d0aa7e89b3bd75bf363f427bb8cf05" title="Max size in bytes of a constant buffer allocation. The minimum value is 64 KB.">max_constant_buffer_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01056"></a>01056           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Mem Alloc Size:            &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a76e80ea0f77a23879abaf577db0f28bd" title="Max size of memory object allocation in bytes. The minimum value is max(1/4th of CL_DEVICE_GLOBAL_MEM...">max_mem_alloc_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01057"></a>01057           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Parameter Size:            &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1ec4f9908f272af3158d54ef5368ff3b" title="Max size in bytes of the arguments that can be passed to a kernel. The minimum value is 1024...">max_parameter_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01058"></a>01058           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Read Image Args:           &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad49d0c2c2041cedf8a0e3f63e0b729b8" title="Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL...">max_read_image_args</a>() &lt;&lt; std::endl;
<a name="l01059"></a>01059           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Samplers:                  &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#abab1724b923609c7f0aa17b0d59e5e81" title="Max number of simultaneous image objects that can be read by a kernel. The minimum value is 128 if CL...">max_samplers</a>() &lt;&lt; std::endl;
<a name="l01060"></a>01060           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Work Group Size:           &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a49dafae1d5a718f0825eefd245b14683" title="Maximum number of work-items in a work-group executing a kernel using the data parallel execution mod...">max_work_group_size</a>() &lt;&lt; std::endl;
<a name="l01061"></a>01061           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Work Item Dimensions:      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a9a996b0b90a0ce4abebfe13d68634ca1" title="Maximum dimensions that specify the global and local work-item IDs used by the data parallel executio...">max_work_item_dimensions</a>() &lt;&lt; std::endl;
<a name="l01062"></a>01062           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Work Item Sizes:           &quot;</span> &lt;&lt; convert_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a1b3b4141030035fe9f4898495f22e11e" title="Maximum number of work-items that can be specified in each dimension of the work-group.">max_work_item_sizes</a>()) &lt;&lt; std::endl;
<a name="l01063"></a>01063           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Max Write Image Args:          &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#ad373bfe54f24f176f898af2e02c4f6a1" title="Max number of simultaneous image objects that can be written to by a kernel. The minimum value is 8 i...">max_write_image_args</a>() &lt;&lt; std::endl;
<a name="l01064"></a>01064           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Mem Base Addr Align:           &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#af06975359d57fe421bfe1b57b0073956" title="Describes the alignment in bits of the base address of any allocated memory object.">mem_base_addr_align</a>() &lt;&lt; std::endl;
<a name="l01065"></a>01065           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Min Data Type Align Size:      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a11526ca6bb6e66405ec0e51dafe167dd" title="The smallest alignment in bytes which can be used for any data type.">min_data_type_align_size</a>() &lt;&lt; <span class="stringliteral">&quot; Bytes&quot;</span> &lt;&lt; std::endl;
<a name="l01066"></a>01066           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Name:                          &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a37627d5d5bba7f4a8690c71c2ab3cb07" title="Device name string.">name</a>() &lt;&lt; std::endl;
<a name="l01067"></a>01067 <span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width char:      &quot;</span> &lt;&lt; native_vector_width_char() &lt;&lt; std::endl;
<a name="l01069"></a>01069 <span class="preprocessor">#endif</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT</span>
<a name="l01071"></a>01071 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width short:     &quot;</span> &lt;&lt; native_vector_width_short() &lt;&lt; std::endl;
<a name="l01072"></a>01072 <span class="preprocessor">#endif</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_INT</span>
<a name="l01074"></a>01074 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width int:       &quot;</span> &lt;&lt; native_vector_width_int() &lt;&lt; std::endl;
<a name="l01075"></a>01075 <span class="preprocessor">#endif</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG</span>
<a name="l01077"></a>01077 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width long:      &quot;</span> &lt;&lt; native_vector_width_long() &lt;&lt; std::endl;
<a name="l01078"></a>01078 <span class="preprocessor">#endif</span>
<a name="l01079"></a>01079 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT</span>
<a name="l01080"></a>01080 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width float:     &quot;</span> &lt;&lt; native_vector_width_float() &lt;&lt; std::endl;
<a name="l01081"></a>01081 <span class="preprocessor">#endif</span>
<a name="l01082"></a>01082 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE</span>
<a name="l01083"></a>01083 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width double:    &quot;</span> &lt;&lt; native_vector_width_double() &lt;&lt; std::endl;
<a name="l01084"></a>01084 <span class="preprocessor">#endif</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF</span>
<a name="l01086"></a>01086 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Native Vector Width half:      &quot;</span> &lt;&lt; native_vector_width_half() &lt;&lt; std::endl;
<a name="l01087"></a>01087 <span class="preprocessor">#endif</span>
<a name="l01088"></a>01088 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_DEVICE_OPENCL_C_VERSION</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;OpenCL C Version:              &quot;</span> &lt;&lt; opencl_c_version() &lt;&lt; std::endl;
<a name="l01090"></a>01090 <span class="preprocessor">#endif</span>
<a name="l01091"></a>01091 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Platform:                      &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#adc00f11c541e009faf21e1a93592cdbd" title="The platform associated with this device.">platform</a>() &lt;&lt; std::endl;
<a name="l01092"></a>01092           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width char:   &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a88376a162cd1a0d5c61a5051918a7df7" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_char</a>() &lt;&lt; std::endl;
<a name="l01093"></a>01093           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width short:  &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a43e57454609654363908d5d1bff67e11" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_short</a>() &lt;&lt; std::endl;
<a name="l01094"></a>01094           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width int:    &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a0d9ba534766a629f6d83242ec20d9c7d" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_int</a>() &lt;&lt; std::endl;
<a name="l01095"></a>01095           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width long:   &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a7ca95e17c171318c3fcab76bcaeccc9e" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_long</a>() &lt;&lt; std::endl;
<a name="l01096"></a>01096           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width float:  &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a035903cebad6b26df51ae4ee8d95d898" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_float</a>() &lt;&lt; std::endl;
<a name="l01097"></a>01097           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width double: &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a7409d792a832e9adc3d003aabe181e1c" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">preferred_vector_width_double</a>() &lt;&lt; std::endl;
<a name="l01098"></a>01098 <span class="preprocessor">#ifdef CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Preferred Vector Width half:   &quot;</span> &lt;&lt; preferred_vector_width_half() &lt;&lt; std::endl;
<a name="l01100"></a>01100 <span class="preprocessor">#endif</span>
<a name="l01101"></a>01101 <span class="preprocessor"></span>          oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Profile:                       &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#abaed2e4ea123afab890a1ee3d825aaef" title="Preferred native vector width size for built-in scalar types that can be put into vectors...">profile</a>() &lt;&lt; std::endl;
<a name="l01102"></a>01102           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Profiling Timer Resolution:    &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#afd92d6ae0f09c371d207fdacf72bb775" title="Describes the resolution of device timer. This is measured in nanoseconds.">profiling_timer_resolution</a>() &lt;&lt; <span class="stringliteral">&quot; ns&quot;</span> &lt;&lt; std::endl;
<a name="l01103"></a>01103           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Queue Properties:              &quot;</span> &lt;&lt; queue_properties_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a632b3e9d82280ba91a1147544efad604" title="Describes the command-queue properties supported by the device.">queue_properties</a>()) &lt;&lt; std::endl;
<a name="l01104"></a>01104           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Single FP Config:              &quot;</span> &lt;&lt; fp_config_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#adef66e00159d69c443e5dcc90d9b6772" title="Describes single precision floating-point capability of the OpenCL device.">single_fp_config</a>()) &lt;&lt; std::endl;
<a name="l01105"></a>01105           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Type:                          &quot;</span> &lt;&lt; device_type_to_string(<a class="code" href="classviennacl_1_1ocl_1_1device.html#a30cb8b6361720dfb6c7ce63d1c347e41" title="The OpenCL device type.">type</a>()) &lt;&lt; std::endl;
<a name="l01106"></a>01106           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Vendor:                        &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a5c6eb4b06ab73aea8614531b04a44d5b" title="Vendor name string.">vendor</a>() &lt;&lt; std::endl;
<a name="l01107"></a>01107           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Vendor ID:                     &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a1575318b34ec417067780eb43514f37d" title="A unique device vendor identifier. An example of a unique device identifier could be the PCIe ID...">vendor_id</a>() &lt;&lt; std::endl;
<a name="l01108"></a>01108           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Version:                       &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a74fde2dcc73016d9f02eba2a83ca5e9b" title="Vendor name string.">version</a>() &lt;&lt; std::endl;
<a name="l01109"></a>01109           oss &lt;&lt; line_indent &lt;&lt; <span class="stringliteral">&quot;Driver Version:                &quot;</span> &lt;&lt; <a class="code" href="classviennacl_1_1ocl_1_1device.html#a662b75f96a75aad23ec28c7c55b64d88" title="Vendor name string.">driver_version</a>() &lt;&lt; std::endl;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111           <span class="keywordflow">return</span> oss.str();
<a name="l01112"></a>01112         }
<a name="l01113"></a>01113 
<a name="l01114"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a42bb548ced469dc5714f1816603a4d35">01114</a>         <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a42bb548ced469dc5714f1816603a4d35">operator==</a>(<a class="code" href="classviennacl_1_1ocl_1_1device.html" title="A class representing a compute device (e.g. a GPU)">device</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const</span>
<a name="l01115"></a>01115 <span class="keyword">        </span>{
<a name="l01116"></a>01116           <span class="keywordflow">return</span> device_ == other.device_;
<a name="l01117"></a>01117         }
<a name="l01118"></a>01118 
<a name="l01119"></a><a class="code" href="classviennacl_1_1ocl_1_1device.html#a06e1d466be32d6b0072a8a8e23b339f9">01119</a>         <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1ocl_1_1device.html#a42bb548ced469dc5714f1816603a4d35">operator==</a>(cl_device_id other)<span class="keyword"> const</span>
<a name="l01120"></a>01120 <span class="keyword">        </span>{
<a name="l01121"></a>01121           <span class="keywordflow">return</span> device_ == other;
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124       <span class="keyword">private</span>:
<a name="l01125"></a>01125 
<a name="l01127"></a>01127         std::string fp_config_to_string(cl_device_fp_config conf)<span class="keyword"> const</span>
<a name="l01128"></a>01128 <span class="keyword">        </span>{
<a name="l01129"></a>01129           std::ostringstream oss;
<a name="l01130"></a>01130           <span class="keywordflow">if</span> (conf &amp; CL_FP_DENORM)
<a name="l01131"></a>01131             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_DENORM &quot;</span>;
<a name="l01132"></a>01132           <span class="keywordflow">if</span> (conf &amp; CL_FP_INF_NAN)
<a name="l01133"></a>01133             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_INF_NAN &quot;</span>;
<a name="l01134"></a>01134           <span class="keywordflow">if</span> (conf &amp; CL_FP_ROUND_TO_NEAREST)
<a name="l01135"></a>01135             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_ROUND_TO_NEAREST &quot;</span>;
<a name="l01136"></a>01136           <span class="keywordflow">if</span> (conf &amp; CL_FP_ROUND_TO_ZERO)
<a name="l01137"></a>01137             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_ROUND_TO_ZERO &quot;</span>;
<a name="l01138"></a>01138           <span class="keywordflow">if</span> (conf &amp; CL_FP_ROUND_TO_INF)
<a name="l01139"></a>01139             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_ROUND_TO_INF &quot;</span>;
<a name="l01140"></a>01140           <span class="keywordflow">if</span> (conf &amp; CL_FP_FMA)
<a name="l01141"></a>01141             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_FMA &quot;</span>;
<a name="l01142"></a>01142 <span class="preprocessor">#ifdef CL_FP_SOFT_FLOAT</span>
<a name="l01143"></a>01143 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (conf &amp; CL_FP_SOFT_FLOAT)
<a name="l01144"></a>01144             oss &lt;&lt; <span class="stringliteral">&quot;CL_FP_SOFT_FLOAT &quot;</span>;
<a name="l01145"></a>01145 <span class="preprocessor">#endif</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span>
<a name="l01147"></a>01147           <span class="keywordflow">return</span> oss.str();
<a name="l01148"></a>01148         }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150         std::string exec_capabilities_to_string(cl_device_exec_capabilities cap)<span class="keyword"> const</span>
<a name="l01151"></a>01151 <span class="keyword">        </span>{
<a name="l01152"></a>01152           std::ostringstream oss;
<a name="l01153"></a>01153           <span class="keywordflow">if</span> (cap &amp; CL_EXEC_KERNEL)
<a name="l01154"></a>01154             oss &lt;&lt; <span class="stringliteral">&quot;CL_EXEC_KERNEL &quot;</span>;
<a name="l01155"></a>01155           <span class="keywordflow">if</span> (cap &amp; CL_EXEC_NATIVE_KERNEL)
<a name="l01156"></a>01156             oss &lt;&lt; <span class="stringliteral">&quot;CL_EXEC_NATIVE_KERNEL &quot;</span>;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158           <span class="keywordflow">return</span> oss.str();
<a name="l01159"></a>01159         }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         std::string mem_cache_type_to_string(cl_device_mem_cache_type cachetype)<span class="keyword"> const</span>
<a name="l01162"></a>01162 <span class="keyword">        </span>{
<a name="l01163"></a>01163           std::ostringstream oss;
<a name="l01164"></a>01164           <span class="keywordflow">if</span> (cachetype == CL_NONE)
<a name="l01165"></a>01165             oss &lt;&lt; <span class="stringliteral">&quot;CL_NONE &quot;</span>;
<a name="l01166"></a>01166           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cachetype == CL_READ_ONLY_CACHE)
<a name="l01167"></a>01167             oss &lt;&lt; <span class="stringliteral">&quot;CL_READ_ONLY_CACHE &quot;</span>;
<a name="l01168"></a>01168           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cachetype == CL_READ_WRITE_CACHE)
<a name="l01169"></a>01169             oss &lt;&lt; <span class="stringliteral">&quot;CL_READ_WRITE_CACHE &quot;</span>;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171           <span class="keywordflow">return</span> oss.str();
<a name="l01172"></a>01172         }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         std::string local_mem_type_to_string(cl_device_local_mem_type loc_mem_type)<span class="keyword"> const</span>
<a name="l01175"></a>01175 <span class="keyword">        </span>{
<a name="l01176"></a>01176           std::ostringstream oss;
<a name="l01177"></a>01177           <span class="keywordflow">if</span> (loc_mem_type &amp; CL_LOCAL)
<a name="l01178"></a>01178             oss &lt;&lt; <span class="stringliteral">&quot;CL_LOCAL &quot;</span>;
<a name="l01179"></a>01179           <span class="keywordflow">if</span> (loc_mem_type &amp; CL_GLOBAL)
<a name="l01180"></a>01180             oss &lt;&lt; <span class="stringliteral">&quot;CL_GLOBAL &quot;</span>;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182           <span class="keywordflow">return</span> oss.str();
<a name="l01183"></a>01183         }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         std::string convert_to_string(std::vector&lt;size_t&gt; <span class="keyword">const</span> &amp; vec)<span class="keyword"> const</span>
<a name="l01186"></a>01186 <span class="keyword">        </span>{
<a name="l01187"></a>01187           std::ostringstream oss;
<a name="l01188"></a>01188           <span class="keywordflow">for</span> (<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> i=0; i&lt;vec.size(); ++i)
<a name="l01189"></a>01189             oss &lt;&lt; vec[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191           <span class="keywordflow">return</span> oss.str();
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         std::string queue_properties_to_string(cl_command_queue_properties queue_prop)<span class="keyword"> const</span>
<a name="l01195"></a>01195 <span class="keyword">        </span>{
<a name="l01196"></a>01196           std::ostringstream oss;
<a name="l01197"></a>01197           <span class="keywordflow">if</span> (queue_prop &amp; CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE)
<a name="l01198"></a>01198             oss &lt;&lt; <span class="stringliteral">&quot;CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE &quot;</span>;
<a name="l01199"></a>01199           <span class="keywordflow">if</span> (queue_prop &amp; CL_QUEUE_PROFILING_ENABLE)
<a name="l01200"></a>01200             oss &lt;&lt; <span class="stringliteral">&quot;CL_QUEUE_PROFILING_ENABLE &quot;</span>;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202           <span class="keywordflow">return</span> oss.str();
<a name="l01203"></a>01203         }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205         std::string device_type_to_string(cl_device_type dev_type)<span class="keyword"> const</span>
<a name="l01206"></a>01206 <span class="keyword">        </span>{
<a name="l01207"></a>01207           std::ostringstream oss;
<a name="l01208"></a>01208           <span class="keywordflow">if</span> (dev_type &amp; CL_DEVICE_TYPE_GPU)
<a name="l01209"></a>01209             oss &lt;&lt; <span class="stringliteral">&quot;GPU &quot;</span>;
<a name="l01210"></a>01210           <span class="keywordflow">if</span> (dev_type &amp; CL_DEVICE_TYPE_CPU)
<a name="l01211"></a>01211             oss &lt;&lt; <span class="stringliteral">&quot;CPU &quot;</span>;
<a name="l01212"></a>01212           <span class="keywordflow">if</span> (dev_type &amp; CL_DEVICE_TYPE_ACCELERATOR)
<a name="l01213"></a>01213             oss &lt;&lt; <span class="stringliteral">&quot;Accelerator &quot;</span>;
<a name="l01214"></a>01214           <span class="keywordflow">if</span> (dev_type &amp; CL_DEVICE_TYPE_DEFAULT)
<a name="l01215"></a>01215             oss &lt;&lt; <span class="stringliteral">&quot;(default)&quot;</span>;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217           <span class="keywordflow">return</span> oss.str();
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         <span class="keywordtype">void</span> flush_cache()
<a name="l01221"></a>01221         {
<a name="l01222"></a>01222           address_bits_valid_       = <span class="keyword">false</span>;
<a name="l01223"></a>01223           architecture_family_valid_ = <span class="keyword">false</span>;
<a name="l01224"></a>01224           available_valid_          = <span class="keyword">false</span>;
<a name="l01225"></a>01225           compiler_available_valid_ = <span class="keyword">false</span>;
<a name="l01226"></a>01226 <span class="preprocessor">#ifdef CL_DEVICE_DOUBLE_FP_CONFIG</span>
<a name="l01227"></a>01227 <span class="preprocessor"></span>          double_fp_config_valid_   = <span class="keyword">false</span>;
<a name="l01228"></a>01228 <span class="preprocessor">#endif</span>
<a name="l01229"></a>01229 <span class="preprocessor"></span>          endian_little_valid_      = <span class="keyword">false</span>;
<a name="l01230"></a>01230           error_correction_support_valid_  = <span class="keyword">false</span>;
<a name="l01231"></a>01231           execution_capabilities_valid_    = <span class="keyword">false</span>;
<a name="l01232"></a>01232           extensions_valid_                = <span class="keyword">false</span>;
<a name="l01233"></a>01233           global_mem_cache_size_valid_     = <span class="keyword">false</span>;
<a name="l01234"></a>01234           global_mem_cache_type_valid_     = <span class="keyword">false</span>;
<a name="l01235"></a>01235           global_mem_cacheline_size_valid_ = <span class="keyword">false</span>;
<a name="l01236"></a>01236           global_mem_size_valid_           = <span class="keyword">false</span>;
<a name="l01237"></a>01237 <span class="preprocessor">#ifdef CL_DEVICE_HALF_FP_CONFIG</span>
<a name="l01238"></a>01238 <span class="preprocessor"></span>          half_fp_config_valid_      = <span class="keyword">false</span>;
<a name="l01239"></a>01239 <span class="preprocessor">#endif</span>
<a name="l01240"></a>01240 <span class="preprocessor"></span>          host_unified_memory_valid_ = <span class="keyword">false</span>;
<a name="l01241"></a>01241           image_support_valid_       = <span class="keyword">false</span>;
<a name="l01242"></a>01242           image2d_max_height_valid_  = <span class="keyword">false</span>;
<a name="l01243"></a>01243           image2d_max_width_valid_   = <span class="keyword">false</span>;
<a name="l01244"></a>01244           image3d_max_depth_valid_   = <span class="keyword">false</span>;
<a name="l01245"></a>01245           image3d_max_height_valid_  = <span class="keyword">false</span>;
<a name="l01246"></a>01246           image3d_max_width_valid_   = <span class="keyword">false</span>;
<a name="l01247"></a>01247           local_mem_size_valid_      = <span class="keyword">false</span>;
<a name="l01248"></a>01248           local_mem_type_valid_      = <span class="keyword">false</span>;
<a name="l01249"></a>01249           max_clock_frequency_valid_ = <span class="keyword">false</span>;
<a name="l01250"></a>01250           max_compute_units_valid_   = <span class="keyword">false</span>;
<a name="l01251"></a>01251           max_constant_args_valid_   = <span class="keyword">false</span>;
<a name="l01252"></a>01252           max_constant_buffer_size_valid_ = <span class="keyword">false</span>;
<a name="l01253"></a>01253           max_mem_alloc_size_valid_  = <span class="keyword">false</span>;
<a name="l01254"></a>01254           max_parameter_size_valid_  = <span class="keyword">false</span>;
<a name="l01255"></a>01255           max_read_image_args_valid_ = <span class="keyword">false</span>;
<a name="l01256"></a>01256           max_samplers_valid_        = <span class="keyword">false</span>;
<a name="l01257"></a>01257           max_work_group_size_valid_ = <span class="keyword">false</span>;
<a name="l01258"></a>01258           max_work_item_dimensions_valid_ = <span class="keyword">false</span>;
<a name="l01259"></a>01259           max_work_item_sizes_valid_  = <span class="keyword">false</span>;
<a name="l01260"></a>01260           max_write_image_args_valid_ = <span class="keyword">false</span>;
<a name="l01261"></a>01261           mem_base_addr_align_valid_  = <span class="keyword">false</span>;
<a name="l01262"></a>01262           min_data_type_align_size_valid_ = <span class="keyword">false</span>;
<a name="l01263"></a>01263           name_valid_ = <span class="keyword">false</span>;
<a name="l01264"></a>01264           native_vector_width_char_valid_   = <span class="keyword">false</span>;
<a name="l01265"></a>01265           native_vector_width_short_valid_  = <span class="keyword">false</span>;
<a name="l01266"></a>01266           native_vector_width_int_valid_    = <span class="keyword">false</span>;
<a name="l01267"></a>01267           native_vector_width_long_valid_   = <span class="keyword">false</span>;
<a name="l01268"></a>01268           native_vector_width_float_valid_  = <span class="keyword">false</span>;
<a name="l01269"></a>01269           native_vector_width_double_valid_ = <span class="keyword">false</span>;
<a name="l01270"></a>01270           native_vector_width_half_valid_   = <span class="keyword">false</span>;
<a name="l01271"></a>01271           opencl_c_version_valid_ = <span class="keyword">false</span>;
<a name="l01272"></a>01272           platform_valid_ = <span class="keyword">false</span>;
<a name="l01273"></a>01273           preferred_vector_width_char_valid_   = <span class="keyword">false</span>;
<a name="l01274"></a>01274           preferred_vector_width_short_valid_  = <span class="keyword">false</span>;
<a name="l01275"></a>01275           preferred_vector_width_int_valid_    = <span class="keyword">false</span>;
<a name="l01276"></a>01276           preferred_vector_width_long_valid_   = <span class="keyword">false</span>;
<a name="l01277"></a>01277           preferred_vector_width_float_valid_  = <span class="keyword">false</span>;
<a name="l01278"></a>01278           preferred_vector_width_double_valid_ = <span class="keyword">false</span>;
<a name="l01279"></a>01279           preferred_vector_width_half_valid_   = <span class="keyword">false</span>;
<a name="l01280"></a>01280           profile_valid_ = <span class="keyword">false</span>;
<a name="l01281"></a>01281           profiling_timer_resolution_valid_ = <span class="keyword">false</span>;
<a name="l01282"></a>01282           queue_properties_valid_ = <span class="keyword">false</span>;
<a name="l01283"></a>01283           single_fp_config_valid_ = <span class="keyword">false</span>;
<a name="l01284"></a>01284           type_valid_             = <span class="keyword">false</span>;
<a name="l01285"></a>01285           vendor_valid_           = <span class="keyword">false</span>;
<a name="l01286"></a>01286           vendor_id_valid_        = <span class="keyword">false</span>;
<a name="l01287"></a>01287           version_valid_          = <span class="keyword">false</span>;
<a name="l01288"></a>01288           driver_version_valid_   = <span class="keyword">false</span>;
<a name="l01289"></a>01289         }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291         cl_device_id    device_;
<a name="l01292"></a>01292 
<a name="l01293"></a>01293         <span class="comment">//</span>
<a name="l01294"></a>01294         <span class="comment">// Device information supported by OpenCL 1.0 to follow</span>
<a name="l01295"></a>01295         <span class="comment">// cf. http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html</span>
<a name="l01296"></a>01296         <span class="comment">// Note that all members are declared &#39;mutable&#39;, as they represent a caching mechanism in order to circumvent repeated potentially expensive calls to the OpenCL SDK</span>
<a name="l01297"></a>01297         <span class="comment">//</span>
<a name="l01298"></a>01298 
<a name="l01299"></a>01299         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    address_bits_valid_;
<a name="l01300"></a>01300         <span class="keyword">mutable</span> cl_uint address_bits_;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    available_valid_;
<a name="l01303"></a>01303         <span class="keyword">mutable</span> cl_bool available_;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    compiler_available_valid_;
<a name="l01306"></a>01306         <span class="keyword">mutable</span> cl_bool compiler_available_;
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 <span class="preprocessor">#ifdef CL_DEVICE_DOUBLE_FP_CONFIG</span>
<a name="l01309"></a>01309 <span class="preprocessor"></span>        <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                double_fp_config_valid_;
<a name="l01310"></a>01310         <span class="keyword">mutable</span> cl_device_fp_config double_fp_config_;
<a name="l01311"></a>01311 <span class="preprocessor">#endif</span>
<a name="l01312"></a>01312 <span class="preprocessor"></span>
<a name="l01313"></a>01313         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    endian_little_valid_;
<a name="l01314"></a>01314         <span class="keyword">mutable</span> cl_bool endian_little_;
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    error_correction_support_valid_;
<a name="l01317"></a>01317         <span class="keyword">mutable</span> cl_bool error_correction_support_;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                        execution_capabilities_valid_;
<a name="l01320"></a>01320         <span class="keyword">mutable</span> cl_device_exec_capabilities execution_capabilities_;
<a name="l01321"></a>01321 
<a name="l01322"></a>01322         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> extensions_valid_;
<a name="l01323"></a>01323         <span class="keyword">mutable</span> <span class="keywordtype">char</span> extensions_[2048];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01324"></a>01324 
<a name="l01325"></a>01325         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>     global_mem_cache_size_valid_;
<a name="l01326"></a>01326         <span class="keyword">mutable</span> cl_ulong global_mem_cache_size_;
<a name="l01327"></a>01327 
<a name="l01328"></a>01328         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                     global_mem_cache_type_valid_;
<a name="l01329"></a>01329         <span class="keyword">mutable</span> cl_device_mem_cache_type global_mem_cache_type_;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    global_mem_cacheline_size_valid_;
<a name="l01332"></a>01332         <span class="keyword">mutable</span> cl_uint global_mem_cacheline_size_;
<a name="l01333"></a>01333 
<a name="l01334"></a>01334         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>     global_mem_size_valid_;
<a name="l01335"></a>01335         <span class="keyword">mutable</span> cl_ulong global_mem_size_;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 <span class="preprocessor">#ifdef CL_DEVICE_HALF_FP_CONFIG</span>
<a name="l01338"></a>01338 <span class="preprocessor"></span>        <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                half_fp_config_valid_;
<a name="l01339"></a>01339         <span class="keyword">mutable</span> cl_device_fp_config half_fp_config_;
<a name="l01340"></a>01340 <span class="preprocessor">#endif</span>
<a name="l01341"></a>01341 <span class="preprocessor"></span>
<a name="l01342"></a>01342         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    host_unified_memory_valid_;
<a name="l01343"></a>01343         <span class="keyword">mutable</span> cl_bool host_unified_memory_;
<a name="l01344"></a>01344 
<a name="l01345"></a>01345         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    image_support_valid_;
<a name="l01346"></a>01346         <span class="keyword">mutable</span> cl_bool image_support_;
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   image2d_max_height_valid_;
<a name="l01349"></a>01349         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> image2d_max_height_;
<a name="l01350"></a>01350 
<a name="l01351"></a>01351         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   image2d_max_width_valid_;
<a name="l01352"></a>01352         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> image2d_max_width_;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   image3d_max_depth_valid_;
<a name="l01355"></a>01355         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> image3d_max_depth_;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   image3d_max_height_valid_;
<a name="l01358"></a>01358         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> image3d_max_height_;
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   image3d_max_width_valid_;
<a name="l01361"></a>01361         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> image3d_max_width_;
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>     local_mem_size_valid_;
<a name="l01364"></a>01364         <span class="keyword">mutable</span> cl_ulong local_mem_size_;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                     local_mem_type_valid_;
<a name="l01367"></a>01367         <span class="keyword">mutable</span> cl_device_local_mem_type local_mem_type_;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_clock_frequency_valid_;
<a name="l01370"></a>01370         <span class="keyword">mutable</span> cl_uint max_clock_frequency_;
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_compute_units_valid_;
<a name="l01373"></a>01373         <span class="keyword">mutable</span> cl_uint max_compute_units_;
<a name="l01374"></a>01374 
<a name="l01375"></a>01375         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_constant_args_valid_;
<a name="l01376"></a>01376         <span class="keyword">mutable</span> cl_uint max_constant_args_;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>     max_constant_buffer_size_valid_;
<a name="l01379"></a>01379         <span class="keyword">mutable</span> cl_ulong max_constant_buffer_size_;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>     max_mem_alloc_size_valid_;
<a name="l01382"></a>01382         <span class="keyword">mutable</span> cl_ulong max_mem_alloc_size_;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   max_parameter_size_valid_;
<a name="l01385"></a>01385         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> max_parameter_size_;
<a name="l01386"></a>01386 
<a name="l01387"></a>01387         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_read_image_args_valid_;
<a name="l01388"></a>01388         <span class="keyword">mutable</span> cl_uint max_read_image_args_;
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_samplers_valid_;
<a name="l01391"></a>01391         <span class="keyword">mutable</span> cl_uint max_samplers_;
<a name="l01392"></a>01392 
<a name="l01393"></a>01393         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   max_work_group_size_valid_;
<a name="l01394"></a>01394         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> max_work_group_size_;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_work_item_dimensions_valid_;
<a name="l01397"></a>01397         <span class="keyword">mutable</span> cl_uint max_work_item_dimensions_;
<a name="l01398"></a>01398 
<a name="l01399"></a>01399         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   max_work_item_sizes_valid_;
<a name="l01400"></a>01400         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> max_work_item_sizes_[16];   <span class="comment">//we do not support execution models with more than 16 dimensions. This should totally suffice in practice, though.</span>
<a name="l01401"></a>01401 
<a name="l01402"></a>01402         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    max_write_image_args_valid_;
<a name="l01403"></a>01403         <span class="keyword">mutable</span> cl_uint max_write_image_args_;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    mem_base_addr_align_valid_;
<a name="l01406"></a>01406         <span class="keyword">mutable</span> cl_uint mem_base_addr_align_;
<a name="l01407"></a>01407 
<a name="l01408"></a>01408         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    min_data_type_align_size_valid_;
<a name="l01409"></a>01409         <span class="keyword">mutable</span> cl_uint min_data_type_align_size_;
<a name="l01410"></a>01410 
<a name="l01411"></a>01411         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> name_valid_;
<a name="l01412"></a>01412         <span class="keyword">mutable</span> <span class="keywordtype">char</span> name_[256];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01413"></a>01413 
<a name="l01414"></a>01414         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_char_valid_;
<a name="l01415"></a>01415         <span class="keyword">mutable</span> cl_uint native_vector_width_char_;
<a name="l01416"></a>01416 
<a name="l01417"></a>01417         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_short_valid_;
<a name="l01418"></a>01418         <span class="keyword">mutable</span> cl_uint native_vector_width_short_;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_int_valid_;
<a name="l01421"></a>01421         <span class="keyword">mutable</span> cl_uint native_vector_width_int_;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_long_valid_;
<a name="l01424"></a>01424         <span class="keyword">mutable</span> cl_uint native_vector_width_long_;
<a name="l01425"></a>01425 
<a name="l01426"></a>01426         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_float_valid_;
<a name="l01427"></a>01427         <span class="keyword">mutable</span> cl_uint native_vector_width_float_;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_double_valid_;
<a name="l01430"></a>01430         <span class="keyword">mutable</span> cl_uint native_vector_width_double_;
<a name="l01431"></a>01431 
<a name="l01432"></a>01432         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    native_vector_width_half_valid_;
<a name="l01433"></a>01433         <span class="keyword">mutable</span> cl_uint native_vector_width_half_;
<a name="l01434"></a>01434 
<a name="l01435"></a>01435         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> opencl_c_version_valid_;
<a name="l01436"></a>01436         <span class="keyword">mutable</span> <span class="keywordtype">char</span> opencl_c_version_[128];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01437"></a>01437 
<a name="l01438"></a>01438         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>           platform_valid_;
<a name="l01439"></a>01439         <span class="keyword">mutable</span> cl_platform_id platform_;
<a name="l01440"></a>01440 
<a name="l01441"></a>01441         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_char_valid_;
<a name="l01442"></a>01442         <span class="keyword">mutable</span> cl_uint preferred_vector_width_char_;
<a name="l01443"></a>01443 
<a name="l01444"></a>01444         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_short_valid_;
<a name="l01445"></a>01445         <span class="keyword">mutable</span> cl_uint preferred_vector_width_short_;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_int_valid_;
<a name="l01448"></a>01448         <span class="keyword">mutable</span> cl_uint preferred_vector_width_int_;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_long_valid_;
<a name="l01451"></a>01451         <span class="keyword">mutable</span> cl_uint preferred_vector_width_long_;
<a name="l01452"></a>01452 
<a name="l01453"></a>01453         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_float_valid_;
<a name="l01454"></a>01454         <span class="keyword">mutable</span> cl_uint preferred_vector_width_float_;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_double_valid_;
<a name="l01457"></a>01457         <span class="keyword">mutable</span> cl_uint preferred_vector_width_double_;
<a name="l01458"></a>01458 
<a name="l01459"></a>01459         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    preferred_vector_width_half_valid_;
<a name="l01460"></a>01460         <span class="keyword">mutable</span> cl_uint preferred_vector_width_half_;
<a name="l01461"></a>01461 
<a name="l01462"></a>01462         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> profile_valid_;
<a name="l01463"></a>01463         <span class="keyword">mutable</span> <span class="keywordtype">char</span> profile_[32];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>   profiling_timer_resolution_valid_;
<a name="l01466"></a>01466         <span class="keyword">mutable</span> <span class="keywordtype">size_t</span> profiling_timer_resolution_;
<a name="l01467"></a>01467 
<a name="l01468"></a>01468         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                        queue_properties_valid_;
<a name="l01469"></a>01469         <span class="keyword">mutable</span> cl_command_queue_properties queue_properties_;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>                single_fp_config_valid_;
<a name="l01472"></a>01472         <span class="keyword">mutable</span> cl_device_fp_config single_fp_config_;
<a name="l01473"></a>01473 
<a name="l01474"></a>01474         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>           type_valid_;
<a name="l01475"></a>01475         <span class="keyword">mutable</span> cl_device_type type_;
<a name="l01476"></a>01476 
<a name="l01477"></a>01477         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> vendor_valid_;
<a name="l01478"></a>01478         <span class="keyword">mutable</span> <span class="keywordtype">char</span> vendor_[256];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01479"></a>01479 
<a name="l01480"></a>01480         <span class="keyword">mutable</span> <span class="keywordtype">bool</span>    vendor_id_valid_;
<a name="l01481"></a>01481         <span class="keyword">mutable</span> cl_uint vendor_id_;
<a name="l01482"></a>01482 
<a name="l01483"></a>01483         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> version_valid_;
<a name="l01484"></a>01484         <span class="keyword">mutable</span> <span class="keywordtype">char</span> version_[256];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01485"></a>01485 
<a name="l01486"></a>01486         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> driver_version_valid_;
<a name="l01487"></a>01487         <span class="keyword">mutable</span> <span class="keywordtype">char</span> driver_version_[256];    <span class="comment">// don&#39;t forget to adjust member function accordingly when changing array size</span>
<a name="l01488"></a>01488 
<a name="l01489"></a>01489         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> architecture_family_valid_;
<a name="l01490"></a>01490         <span class="keyword">mutable</span> <a class="code" href="namespaceviennacl_1_1ocl.html#adb83837b11c9bec5603b76a0012e24e8">device_architecture_family</a> architecture_family_;
<a name="l01491"></a>01491     };
<a name="l01492"></a>01492 
<a name="l01493"></a>01493   } <span class="comment">//namespace ocl</span>
<a name="l01494"></a>01494 } <span class="comment">//namespace viennacl</span>
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:36 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
