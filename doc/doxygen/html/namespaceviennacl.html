<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1backend.html">backend</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing routines for handling the different memory domains. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1detail.html">detail</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Holds implementation details for functionality in the main viennacl-namespace. Not intended for direct use by library users. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1generator.html">generator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides an OpenCL kernel generator. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">io</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides basic input-output functionality. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Provides all linear algebra operations which are not covered by operator overloads. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">ocl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>OpenCL backend. Manages platforms, contexts, buffers, kernels, etc. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1result__of.html">result_of</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace containing many meta-functions. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1scheduler.html">scheduler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains the scheduling functionality which allows for dynamic kernel generation as well as the fusion of multiple statements into a single kernel. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">tools</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace for various tools used within ViennaCL. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Namespace providing traits-information as well as generic wrappers to common routines for vectors and matrices such as <a class="el" href="namespaceviennacl_1_1traits.html#aa2344ea20469f55fbc15a8e9526494d0" title="Generic routine for obtaining the size of a vector (ViennaCL, uBLAS, etc.)">size()</a> or <a class="el" href="namespaceviennacl_1_1traits.html#a22ab64b1df12a9da0423e5cad52ea367" title="Generic routine for setting all entries of a vector to zero. This is the version for non-ViennaCL obj...">clear()</a> </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Circulant matrix class.  <a href="classviennacl_1_1circulant__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows carry nonzero entries.  <a href="classviennacl_1_1compressed__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format.  <a href="classviennacl_1_1compressed__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1context.html">context</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a generic 'context' similar to an OpenCL context, but is backend-agnostic and thus also suitable for CUDA and OpenMP.  <a href="classviennacl_1_1context.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row and column indices and val denotes the entry.  <a href="classviennacl_1_1coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using the ELLPACK format for storing the nonzeros.  <a href="classviennacl_1_1ell__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__assign.html">op_assign</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing assignment.  <a href="structviennacl_1_1op__assign.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__add.html">op_inplace_add</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace addition.  <a href="structviennacl_1_1op__inplace__add.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inplace__sub.html">op_inplace_sub</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inplace subtraction.  <a href="structviennacl_1_1op__inplace__sub.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__add.html">op_add</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing addition.  <a href="structviennacl_1_1op__add.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sub.html">op_sub</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing subtraction.  <a href="structviennacl_1_1op__sub.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mult.html">op_mult</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing multiplication by a scalar.  <a href="structviennacl_1_1op__mult.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__prod.html">op_prod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-vector products and element-wise multiplications.  <a href="structviennacl_1_1op__prod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__mat__mat__prod.html">op_mat_mat_prod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing matrix-matrix products.  <a href="structviennacl_1_1op__mat__mat__prod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__div.html">op_div</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing division.  <a href="structviennacl_1_1op__div.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__pow.html">op_pow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the power function.  <a href="structviennacl_1_1op__pow.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__binary.html">op_element_binary</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise binary operations (like multiplication) on vectors or matrices.  <a href="structviennacl_1_1op__element__binary.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__element__unary.html">op_element_unary</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing element-wise unary operations (like sin()) on vectors or matrices.  <a href="structviennacl_1_1op__element__unary.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__abs.html">op_abs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the modulus function for integers.  <a href="structviennacl_1_1op__abs.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__acos.html">op_acos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the acos() function.  <a href="structviennacl_1_1op__acos.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__asin.html">op_asin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the asin() function.  <a href="structviennacl_1_1op__asin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan.html">op_atan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan() function.  <a href="structviennacl_1_1op__atan.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__atan2.html">op_atan2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the atan2() function.  <a href="structviennacl_1_1op__atan2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__ceil.html">op_ceil</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the ceil() function.  <a href="structviennacl_1_1op__ceil.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cos.html">op_cos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cos() function.  <a href="structviennacl_1_1op__cos.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__cosh.html">op_cosh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the cosh() function.  <a href="structviennacl_1_1op__cosh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__exp.html">op_exp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the exp() function.  <a href="structviennacl_1_1op__exp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fabs.html">op_fabs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fabs() function.  <a href="structviennacl_1_1op__fabs.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fdim.html">op_fdim</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fdim() function.  <a href="structviennacl_1_1op__fdim.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__floor.html">op_floor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the floor() function.  <a href="structviennacl_1_1op__floor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmax.html">op_fmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmax() function.  <a href="structviennacl_1_1op__fmax.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmin.html">op_fmin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmin() function.  <a href="structviennacl_1_1op__fmin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__fmod.html">op_fmod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the fmod() function.  <a href="structviennacl_1_1op__fmod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log.html">op_log</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log() function.  <a href="structviennacl_1_1op__log.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__log10.html">op_log10</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the log10() function.  <a href="structviennacl_1_1op__log10.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sin.html">op_sin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sin() function.  <a href="structviennacl_1_1op__sin.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sinh.html">op_sinh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sinh() function.  <a href="structviennacl_1_1op__sinh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__sqrt.html">op_sqrt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the sqrt() function.  <a href="structviennacl_1_1op__sqrt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tan.html">op_tan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tan() function.  <a href="structviennacl_1_1op__tan.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__tanh.html">op_tanh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the tanh() function.  <a href="structviennacl_1_1op__tanh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the (off-)diagonal of a matrix.  <a href="structviennacl_1_1op__matrix__diag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing a matrix given by a vector placed on a certain (off-)diagonal.  <a href="structviennacl_1_1op__vector__diag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__row.html">op_row</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix row to a vector.  <a href="structviennacl_1_1op__row.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__column.html">op_column</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the extraction of a matrix column to a vector.  <a href="structviennacl_1_1op__column.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__inner__prod.html">op_inner_prod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing inner products of two vectors.  <a href="structviennacl_1_1op__inner__prod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__1.html">op_norm_1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 1-norm of a vector.  <a href="structviennacl_1_1op__norm__1.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__2.html">op_norm_2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the 2-norm of a vector.  <a href="structviennacl_1_1op__norm__2.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__inf.html">op_norm_inf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the inf-norm of a vector.  <a href="structviennacl_1_1op__norm__inf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__norm__frobenius.html">op_norm_frobenius</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing the Frobenius-norm of a matrix.  <a href="structviennacl_1_1op__norm__frobenius.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__trans.html">op_trans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing transposed matrices.  <a href="structviennacl_1_1op__trans.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1op__flip__sign.html">op_flip_sign</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class representing sign flips (for scalars only. Vectors and matrices use the standard multiplication by the scalar -1.0)  <a href="structviennacl_1_1op__flip__sign.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major__tag.html">row_major_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating row-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix.">row_major</a> type.  <a href="structviennacl_1_1row__major__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major__tag.html">column_major_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for indicating column-major layout of a matrix. Not passed to the matrix directly, see <a class="el" href="structviennacl_1_1row__major.html" title="A tag for row-major storage of a dense matrix.">row_major</a> type.  <a href="structviennacl_1_1column__major__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">column_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag for column-major storage of a dense matrix.  <a href="structviennacl_1_1column__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__cpu__scalar.html">is_cpu_scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a host scalar type (e.g. float, double)  <a href="structviennacl_1_1is__cpu__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type is a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__flip__sign__scalar.html">is_flip_sign_scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether a type represents a sign flip on a viennacl::scalar&lt;&gt;  <a href="structviennacl_1_1is__flip__sign__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__scalar.html">is_any_scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for checking whether the provided type represents a scalar (either host, from ViennaCL, or a flip-sign proxy)  <a href="structviennacl_1_1is__any__scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__vector.html">is_any_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for a type being either <a class="el" href="classviennacl_1_1vector__base.html" title="Common base class for dense vectors, vector ranges, and vector slices.">vector_base</a> or <a class="el" href="classviennacl_1_1implicit__vector__base.html" title="Common base class for representing vectors where the entries are not all stored explicitly.">implicit_vector_base</a>.  <a href="structviennacl_1_1is__any__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__matrix.html">is_any_dense_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for either <a class="el" href="classviennacl_1_1matrix__base.html" title="A dense matrix class.">matrix_base</a> or <a class="el" href="classviennacl_1_1implicit__matrix__base.html" title="Base class for representing matrices where the individual entries are not all stored explicitly...">implicit_matrix_base</a>.  <a href="structviennacl_1_1is__any__dense__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__row__major.html">is_row_major</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix has a row-major layout.  <a href="structviennacl_1_1is__row__major.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__compressed__matrix.html">is_compressed_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> (CSR format)  <a href="structviennacl_1_1is__compressed__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__coordinate__matrix.html">is_coordinate_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> (COO format)  <a href="structviennacl_1_1is__coordinate__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ell__matrix.html">is_ell_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is an <a class="el" href="classviennacl_1_1ell__matrix.html" title="Sparse matrix class using the ELLPACK format for storing the nonzeros.">ell_matrix</a> (ELL format)  <a href="structviennacl_1_1is__ell__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hyb__matrix.html">is_hyb_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a <a class="el" href="classviennacl_1_1hyb__matrix.html" title="Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros...">hyb_matrix</a> (hybrid format: ELL plus CSR)  <a href="structviennacl_1_1is__hyb__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">is_any_sparse_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is one of the sparse matrix types (<a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>, <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>, etc.)  <a href="structviennacl_1_1is__any__sparse__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__circulant__matrix.html">is_circulant_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a circulant matrix.  <a href="structviennacl_1_1is__circulant__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__hankel__matrix.html">is_hankel_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Hankel matrix.  <a href="structviennacl_1_1is__hankel__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__toeplitz__matrix.html">is_toeplitz_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Toeplitz matrix.  <a href="structviennacl_1_1is__toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__vandermonde__matrix.html">is_vandermonde_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a matrix is a Vandermonde matrix.  <a href="structviennacl_1_1is__vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__any__dense__structured__matrix.html">is_any_dense_structured_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether the provided type is any of the dense structured matrix types (circulant, Hankel, etc.)  <a href="structviennacl_1_1is__any__dense__structured__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1memory__exception.html">memory_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class in case of memory errors.  <a href="classviennacl_1_1memory__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1cuda__not__available__exception.html">cuda_not_available_exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Hankel matrix class.  <a href="classviennacl_1_1hankel__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix class using a hybrid format composed of the ELL and CSR format for storing the nonzeros.  <a href="classviennacl_1_1hyb__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__matrix__base.html">implicit_matrix_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing matrices where the individual entries are not all stored explicitly, e.g. identity_matrix&lt;&gt;  <a href="classviennacl_1_1implicit__matrix__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1identity__matrix.html">identity_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1identity__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__matrix.html">zero_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__matrix.html">scalar_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression template class for representing a tree of expressions which ultimately result in a matrix.  <a href="classviennacl_1_1matrix__expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">uBLAS-like iterator class for iterating over the entries of a dense matrix.  <a href="classviennacl_1_1matrix__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing non-strided submatrices of a bigger matrix A.  <a href="classviennacl_1_1matrix__range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing strided submatrices of a bigger matrix A.  <a href="classviennacl_1_1matrix__slice.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple enable-if variant that uses the SFINAE pattern.  <a href="structviennacl_1_1enable__if.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__addition.html">is_addition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__add.html" title="A tag class representing addition.">viennacl::op_add</a> (for addition)  <a href="structviennacl_1_1is__addition.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__subtraction.html">is_subtraction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__sub.html" title="A tag class representing subtraction.">viennacl::op_sub</a> (for subtraction)  <a href="structviennacl_1_1is__subtraction.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__product.html">is_product</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__prod.html" title="A tag class representing matrix-vector products and element-wise multiplications.">viennacl::op_prod</a> (for products/multiplication)  <a href="structviennacl_1_1is__product.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__division.html">is_division</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper metafunction for checking whether the provided type is <a class="el" href="structviennacl_1_1op__div.html" title="A tag class representing division.">viennacl::op_div</a> (for division)  <a href="structviennacl_1_1is__division.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__primitive__type.html">is_primitive_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for checking whether a type is a primitive type.  <a href="structviennacl_1_1is__primitive__type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__none.html">tag_none</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying 'unknown' types.  <a href="structviennacl_1_1tag__none.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__mtl4.html">tag_mtl4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from MTL4.  <a href="structviennacl_1_1tag__mtl4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__eigen.html">tag_eigen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from Eigen.  <a href="structviennacl_1_1tag__eigen.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from uBLAS.  <a href="structviennacl_1_1tag__ublas.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__stl.html">tag_stl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from the C++ STL.  <a href="structviennacl_1_1tag__stl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for identifying types from ViennaCL.  <a href="structviennacl_1_1tag__viennacl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__mtl4.html">is_mtl4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__mtl4.html" title="A tag class for identifying types from MTL4.">tag_mtl4</a>.  <a href="structviennacl_1_1is__mtl4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__eigen.html">is_eigen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__eigen.html" title="A tag class for identifying types from Eigen.">tag_eigen</a>.  <a href="structviennacl_1_1is__eigen.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas.html">is_ublas</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html" title="A tag class for identifying types from uBLAS.">tag_ublas</a>.  <a href="structviennacl_1_1is__ublas.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__stl.html">is_stl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html" title="A tag class for identifying types from uBLAS.">tag_ublas</a>.  <a href="structviennacl_1_1is__stl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl.html">is_viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__viennacl.html" title="A tag class for identifying types from ViennaCL.">tag_viennacl</a>.  <a href="structviennacl_1_1is__viennacl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1cuthill__mckee__tag.html">cuthill_mckee_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag class for selecting the Cuthill-McKee algorithm for reducing the bandwidth of a sparse matrix.  <a href="structviennacl_1_1cuthill__mckee__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1advanced__cuthill__mckee__tag.html">advanced_cuthill_mckee_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the advanced Cuthill-McKee algorithm (i.e. running the 'standard' Cuthill-McKee algorithm for a couple of different seeds).  <a href="classviennacl_1_1advanced__cuthill__mckee__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html">gibbs_poole_stockmeyer_tag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag class for identifying the Gibbs-Poole-Stockmeyer algorithm for reducing the bandwidth of a sparse matrix.  <a href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__range.html">basic_range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A range class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy for scalar expressions (e.g. from inner vector products)  <a href="classviennacl_1_1scalar__expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__inner__prod_01_4.html">scalar_expression&lt; LHS, RHS, op_inner_prod &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for inner products. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__inner__prod_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__1_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_1. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__1_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__2_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_2. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__2_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__inf_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_inf &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_inf. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__inf_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__frobenius_01_4.html">scalar_expression&lt; LHS, RHS, op_norm_frobenius &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of a scalar expression for norm_frobenius. Allows for a final reduction on the CPU.  <a href="classviennacl_1_1scalar__expression_3_01_l_h_s_00_01_r_h_s_00_01op__norm__frobenius_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar.html">scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type like float or double.  <a href="classviennacl_1_1scalar.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice class that refers to an interval [start, stop), where 'start' is included, and 'stop' is excluded.  <a href="classviennacl_1_1basic__slice.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Toeplitz matrix class.  <a href="classviennacl_1_1toeplitz__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1entry__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__entry__proxy.html">const_entry_proxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1const__entry__proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vandermonde matrix class.  <a href="classviennacl_1_1vandermonde__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__vector__base.html">implicit_vector_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for representing vectors where the entries are not all stored explicitly.  <a href="classviennacl_1_1implicit__vector__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1unit__vector.html">unit_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise.  <a href="classviennacl_1_1unit__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__vector.html">zero_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only.  <a href="classviennacl_1_1zero__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1one__vector.html">one_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of ones only.  <a href="classviennacl_1_1one__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__vector.html">scalar_vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression template class that represents a binary operation that yields a vector.  <a href="classviennacl_1_1vector__expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  <a href="classviennacl_1_1const__vector__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!  <a href="classviennacl_1_1vector__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for dense vectors, vector ranges, and vector slices.  <a href="classviennacl_1_1vector__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html">vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::vector.  <a href="classviennacl_1_1vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple class holding pointers to multiple vectors. Mainly used as a temporary object returned from <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie()</a>.  <a href="classviennacl_1_1vector__tuple.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing non-strided subvectors of a bigger vector x.  <a href="classviennacl_1_1vector__range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing strided subvectors of a bigger vector x.  <a href="classviennacl_1_1vector__slice.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1basic__range.html">basic_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">range</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">slice</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">memory_types</a> { <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810">MEMORY_NOT_INITIALIZED</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c">MAIN_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001">OPENCL_MEMORY</a>, 
<a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03">CUDA_MEMORY</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a87d41d517b3d0daca8b1536e15e6659d">switch_memory_context</a> (T &amp;obj, <a class="el" href="classviennacl_1_1context.html">viennacl::context</a> new_ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic convenience routine for migrating data of an object to a new memory domain.  <a href="#a87d41d517b3d0daca8b1536e15e6659d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">copy</a> (std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#aa6eeaec91ef48b6f60c0206f09888163"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a126f2a3b2c6751f234e10999b27f42">copy</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a0a126f2a3b2c6751f234e10999b27f42"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad91450296031c933d0131304f388bf1f">copy</a> (<a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#ad91450296031c933d0131304f388bf1f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae879503909c9b66fad49e8295726dfe5">copy</a> (MATRIXTYPE &amp;com_src, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the circulant matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#ae879503909c9b66fad49e8295726dfe5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1febce45965241500ed60feeaf290dec">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1circulant__matrix.html">circulant_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a1febce45965241500ed60feeaf290dec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a499f98274df77172adc5a7cee6a4289a">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; SCALARTYPE &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a499f98274df77172adc5a7cee6a4289a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8426a9dafc7b6488f61811866b481715">copy</a> (const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; SCALARTYPE &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;SizeType, SCALARTYPE&gt; &gt; to ba...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices.  <a href="#a8426a9dafc7b6488f61811866b481715"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9d1999a9f4f94ec6e3601528245bd7d8">copy</a> (const <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; SCALARTYPE &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a9d1999a9f4f94ec6e3601528245bd7d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af554e2309a7e347f5fbb9b6d3a85fcc3">copy</a> (const <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html">compressed_compressed_matrix</a>&lt; SCALARTYPE &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#af554e2309a7e347f5fbb9b6d3a85fcc3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a582c55682d79f0d548cd30f54412867b">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a582c55682d79f0d548cd30f54412867b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SizeType , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a237f3288335acfa845fcad2915a4def4">copy</a> (const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;SizeType, SCALARTYPE&gt; &gt; to ba...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices.  <a href="#a237f3288335acfa845fcad2915a4def4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac594658b697570a6d4321a157d30bc0f">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#ac594658b697570a6d4321a157d30bc0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a819d66bc1da492c41811de0d4815ea28">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a819d66bc1da492c41811de0d4815ea28"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a22804a43ca1561efd03d0d09d1eb027a">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)  <a href="#a22804a43ca1561efd03d0d09d1eb027a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae1fd3c3d02e18c4400901acfa6617a85">copy</a> (const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#ae1fd3c3d02e18c4400901acfa6617a85"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3e537294698c05511a1dbb3693e378d6">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a3e537294698c05511a1dbb3693e378d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a381e8b0ba7c993453490de8d40090bdb">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a381e8b0ba7c993453490de8d40090bdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad703586f75e0f4ef42cf61cb1b2d9ef5">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af3332c84c557449850580f50b74d5f8c">copy</a> (const <a class="el" href="classviennacl_1_1ell__matrix.html">ell_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae90a3bfb2d1d49bb356c8f2179a685b0">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#ae90a3bfb2d1d49bb356c8f2179a685b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0d783c95a46bcb7d01000ae479a03cfc">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a0d783c95a46bcb7d01000ae479a03cfc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9139574d3d99501f0ef6c3fc322e548">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a815cf9646ece6cc98ec80b3f925c482d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abfe63ce6ea6eded970702b69279c37fb">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#abfe63ce6ea6eded970702b69279c37fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a03af48cea9a5fea3198f162b6b9a4eb0">copy</a> (std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#a03af48cea9a5fea3198f162b6b9a4eb0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a92dcefda716d015629dbdfcbd1415681">copy</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a92dcefda716d015629dbdfcbd1415681"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac469622b0f544532fc02adc9db80b031">copy</a> (<a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;han_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#ac469622b0f544532fc02adc9db80b031"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4c68c868aa1def45e1247b6f175ae684">copy</a> (MATRIXTYPE const &amp;com_src, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;han_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Hankel matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a4c68c868aa1def45e1247b6f175ae684"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a62d454e7d9e7b376258fdf34e20e538b">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1hankel__matrix.html">hankel_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac8b18ab1f522e27ba87db0da5af465e7">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a692978afc5e0f0654163509c3c519d37">copy</a> (const <a class="el" href="classviennacl_1_1hyb__matrix.html">hyb_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a773db2ca4b258b74a575da40fbfda49b">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#a773db2ca4b258b74a575da40fbfda49b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa5d425b543da3d12007eb98065137138">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#aa5d425b543da3d12007eb98065137138"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a36a774cb277f1c9588168775f56a0ebf">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#a36a774cb277f1c9588168775f56a0ebf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab30239ae5a61e50989e36802adb29d8f">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#ab30239ae5a61e50989e36802adb29d8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae14e093250df58e8254f94e805c6a4f5">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 += A * v2, where A is a matrix.  <a href="#ae14e093250df58e8254f94e805c6a4f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9672a2d4e157a13683bc2bbe7d315f15">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation v1 -= A * v2, where A is a matrix.  <a href="#a9672a2d4e157a13683bc2bbe7d315f15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab6e057825e16a810dd49dbb2b46e5e76">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#ab6e057825e16a810dd49dbb2b46e5e76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; NumericT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a934ba52bdd529f4aa5250f9db3225627">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#a934ba52bdd529f4aa5250f9db3225627"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; M1 &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const M1, <br class="typebreak"/>
const M1, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">trans</a> (const M1 &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a2ee5dd77d41040e0a937a60346475b84"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab85e3912a40d5d479835e7608808f07e">operator+</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 + A * v2', where A is a matrix.  <a href="#ab85e3912a40d5d479835e7608808f07e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename SparseMatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a><br class="typebreak"/>
&lt; SparseMatrixType &gt;::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5309df539f189a889f45f5e25098930f">operator-</a> (<a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;result, const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the operation 'result = v1 - A * v2', where A is a matrix.  <a href="#a5309df539f189a889f45f5e25098930f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad648cd691bb8fa8358f552d00bce2946">operator+=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const LHS, const RHS, OP &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5e584237e084f29313d487917ceed47e">operator-=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const LHS, const RHS, OP &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aea303edb50bfe8b43d5591d62abd690d">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; SCALARTYPE, F &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#aea303edb50bfe8b43d5591d62abd690d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c1627d47e4b494526e0287de3ed8476">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; &amp;expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a6c1627d47e4b494526e0287de3ed8476"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0250af0917fd1088eb339e3550964954">trans</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a0250af0917fd1088eb339e3550964954"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const int, <a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad459d800c7d2ca780bd3ecd21941dc24">diag</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;A, int k=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <br class="typebreak"/>
int, <a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a96df6ab1bb59ee2c6e540694639d27">diag</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;v, int k=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const unsigned int, <a class="el" href="structviennacl_1_1op__row.html">op_row</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a574e6cd04ca0e42298b4ab845700e4">row</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;A, unsigned int i)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const unsigned int, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__column.html">op_column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7fca08f4a83edffe7f47666d298ca87d">column</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;A, unsigned int j)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3728d51018413682b2c807cb26fe0ce6">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#a3728d51018413682b2c807cb26fe0ce6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aba57054849e1adf3cd627b22d8512b75">copy</a> (const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#aba57054849e1adf3cd627b22d8512b75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6fe9c1c3ea45c54d92082b1805790e80">fast_copy</a> (SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU.  <a href="#a6fe9c1c3ea45c54d92082b1805790e80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad655c8cbb96bf07d2348309a2656799e">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#ad655c8cbb96bf07d2348309a2656799e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aab87e45b79097799bbaabeed1e240ace">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#aab87e45b79097799bbaabeed1e240ace"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a67d05f6ec18b2d7c2051eb4f6b47b5a7">fast_copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a67d05f6ec18b2d7c2051eb4f6b47b5a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1467c3b3f6546172c178ac106513a1ae">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#a1467c3b3f6546172c178ac106513a1ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad31e53305db54fcf4483dec49674f440">operator+</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const LHS2, const RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa21f64d8b17b9c3a8891c584e882a4ca">operator+</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5372fd531482dd77aac96fba60b4538f">operator+</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5372fd531482dd77aac96fba60b4538f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a182bd38887779e44f6abfbd476538605">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2d60c450a5eadd9178afbfde5cc9fd6e">operator-</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const LHS2, const RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa586c718254a15cf8326253a0d4fac8d">operator-</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5bf54d540a468ff7b897e5b4d9b8b330">operator-</a> (const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5bf54d540a468ff7b897e5b4d9b8b330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad2dd7a1271ffad8b38aa15d24c47f0cc">operator*</a> (S1 const &amp;value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;m1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix.  <a href="#ad2dd7a1271ffad8b38aa15d24c47f0cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9a515a15cb3bffa56339f894312d7a0a">operator*</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the right.  <a href="#a9a515a15cb3bffa56339f894312d7a0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2189d7a68eacf7ebf7d7ec97e3430a4e">operator*</a> (S1 const &amp;val, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the left.  <a href="#a2189d7a68eacf7ebf7d7ec97e3430a4e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9a9af1376549e609219bc1e341247817">operator*</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a GPU scalar 'alpha' and returns an expression template.  <a href="#a9a9af1376549e609219bc1e341247817"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4">operator*=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a920e8836c8304945668799c249ef35c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afb7c2e69a5e9e6d41ee3b651605b9750">operator/</a> (<a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const LHS, const RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then divided by alpha.  <a href="#afb7c2e69a5e9e6d41ee3b651605b9750"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acc8e629b037b3ae3dd4dccf7fd277250">operator/</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a GPU scalar 'alpha'.  <a href="#acc8e629b037b3ae3dd4dccf7fd277250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453">operator/=</a> (<a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a2949cf07f6b1bb423de3f634d4b49453"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a50b2b832ea2c80dd6266efc27cc483e8">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy, const S1 &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a21d1613c4092dfdd5db6176f6d7ef7dc">operator*</a> (const S1 &amp;val, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt; &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a975242568e2dcb6cb6acdbfc166b4eb2">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; &amp;gpu_matrix_range)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad0fd2e7e9bf7ca3ad63ffda64c7b14e2">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; &amp;gpu_matrix_range)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad45a6160851a0184c6127de22cc780e6">copy</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a54c4d59831b38159a5cd0444ab891864">copy</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">project</a> (MatrixType &amp;A, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af97f37bc5782032f5d48aa7d69e00612">project</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; &amp;A, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5dee37834f9f1cf2c2cb530821c5975b">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; &amp;gpu_matrix_slice)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa423da9ae9241369e204bc22f3f6d4ed">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; &amp;gpu_matrix_slice)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a00d559e0934897588985715f2ac42eb3">copy</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1row__major.html">row_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4afe2af2aa2fa3294d77cc2bfb0d6e37">copy</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, <a class="el" href="structviennacl_1_1column__major.html">column_major</a>, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad843d07ca697041a7bb42656644c7ef9">project</a> (MatrixType &amp;A, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3a7f5b8c12a1e8b2b5a278173414f330">project</a> (<a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt; MatrixType &gt; &amp;A, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad17914cefb71411c1c616c8ca21c4342">project</a> (<a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt; MatrixType &gt; &amp;A, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r1, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;r2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename ValueT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IndexT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af22338e452cee008bee5e38070ddc611">reorder</a> (std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="structviennacl_1_1cuthill__mckee__tag.html">cuthill_mckee_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the Cuthill-McKee algorithm.  <a href="#af22338e452cee008bee5e38070ddc611"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IndexT , typename ValueT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IndexT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a032f691cd245d13b51b951f8a10825f3">reorder</a> (std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1advanced__cuthill__mckee__tag.html">advanced_cuthill_mckee_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the advanced Cuthill-McKee algorithm.  <a href="#a032f691cd245d13b51b951f8a10825f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acec126e71833e0756286cbf8cd036fbd">reorder</a> (MatrixType const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="structviennacl_1_1gibbs__poole__stockmeyer__tag.html">gibbs_poole_stockmeyer_tag</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for the calculation of a node numbering permutation vector to reduce the bandwidth of a incidence matrix by the Gibbs-Poole-Stockmeyer algorithm.  <a href="#acec126e71833e0756286cbf8cd036fbd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aeb593bb1abab989d5396c3196ba4ff01">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to directly print the value of a scalar to an output stream.  <a href="#aeb593bb1abab989d5396c3196ba4ff01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad4143bdeffd1dc0aa102777fb6179747">operator&gt;&gt;</a> (std::istream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to directly read a value of a scalar from an input stream.  <a href="#ad4143bdeffd1dc0aa102777fb6179747"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af18e0a8b6c0a2fc42090a78158329951">copy</a> (std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#af18e0a8b6c0a2fc42090a78158329951"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa17c5bbb85bd1d93daa7d0767edbf2dd">copy</a> (<a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#aa17c5bbb85bd1d93daa7d0767edbf2dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a40eb132b8b1293854c1a8f5e9860dbdf">copy</a> (<a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;tep_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#a40eb132b8b1293854c1a8f5e9860dbdf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9bdaf347b6f7a3c1b0d74d97e103a158">copy</a> (MATRIXTYPE const &amp;com_src, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;tep_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a9bdaf347b6f7a3c1b0d74d97e103a158"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0150a5d176ba2a924ffa44b65287f460">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1toeplitz__matrix.html">toeplitz_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a0150a5d176ba2a924ffa44b65287f460"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad0d83fb04dea07ec903eb82e7fbfa165">copy</a> (std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)  <a href="#ad0d83fb04dea07ec903eb82e7fbfa165"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a384b787fb35e74b44c5c685b7dca6de2">copy</a> (<a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector.  <a href="#a384b787fb35e74b44c5c685b7dca6de2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa3f006c00cce616394f6a412be783d24">copy</a> (<a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_src, MATRIXTYPE &amp;com_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object.  <a href="#aa3f006c00cce616394f6a412be783d24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename MATRIXTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a88e7916fee08d3c2f4ac2f334e925f44">copy</a> (MATRIXTYPE &amp;com_src, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a the matrix-like object to the Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU)  <a href="#a88e7916fee08d3c2f4ac2f334e925f44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af9a32a60b002b21a968695892e5e564b">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vandermonde__matrix.html">vandermonde_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#af9a32a60b002b21a968695892e5e564b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab25260434dfe3c4c527fd2a9ae437685">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aee58be5508bb77871fc653aa8b33f3e2">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a56eeda7139441461f48c7303ad1b4b44">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae7d28ebaf25043e36652c5ef210d405a">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v2, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0250b6a52a40df48e3ee18f1db6e4747">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v2, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8e40b38f92dd9f2b23f8fa134da43204">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v2, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v3, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; const &amp;v4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt; ScalarT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac96d28a81e8e227f2678360fbdd92ae1">tie</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v0, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v2, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v3, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; ScalarT &gt; &amp;v4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a18efe971cc5df1ca97ca63bf7565a8ed">fast_copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a18efe971cc5df1ca97ca63bf7565a8ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad958025c01f2ddc4460a51ddd6001eea">async_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy()</a>, copying data from device to host. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#ad958025c01f2ddc4460a51ddd6001eea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad588773086ec291f43d382f023648166">async_copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#ad588773086ec291f43d382f023648166"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a592a3a17afda2a630893f43e4a682143">copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a592a3a17afda2a630893f43e4a682143"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a247dbb2faef4f43e89a6ea3c5ebdb028">copy</a> (const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a247dbb2faef4f43e89a6ea3c5ebdb028"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a41d005b9f0d205c14417da3dbdaff0f7">copy</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a41d005b9f0d205c14417da3dbdaff0f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a19621895b23c45e932e4ce15d947b311">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a19621895b23c45e932e4ce15d947b311"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_ITERATOR , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3e51d39d9dd48b65bd8590d462d0618a">async_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy()</a>, copying data from host to device. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a3e51d39d9dd48b65bd8590d462d0618a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaac9f2de1a2a22c01d1993b2e28f16d9">async_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aaac9f2de1a2a22c01d1993b2e28f16d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa38a64c6f9e5764df676c05e5aec3ff8">copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aa38a64c6f9e5764df676c05e5aec3ff8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a932444aaf1651567029ef1618f883d1b">copy</a> (<a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a932444aaf1651567029ef1618f883d1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa5623507e69891c07a96a2036105cf35">copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;gpu_dest_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());.  <a href="#aa5623507e69891c07a96a2036105cf35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab305fb97f519cb1280277cf830e3dfce">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream. Output format is ublas compatible.  <a href="#ab305fb97f519cb1280277cf830e3dfce"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a21669e48cbc9c19811088f65b1162c1c">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375">swap</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#a49233dc20718f52e98e8b06e9711b375"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa992d7af76c7c4e00d1332041581ba7d">fast_swap</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v1, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied.  <a href="#aa992d7af76c7c4e00d1332041581ba7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a447eda4887f7373cd9214f7f452aa8ca">operator*=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#a447eda4887f7373cd9214f7f452aa8ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
 &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5911b2abc96a555d3c20855f645441ac">operator/=</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#a5911b2abc96a555d3c20855f645441ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; LHS2, RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa361d54076f354799e14cb209f9373e0">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of two vector expressions.  <a href="#aa361d54076f354799e14cb209f9373e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a622a47e42369e2458b442e7dc2034579">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a622a47e42369e2458b442e7dc2034579"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3a437c51256ab4916a56ecd2b5d26d08">operator+</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the addition of a vector with a vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a3a437c51256ab4916a56ecd2b5d26d08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2471d058da27c2588866407382060cc0">operator+</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for adding up two vectors, i.e. v1 + v2.  <a href="#a2471d058da27c2588866407382060cc0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; LHS2, RHS2, OP2 &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a327404c7cd8f4b58a6bc19cbc536a363">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of two vector expressions.  <a href="#a327404c7cd8f4b58a6bc19cbc536a363"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2f50c049c1ba30ca5d5dab8b6a53d6dc">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#a2f50c049c1ba30ca5d5dab8b6a53d6dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaf453161e94700cbff1d38f14ccab626">operator-</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created.  <a href="#aaf453161e94700cbff1d38f14ccab626"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab2a0eb807884794e795aec5ec78353a4">operator-</a> (const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v1, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template object for subtracting two vectors, i.e. v1 - v2.  <a href="#ab2a0eb807884794e795aec5ec78353a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7aa194ac845881167f06c7e690fbe8d0">operator*</a> (S1 const &amp;value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector.  <a href="#a7aa194ac845881167f06c7e690fbe8d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1aa648c88a546872e66f73ae6b6f8c84">operator*</a> (char value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a char.  <a href="#a1aa648c88a546872e66f73ae6b6f8c84"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5f6a0765c929401a06741a1c837a7af3">operator*</a> (short value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a short.  <a href="#a5f6a0765c929401a06741a1c837a7af3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a53f54b5071fc459f13261a08c0ea6ee5">operator*</a> (int value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a int.  <a href="#a53f54b5071fc459f13261a08c0ea6ee5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a902d3e1f3473a758e15b232f07e7b11e">operator*</a> (long value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a long.  <a href="#a902d3e1f3473a758e15b232f07e7b11e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt; LHS, RHS, <br class="typebreak"/>
OP &gt;, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac34b0528ba9cb2a8e586a64bafc3a1b1">operator*</a> (<a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt; LHS, RHS, OP &gt; const &amp;expr, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a scalar expression and v1 is a ViennaCL vector.  <a href="#ac34b0528ba9cb2a8e586a64bafc3a1b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acf62c14c5019cb0d0e51665e704a282f">operator*</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, S1 const &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the vector by a scalar 'alpha' and returns an expression template.  <a href="#acf62c14c5019cb0d0e51665e704a282f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;, const T, <br class="typebreak"/>
<a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a595de671ea4e3f2b0bb5eebb01458168">operator*</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;vec, T const &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a409f3f32dff7d389aaae2556f8b2010a">operator*</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the right.  <a href="#a409f3f32dff7d389aaae2556f8b2010a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad16f8e922faecda1f3cdca04600b149c">operator*</a> (S1 const &amp;val, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left.  <a href="#ad16f8e922faecda1f3cdca04600b149c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a33caa6103aea5a99f9d95f041c5cd52a">operator/</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then divided by alpha.  <a href="#a33caa6103aea5a99f9d95f041c5cd52a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt;<br class="typebreak"/>
, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a479f8bc932a3b68dbd4716a0766124f9">operator/</a> (<a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; T &gt; const &amp;v1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the vector by a GPU scalar 'alpha'.  <a href="#a479f8bc932a3b68dbd4716a0766124f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a647c26aa382ff630071c39ea0f6fc057">copy</a> (const VectorType &amp;cpu_vector, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_range)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPUVECTOR , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aff87e6c12c0c4774fb92fa88e0c44806">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#aff87e6c12c0c4774fb92fa88e0c44806"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4560cc12680fc01551454fc9417fe4a7">copy</a> (<a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_range, VectorType &amp;cpu_vector)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7f9afcfdb40091e366e2160d1e47bd2b">fast_copy</a> (<a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from a GPU vector range to a CPU vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#a7f9afcfdb40091e366e2160d1e47bd2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aaa422ff6bca0f275c38493e68cfb6ab7">project</a> (VectorType &amp;vec, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4abd13449f84ae5f2a83d1ebd144d37f">project</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0209e9788d17e7af1f69b0c3ca471a4e">copy</a> (const VectorType &amp;cpu_vector, <a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_slice)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abeabae9f08d37829cb88c5f57671bda7">copy</a> (<a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_slice, VectorType &amp;cpu_vector)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3f562ecf4d6f6591fd3978d857c195b2">project</a> (VectorType &amp;vec, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;s1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a282a337b4b56bb137484bae8ac82200a">project</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;s1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0cd756eaf11b7a342d350e569d20c01c">project</a> (<a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;r1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt; VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac9d4327108630e688f72f2c135a809a9">project</a> (<a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;vec, <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;s1)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad718fa2d632fcefa865374e0a4094d14"></a><!-- doxytag: member="viennacl::range" ref="ad718fa2d632fcefa865374e0a4094d14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1basic__range.html">basic_range</a> <a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">range</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0242f7747dc5e72cf3265e18287b6b5c"></a><!-- doxytag: member="viennacl::slice" ref="a0242f7747dc5e72cf3265e18287b6b5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1basic__slice.html">basic_slice</a> <a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">slice</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2aeb075792a4f72abdd84b393d41869"></a><!-- doxytag: member="viennacl::vcl_ptrdiff_t" ref="aa2aeb075792a4f72abdd84b393d41869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a151281d5407af580310fed77af40f052"></a><!-- doxytag: member="viennacl::vcl_size_t" ref="a151281d5407af580310fed77af40f052" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107"></a><!-- doxytag: member="viennacl::memory_types" ref="ab1dbe08a5f6601428ce29f686d898107" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceviennacl.html#ab1dbe08a5f6601428ce29f686d898107">memory_types</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810"></a><!-- doxytag: member="MEMORY_NOT_INITIALIZED" ref="ab1dbe08a5f6601428ce29f686d898107a90de66e4a6d7498b51fbe77b1f513810" args="" -->MEMORY_NOT_INITIALIZED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c"></a><!-- doxytag: member="MAIN_MEMORY" ref="ab1dbe08a5f6601428ce29f686d898107aae37622ae7a0c815ff5c9806f998709c" args="" -->MAIN_MEMORY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001"></a><!-- doxytag: member="OPENCL_MEMORY" ref="ab1dbe08a5f6601428ce29f686d898107af714600f1febf093cbf30cca89c3d001" args="" -->OPENCL_MEMORY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03"></a><!-- doxytag: member="CUDA_MEMORY" ref="ab1dbe08a5f6601428ce29f686d898107ae0727dadabfc0a2ec45d67f26609fb03" args="" -->CUDA_MEMORY</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad958025c01f2ddc4460a51ddd6001eea"></a><!-- doxytag: member="viennacl::async_copy" ref="ad958025c01f2ddc4460a51ddd6001eea" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#ad958025c01f2ddc4460a51ddd6001eea">viennacl::async_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous version of <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy()</a>, copying data from device to host. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method allows for overlapping data transfer with host computation and returns immediately if the gpu vector has a unit-stride. In order to wait for the transfer to complete, use <a class="el" href="namespaceviennacl_1_1backend.html#a3707340b27c535438e213e3879b0f0a4" title="Synchronizes the execution. finish() will only return after all compute kernels (CUDA, OpenCL) have completed.">viennacl::backend::finish()</a>. Note that data pointed to by cpu_begin must not be modified prior to completion of the transfer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad588773086ec291f43d382f023648166"></a><!-- doxytag: member="viennacl::async_copy" ref="ad588773086ec291f43d382f023648166" args="(vector_base&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#ad958025c01f2ddc4460a51ddd6001eea">viennacl::async_copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator pointing to entries linear in memory can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e51d39d9dd48b65bd8590d462d0618a"></a><!-- doxytag: member="viennacl::async_copy" ref="a3e51d39d9dd48b65bd8590d462d0618a" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#ad958025c01f2ddc4460a51ddd6001eea">viennacl::async_copy</a> </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous version of <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d" title="STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of ...">fast_copy()</a>, copying data from host to device. The host iterator cpu_begin needs to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method allows for overlapping data transfer with host computation and returns immediately if the gpu vector has a unit-stride. In order to wait for the transfer to complete, use <a class="el" href="namespaceviennacl_1_1backend.html#a3707340b27c535438e213e3879b0f0a4" title="Synchronizes the execution. finish() will only return after all compute kernels (CUDA, OpenCL) have completed.">viennacl::backend::finish()</a>. Note that data pointed to by cpu_begin must not be modified prior to completion of the transfer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu iterator must be incrementable (cpu_end - cpu_begin) times, otherwise the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaac9f2de1a2a22c01d1993b2e28f16d9"></a><!-- doxytag: member="viennacl::async_copy" ref="aaac9f2de1a2a22c01d1993b2e28f16d9" args="(const CPUVECTOR &amp;cpu_vec, vector_base&lt; NumericT &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#ad958025c01f2ddc4460a51ddd6001eea">viennacl::async_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fca08f4a83edffe7f47666d298ca87d"></a><!-- doxytag: member="viennacl::column" ref="a7fca08f4a83edffe7f47666d298ca87d" args="(const matrix_base&lt; NumericT, F &gt; &amp;A, unsigned int j)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const unsigned int, <a class="el" href="structviennacl_1_1op__column.html">op_column</a>&gt; <a class="el" href="namespaceviennacl.html#a7fca08f4a83edffe7f47666d298ca87d">viennacl::column</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22804a43ca1561efd03d0d09d1eb027a"></a><!-- doxytag: member="viennacl::copy" ref="a22804a43ca1561efd03d0d09d1eb027a" args="(const CPU_MATRIX &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>For the requirements on the CPU_MATRIX type, see the documentation of the function copy(CPU_MATRIX, compressed_matrix&lt;&gt;)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a975242568e2dcb6cb6acdbfc166b4eb2"></a><!-- doxytag: member="viennacl::copy" ref="a975242568e2dcb6cb6acdbfc166b4eb2" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;gpu_matrix_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a647c26aa382ff630071c39ea0f6fc057"></a><!-- doxytag: member="viennacl::copy" ref="a647c26aa382ff630071c39ea0f6fc057" args="(const VectorType &amp;cpu_vector, vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a582c55682d79f0d548cd30f54412867b"></a><!-- doxytag: member="viennacl::copy" ref="a582c55682d79f0d548cd30f54412867b" args="(const CPU_MATRIX &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>There are some type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">size1()</a> returns the number of rows</li>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4560cc12680fc01551454fc9417fe4a7"></a><!-- doxytag: member="viennacl::copy" ref="a4560cc12680fc01551454fc9417fe4a7" args="(vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_range, VectorType &amp;cpu_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_range&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8b18ab1f522e27ba87db0da5af465e7"></a><!-- doxytag: member="viennacl::copy" ref="ac8b18ab1f522e27ba87db0da5af465e7" args="(const CPU_MATRIX &amp;cpu_matrix, hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad703586f75e0f4ef42cf61cb1b2d9ef5"></a><!-- doxytag: member="viennacl::copy" ref="ad703586f75e0f4ef42cf61cb1b2d9ef5" args="(const CPU_MATRIX &amp;cpu_matrix, ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0fd2e7e9bf7ca3ad63ffda64c7b14e2"></a><!-- doxytag: member="viennacl::copy" ref="ad0fd2e7e9bf7ca3ad63ffda64c7b14e2" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;gpu_matrix_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a499f98274df77172adc5a7cee6a4289a"></a><!-- doxytag: member="viennacl::copy" ref="a499f98274df77172adc5a7cee6a4289a" args="(const CPU_MATRIX &amp;cpu_matrix, compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU) </p>
<p>There are some type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">size1()</a> returns the number of rows</li>
<li>.<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1fd3c3d02e18c4400901acfa6617a85"></a><!-- doxytag: member="viennacl::copy" ref="ae1fd3c3d02e18c4400901acfa6617a85" args="(const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host. </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a237f3288335acfa845fcad2915a4def4"></a><!-- doxytag: member="viennacl::copy" ref="a237f3288335acfa845fcad2915a4def4" args="(const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;SizeType, SCALARTYPE&gt; &gt; to ba...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host using STL types </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e537294698c05511a1dbb3693e378d6"></a><!-- doxytag: member="viennacl::copy" ref="a3e537294698c05511a1dbb3693e378d6" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0d83fb04dea07ec903eb82e7fbfa165"></a><!-- doxytag: member="viennacl::copy" ref="ad0d83fb04dea07ec903eb82e7fbfa165" args="(std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Vandermonde matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03af48cea9a5fea3198f162b6b9a4eb0"></a><!-- doxytag: member="viennacl::copy" ref="a03af48cea9a5fea3198f162b6b9a4eb0" args="(std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Hankel matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6eeaec91ef48b6f60c0206f09888163"></a><!-- doxytag: member="viennacl::copy" ref="aa6eeaec91ef48b6f60c0206f09888163" args="(std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec, circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af18e0a8b6c0a2fc42090a78158329951"></a><!-- doxytag: member="viennacl::copy" ref="af18e0a8b6c0a2fc42090a78158329951" args="(std::vector&lt; SCALARTYPE &gt; const &amp;cpu_vec, toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Toeplitz matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a384b787fb35e74b44c5c685b7dca6de2"></a><!-- doxytag: member="viennacl::copy" ref="a384b787fb35e74b44c5c685b7dca6de2" args="(vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92dcefda716d015629dbdfcbd1415681"></a><!-- doxytag: member="viennacl::copy" ref="a92dcefda716d015629dbdfcbd1415681" args="(hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad45a6160851a0184c6127de22cc780e6"></a><!-- doxytag: member="viennacl::copy" ref="ad45a6160851a0184c6127de22cc780e6" args="(matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a126f2a3b2c6751f234e10999b27f42"></a><!-- doxytag: member="viennacl::copy" ref="a0a126f2a3b2c6751f234e10999b27f42" args="(circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8426a9dafc7b6488f61811866b481715"></a><!-- doxytag: member="viennacl::copy" ref="a8426a9dafc7b6488f61811866b481715" args="(const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;cpu_matrix, compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; SizeType, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse square matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. Use <a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html" title="Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;SizeType, SCALARTYPE&gt; &gt; to ba...">viennacl::tools::sparse_matrix_adapter</a> for non-square matrices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A sparse square matrix on the host using STL types </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3332c84c557449850580f50b74d5f8c"></a><!-- doxytag: member="viennacl::copy" ref="af3332c84c557449850580f50b74d5f8c" args="(const ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const ell_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a381e8b0ba7c993453490de8d40090bdb"></a><!-- doxytag: member="viennacl::copy" ref="a381e8b0ba7c993453490de8d40090bdb" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3f006c00cce616394f6a412be783d24"></a><!-- doxytag: member="viennacl::copy" ref="aa3f006c00cce616394f6a412be783d24" args="(vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vander_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vander_src</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad91450296031c933d0131304f388bf1f"></a><!-- doxytag: member="viennacl::copy" ref="ad91450296031c933d0131304f388bf1f" args="(circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>circ_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a circulant matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">circ_src</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac469622b0f544532fc02adc9db80b031"></a><!-- doxytag: member="viennacl::copy" ref="ac469622b0f544532fc02adc9db80b031" args="(hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;han_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>han_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Hankel matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">han_src</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa17c5bbb85bd1d93daa7d0767edbf2dd"></a><!-- doxytag: member="viennacl::copy" ref="aa17c5bbb85bd1d93daa7d0767edbf2dd" args="(toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_mat, std::vector&lt; SCALARTYPE &gt; &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the std::vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_mat</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>A std::vector on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88e7916fee08d3c2f4ac2f334e925f44"></a><!-- doxytag: member="viennacl::copy" ref="a88e7916fee08d3c2f4ac2f334e925f44" args="(MATRIXTYPE &amp;com_src, vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vander_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vander_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the Vandermonde matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">vander_dst</td><td>A <a class="el" href="classviennacl_1_1vandermonde__matrix.html" title="A Vandermonde matrix class.">vandermonde_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c68c868aa1def45e1247b6f175ae684"></a><!-- doxytag: member="viennacl::copy" ref="a4c68c868aa1def45e1247b6f175ae684" args="(MATRIXTYPE const &amp;com_src, hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;han_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE const &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>han_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the Hankel matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">han_dst</td><td>A <a class="el" href="classviennacl_1_1hankel__matrix.html" title="A Hankel matrix class.">hankel_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0209e9788d17e7af1f69b0c3ca471a4e"></a><!-- doxytag: member="viennacl::copy" ref="a0209e9788d17e7af1f69b0c3ca471a4e" args="(const VectorType &amp;cpu_vector, vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;gpu_vector_slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d1999a9f4f94ec6e3601528245bd7d8"></a><!-- doxytag: member="viennacl::copy" ref="a9d1999a9f4f94ec6e3601528245bd7d8" args="(const compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40eb132b8b1293854c1a8f5e9860dbdf"></a><!-- doxytag: member="viennacl::copy" ref="a40eb132b8b1293854c1a8f5e9860dbdf" args="(toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;tep_src, MATRIXTYPE &amp;com_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tep_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) to the matrix-like object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tep_src</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">com_dst</td><td>A matrix-like object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae879503909c9b66fad49e8295726dfe5"></a><!-- doxytag: member="viennacl::copy" ref="ae879503909c9b66fad49e8295726dfe5" args="(MATRIXTYPE &amp;com_src, circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;circ_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>circ_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the circulant matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">circ_dst</td><td>A <a class="el" href="classviennacl_1_1circulant__matrix.html" title="A Circulant matrix class.">circulant_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54c4d59831b38159a5cd0444ab891864"></a><!-- doxytag: member="viennacl::copy" ref="a54c4d59831b38159a5cd0444ab891864" args="(matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;gpu_matrix_range, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a692978afc5e0f0654163509c3c519d37"></a><!-- doxytag: member="viennacl::copy" ref="a692978afc5e0f0654163509c3c519d37" args="(const hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const hyb_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae90a3bfb2d1d49bb356c8f2179a685b0"></a><!-- doxytag: member="viennacl::copy" ref="ae90a3bfb2d1d49bb356c8f2179a685b0" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">copy</a> </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bdaf347b6f7a3c1b0d74d97e103a158"></a><!-- doxytag: member="viennacl::copy" ref="a9bdaf347b6f7a3c1b0d74d97e103a158" args="(MATRIXTYPE const &amp;com_src, toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;tep_dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">MATRIXTYPE const &amp;&#160;</td>
          <td class="paramname"><em>com_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>tep_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a the matrix-like object to the Toeplitz matrix from the OpenCL device (either GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">com_src</td><td>A std::vector on the host </td></tr>
    <tr><td class="paramname">tep_dst</td><td>A <a class="el" href="classviennacl_1_1toeplitz__matrix.html" title="A Toeplitz matrix class.">toeplitz_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d783c95a46bcb7d01000ae479a03cfc"></a><!-- doxytag: member="viennacl::copy" ref="a0d783c95a46bcb7d01000ae479a03cfc" args="(const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">copy</a> </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_src_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_dest_begin</td><td>Output iterator for the gpu vector. The gpu_dest vector must be at least as long as the gpu_src vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abeabae9f08d37829cb88c5f57671bda7"></a><!-- doxytag: member="viennacl::copy" ref="abeabae9f08d37829cb88c5f57671bda7" args="(vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;gpu_vector_slice, VectorType &amp;cpu_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_slice&lt; vector&lt; SCALARTYPE &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vector_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>cpu_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9139574d3d99501f0ef6c3fc322e548"></a><!-- doxytag: member="viennacl::copy" ref="ac9139574d3d99501f0ef6c3fc322e548" args="(const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af554e2309a7e347f5fbb9b6d3a85fcc3"></a><!-- doxytag: member="viennacl::copy" ref="af554e2309a7e347f5fbb9b6d3a85fcc3" args="(const compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const compressed_compressed_matrix&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format optimized for the case that only a few rows c...">compressed_compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac594658b697570a6d4321a157d30bc0f"></a><!-- doxytag: member="viennacl::copy" ref="ac594658b697570a6d4321a157d30bc0f" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a819d66bc1da492c41811de0d4815ea28"></a><!-- doxytag: member="viennacl::copy" ref="a819d66bc1da492c41811de0d4815ea28" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dee37834f9f1cf2c2cb530821c5975b"></a><!-- doxytag: member="viennacl::copy" ref="a5dee37834f9f1cf2c2cb530821c5975b" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;gpu_matrix_slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa423da9ae9241369e204bc22f3f6d4ed"></a><!-- doxytag: member="viennacl::copy" ref="aa423da9ae9241369e204bc22f3f6d4ed" args="(const CPU_MATRIX &amp;cpu_matrix, matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;gpu_matrix_slice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a00d559e0934897588985715f2ac42eb3"></a><!-- doxytag: member="viennacl::copy" ref="a00d559e0934897588985715f2ac42eb3" args="(matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, row_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4afe2af2aa2fa3294d77cc2bfb0d6e37"></a><!-- doxytag: member="viennacl::copy" ref="a4afe2af2aa2fa3294d77cc2bfb0d6e37" args="(matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;gpu_matrix_slice, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; matrix&lt; SCALARTYPE, column_major, 1 &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3728d51018413682b2c807cb26fe0ce6"></a><!-- doxytag: member="viennacl::copy" ref="a3728d51018413682b2c807cb26fe0ce6" args="(const CPU_MATRIX &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A dense matrix on the host. Type requirements: .<a class="el" href="namespaceviennacl_1_1traits.html#aa756f5d6820722094cae0d8b9bb6d5e2" title="Generic routine for obtaining the number of rows of a matrix (ViennaCL, uBLAS, etc.)">size1()</a> returns number of rows, .<a class="el" href="namespaceviennacl_1_1traits.html#a3658e7c29ac0f60a20cb5871f5b5fd98" title="Generic routine for obtaining the number of columns of a matrix (ViennaCL, uBLAS, etc...">size2()</a> returns number of columns. Access to entries via operator() </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba57054849e1adf3cd627b22d8512b75"></a><!-- doxytag: member="viennacl::copy" ref="aba57054849e1adf3cd627b22d8512b75" args="(const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix</td><td>A dense matrix on the host of type std::vector&lt; std::vector&lt;&gt; &gt;. cpu_matrix[i][j] returns the element in the i-th row and j-th columns (both starting with zero) </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad655c8cbb96bf07d2348309a2656799e"></a><!-- doxytag: member="viennacl::copy" ref="ad655c8cbb96bf07d2348309a2656799e" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A dense memory on the host. Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab87e45b79097799bbaabeed1e240ace"></a><!-- doxytag: member="viennacl::copy" ref="aab87e45b79097799bbaabeed1e240ace" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix</td><td>A dense memory on the host using STL types, typically std::vector&lt; std::vector&lt;&gt; &gt; Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a592a3a17afda2a630893f43e4a682143"></a><!-- doxytag: member="viennacl::copy" ref="a592a3a17afda2a630893f43e4a682143" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU constant iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU constant iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a247dbb2faef4f43e89a6ea3c5ebdb028"></a><!-- doxytag: member="viennacl::copy" ref="a247dbb2faef4f43e89a6ea3c5ebdb028" args="(const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41d005b9f0d205c14417da3dbdaff0f7"></a><!-- doxytag: member="viennacl::copy" ref="a41d005b9f0d205c14417da3dbdaff0f7" args="(vector_base&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa38a64c6f9e5764df676c05e5aec3ff8"></a><!-- doxytag: member="viennacl::copy" ref="aa38a64c6f9e5764df676c05e5aec3ff8" args="(const CPUVECTOR &amp;cpu_vec, vector_base&lt; T &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a932444aaf1651567029ef1618f883d1b"></a><!-- doxytag: member="viennacl::copy" ref="a932444aaf1651567029ef1618f883d1b" args="(vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&#160;</td>
          <td class="paramname"><em>gpu_dest_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_src_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_dest_begin</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5623507e69891c07a96a2036105cf35"></a><!-- doxytag: member="viennacl::copy" ref="aa5623507e69891c07a96a2036105cf35" args="(vector&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_vec, vector&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;gpu_dest_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163">viennacl::copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_src_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_dest_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_src_vec</td><td>A gpu vector </td></tr>
    <tr><td class="paramname">gpu_dest_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad459d800c7d2ca780bd3ecd21941dc24"></a><!-- doxytag: member="viennacl::diag" ref="ad459d800c7d2ca780bd3ecd21941dc24" args="(const matrix_base&lt; NumericT, F &gt; &amp;A, int k=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const int, <a class="el" href="structviennacl_1_1op__matrix__diag.html">op_matrix_diag</a>&gt; <a class="el" href="namespaceviennacl.html#ad459d800c7d2ca780bd3ecd21941dc24">viennacl::diag</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a96df6ab1bb59ee2c6e540694639d27"></a><!-- doxytag: member="viennacl::diag" ref="a0a96df6ab1bb59ee2c6e540694639d27" args="(const vector_base&lt; NumericT &gt; &amp;v, int k=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;NumericT&gt;, const int, <a class="el" href="structviennacl_1_1op__vector__diag.html">op_vector_diag</a>&gt; <a class="el" href="namespaceviennacl.html#ad459d800c7d2ca780bd3ecd21941dc24">viennacl::diag</a> </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff87e6c12c0c4774fb92fa88e0c44806"></a><!-- doxytag: member="viennacl::fast_copy" ref="aff87e6c12c0c4774fb92fa88e0c44806" args="(const CPUVECTOR &amp;cpu_vec, vector_range&lt; VectorType &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_range&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f9afcfdb40091e366e2160d1e47bd2b"></a><!-- doxytag: member="viennacl::fast_copy" ref="a7f9afcfdb40091e366e2160d1e47bd2b" args="(vector_range&lt; VectorType &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_range&lt; VectorType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a GPU vector range to a CPU vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector range. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a815cf9646ece6cc98ec80b3f925c482d"></a><!-- doxytag: member="viennacl::fast_copy" ref="a815cf9646ece6cc98ec80b3f925c482d" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&#160;</td>
          <td class="paramname"><em>cpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy()</a> function, because entries are directly written to the cpu vector, starting with &amp;(*cpu.begin()) However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_begin</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_end</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_begin</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfe63ce6ea6eded970702b69279c37fb"></a><!-- doxytag: member="viennacl::fast_copy" ref="abfe63ce6ea6eded970702b69279c37fb" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&#160;</td>
          <td class="paramname"><em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&#160;</td>
          <td class="paramname"><em>gpu_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#aa6eeaec91ef48b6f60c0206f09888163" title="Copies a circulant matrix from the std::vector to the OpenCL device (either GPU or multi-core CPU)...">copy()</a> function, because entries are directly read from the cpu vector, starting with &amp;(*cpu.begin()). However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_begin</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td class="paramname">cpu_end</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td class="paramname">gpu_begin</td><td>Output iterator for the gpu vector. The gpu iterator must be incrementable (cpu_end - cpu_begin) times, otherwise the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fe9c1c3ea45c54d92082b1805790e80"></a><!-- doxytag: member="viennacl::fast_copy" ref="a6fe9c1c3ea45c54d92082b1805790e80" args="(SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE *&#160;</td>
          <td class="paramname"><em>cpu_matrix_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE *&#160;</td>
          <td class="paramname"><em>cpu_matrix_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_matrix_begin</td><td>Pointer to the first matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td class="paramname">cpu_matrix_end</td><td>Pointer past the last matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67d05f6ec18b2d7c2051eb4f6b47b5a7"></a><!-- doxytag: member="viennacl::fast_copy" ref="a67d05f6ec18b2d7c2051eb4f6b47b5a7" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE *&#160;</td>
          <td class="paramname"><em>cpu_matrix_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td class="paramname">cpu_matrix_begin</td><td>Pointer to the output memory on the CPU. User must ensure that provided memory is large enough. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18efe971cc5df1ca97ca63bf7565a8ed"></a><!-- doxytag: member="viennacl::fast_copy" ref="a18efe971cc5df1ca97ca63bf7565a8ed" args="(vector_base&lt; NumericT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_vec</td><td>A gpu vector. </td></tr>
    <tr><td class="paramname">cpu_vec</td><td>The cpu vector. Type requirements: Output iterator pointing to entries linear in memory can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19621895b23c45e932e4ce15d947b311"></a><!-- doxytag: member="viennacl::fast_copy" ref="a19621895b23c45e932e4ce15d947b311" args="(const CPUVECTOR &amp;cpu_vec, vector_base&lt; NumericT &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a815cf9646ece6cc98ec80b3f925c482d">viennacl::fast_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&#160;</td>
          <td class="paramname"><em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu_vec</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td class="paramname">gpu_vec</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa992d7af76c7c4e00d1332041581ba7d"></a><!-- doxytag: member="viennacl::fast_swap" ref="aa992d7af76c7c4e00d1332041581ba7d" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v1, vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; <a class="el" href="namespaceviennacl.html#aa992d7af76c7c4e00d1332041581ba7d">viennacl::fast_swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2dd7a1271ffad8b38aa15d24c47f0cc"></a><!-- doxytag: member="viennacl::operator*" ref="ad2dd7a1271ffad8b38aa15d24c47f0cc" args="(S1 const &amp;value, matrix_base&lt; NumericT, F &gt; const &amp;m1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">m1</td><td>A ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a515a15cb3bffa56339f894312d7a0a"></a><!-- doxytag: member="viennacl::operator*" ref="a9a515a15cb3bffa56339f894312d7a0a" args="(matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the right. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2189d7a68eacf7ebf7d7ec97e3430a4e"></a><!-- doxytag: member="viennacl::operator*" ref="a2189d7a68eacf7ebf7d7ec97e3430a4e" args="(S1 const &amp;val, matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the left. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a9af1376549e609219bc1e341247817"></a><!-- doxytag: member="viennacl::operator*" ref="a9a9af1376549e609219bc1e341247817" args="(matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the matrix by a GPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="a50b2b832ea2c80dd6266efc27cc483e8"></a><!-- doxytag: member="viennacl::operator*" ref="a50b2b832ea2c80dd6266efc27cc483e8" args="(const viennacl::matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy, const S1 &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt; S1 &gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const NumericT, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21d1613c4092dfdd5db6176f6d7ef7dc"></a><!-- doxytag: member="viennacl::operator*" ref="a21d1613c4092dfdd5db6176f6d7ef7dc" args="(const S1 &amp;val, const viennacl::matrix_expression&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__cpu__scalar.html">viennacl::is_cpu_scalar</a>&lt; S1 &gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">op_prod</a> &gt;, const NumericT, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a> &gt; &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7aa194ac845881167f06c7e690fbe8d0"></a><!-- doxytag: member="viennacl::operator*" ref="a7aa194ac845881167f06c7e690fbe8d0" args="(S1 const &amp;value, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1aa648c88a546872e66f73ae6b6f8c84"></a><!-- doxytag: member="viennacl::operator*" ref="a1aa648c88a546872e66f73ae6b6f8c84" args="(char value, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a char. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f6a0765c929401a06741a1c837a7af3"></a><!-- doxytag: member="viennacl::operator*" ref="a5f6a0765c929401a06741a1c837a7af3" args="(short value, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a short. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53f54b5071fc459f13261a08c0ea6ee5"></a><!-- doxytag: member="viennacl::operator*" ref="a53f54b5071fc459f13261a08c0ea6ee5" args="(int value, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a int. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a902d3e1f3473a758e15b232f07e7b11e"></a><!-- doxytag: member="viennacl::operator*" ref="a902d3e1f3473a758e15b232f07e7b11e" args="(long value, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a long. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The host scalar (float or double) </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac34b0528ba9cb2a8e586a64bafc3a1b1"></a><!-- doxytag: member="viennacl::operator*" ref="ac34b0528ba9cb2a8e586a64bafc3a1b1" args="(scalar_expression&lt; LHS, RHS, OP &gt; const &amp;expr, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a>&lt;LHS, RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">scalar_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a scalar expression and v1 is a ViennaCL vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The scalar expression </td></tr>
    <tr><td class="paramname">vec</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf62c14c5019cb0d0e51665e704a282f"></a><!-- doxytag: member="viennacl::operator*" ref="acf62c14c5019cb0d0e51665e704a282f" args="(vector_base&lt; T &gt; const &amp;vec, S1 const &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="a595de671ea4e3f2b0bb5eebb01458168"></a><!-- doxytag: member="viennacl::operator*" ref="a595de671ea4e3f2b0bb5eebb01458168" args="(vector_base&lt; T &gt; const &amp;vec, T const &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const T, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a409f3f32dff7d389aaae2556f8b2010a"></a><!-- doxytag: member="viennacl::operator*" ref="a409f3f32dff7d389aaae2556f8b2010a" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the right. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad16f8e922faecda1f3cdca04600b149c"></a><!-- doxytag: member="viennacl::operator*" ref="ad16f8e922faecda1f3cdca04600b149c" args="(S1 const &amp;val, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__mult.html">op_mult</a>&gt; &gt;::type viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a920e8836c8304945668799c249ef35c4"></a><!-- doxytag: member="viennacl::operator*=" ref="a920e8836c8304945668799c249ef35c4" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp; &gt;::type viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a matrix by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="a447eda4887f7373cd9214f7f452aa8ca"></a><!-- doxytag: member="viennacl::operator*=" ref="a447eda4887f7373cd9214f7f452aa8ca" args="(vector_base&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp; &gt;::type viennacl::operator*= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="ab85e3912a40d5d479835e7608808f07e"></a><!-- doxytag: member="viennacl::operator+" ref="ab85e3912a40d5d479835e7608808f07e" args="(viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result, const viennacl::vector_expression&lt; const SparseMatrixType, const viennacl::vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; &gt;::type viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The vector the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class holding v1, A, and v2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36a774cb277f1c9588168775f56a0ebf"></a><!-- doxytag: member="viennacl::operator+" ref="a36a774cb277f1c9588168775f56a0ebf" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;NumericT&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6e057825e16a810dd49dbb2b46e5e76"></a><!-- doxytag: member="viennacl::operator+" ref="ab6e057825e16a810dd49dbb2b46e5e76" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1467c3b3f6546172c178ac106513a1ae"></a><!-- doxytag: member="viennacl::operator+" ref="a1467c3b3f6546172c178ac106513a1ae" args="(matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep. </p>

</div>
</div>
<a class="anchor" id="ad31e53305db54fcf4483dec49674f440"></a><!-- doxytag: member="viennacl::operator+" ref="ad31e53305db54fcf4483dec49674f440" args="(matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa21f64d8b17b9c3a8891c584e882a4ca"></a><!-- doxytag: member="viennacl::operator+" ref="aa21f64d8b17b9c3a8891c584e882a4ca" args="(matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5372fd531482dd77aac96fba60b4538f"></a><!-- doxytag: member="viennacl::operator+" ref="a5372fd531482dd77aac96fba60b4538f" args="(const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a> &gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment. </p>

</div>
</div>
<a class="anchor" id="aa361d54076f354799e14cb209f9373e0"></a><!-- doxytag: member="viennacl::operator+" ref="aa361d54076f354799e14cb209f9373e0" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of two vector expressions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy1</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">proxy2</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a622a47e42369e2458b442e7dc2034579"></a><!-- doxytag: member="viennacl::operator+" ref="a622a47e42369e2458b442e7dc2034579" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a437c51256ab4916a56ecd2b5d26d08"></a><!-- doxytag: member="viennacl::operator+" ref="a3a437c51256ab4916a56ecd2b5d26d08" args="(vector_base&lt; T &gt; const &amp;vec, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__add.html">viennacl::op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector with a vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2471d058da27c2588866407382060cc0"></a><!-- doxytag: member="viennacl::operator+" ref="a2471d058da27c2588866407382060cc0" args="(const vector_base&lt; T &gt; &amp;v1, const vector_base&lt; T &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__add.html">op_add</a>&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template object for adding up two vectors, i.e. v1 + v2. </p>

</div>
</div>
<a class="anchor" id="a773db2ca4b258b74a575da40fbfda49b"></a><!-- doxytag: member="viennacl::operator+=" ref="a773db2ca4b258b74a575da40fbfda49b" args="(vector_base&lt; NumericT &gt; &amp;v1, const viennacl::vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector v1 where A * v2 is added to </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad648cd691bb8fa8358f552d00bce2946"></a><!-- doxytag: member="viennacl::operator+=" ref="ad648cd691bb8fa8358f552d00bce2946" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const LHS, const RHS, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;&amp; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const LHS, const RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae14e093250df58e8254f94e805c6a4f5"></a><!-- doxytag: member="viennacl::operator+=" ref="ae14e093250df58e8254f94e805c6a4f5" args="(vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator+= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 += A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector where the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5309df539f189a889f45f5e25098930f"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a5309df539f189a889f45f5e25098930f" args="(viennacl::vector_base&lt; SCALARTYPE &gt; &amp;result, const viennacl::vector_expression&lt; const SparseMatrixType, const viennacl::vector_base&lt; SCALARTYPE &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;SparseMatrixType&gt;::value, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; &gt;::type viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const SparseMatrixType, const <a class="el" href="classviennacl_1_1vector__base.html">viennacl::vector_base</a>&lt; SCALARTYPE &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The vector the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab30239ae5a61e50989e36802adb29d8f"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ab30239ae5a61e50989e36802adb29d8f" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;NumericT&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a934ba52bdd529f4aa5250f9db3225627"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a934ba52bdd529f4aa5250f9db3225627" args="(const vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a182bd38887779e44f6abfbd476538605"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a182bd38887779e44f6abfbd476538605" args="(matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d60c450a5eadd9178afbfde5cc9fd6e"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a2d60c450a5eadd9178afbfde5cc9fd6e" args="(matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS1, const RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa586c718254a15cf8326253a0d4fac8d"></a><!-- doxytag: member="viennacl::operator&#45;" ref="aa586c718254a15cf8326253a0d4fac8d" args="(matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS2, const RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bf54d540a468ff7b897e5b4d9b8b330"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a5bf54d540a468ff7b897e5b4d9b8b330" args="(const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a> &gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment. </p>

</div>
</div>
<a class="anchor" id="a327404c7cd8f4b58a6bc19cbc536a363"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a327404c7cd8f4b58a6bc19cbc536a363" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2&gt;, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of two vector expressions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy1</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">proxy2</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f50c049c1ba30ca5d5dab8b6a53d6dc"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a2f50c049c1ba30ca5d5dab8b6a53d6dc" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector_base&lt; T &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf453161e94700cbff1d38f14ccab626"></a><!-- doxytag: member="viennacl::operator&#45;" ref="aaf453161e94700cbff1d38f14ccab626" args="(vector_base&lt; T &gt; const &amp;vec, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, <a class="el" href="structviennacl_1_1op__sub.html">viennacl::op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of a vector expression with a vector or another vector expression. This is the default implementation for all cases that are too complex in order to be covered within a single kernel, hence a temporary vector is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">vec</td><td>Right hand side vector (also -range and -slice is allowed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2a0eb807884794e795aec5ec78353a4"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ab2a0eb807884794e795aec5ec78353a4" args="(const vector_base&lt; T &gt; &amp;v1, const vector_base&lt; T &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, <a class="el" href="structviennacl_1_1op__sub.html">op_sub</a>&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template object for subtracting two vectors, i.e. v1 - v2. </p>

</div>
</div>
<a class="anchor" id="aa5d425b543da3d12007eb98065137138"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="aa5d425b543da3d12007eb98065137138" args="(vector_base&lt; NumericT &gt; &amp;v1, const viennacl::vector_expression&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const matrix_base&lt; NumericT, F &gt;, const vector_base&lt; NumericT &gt;, <a class="el" href="structviennacl_1_1op__prod.html">viennacl::op_prod</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The result vector v1 where A * v2 is subtracted from </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e584237e084f29313d487917ceed47e"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a5e584237e084f29313d487917ceed47e" args="(vector_base&lt; T &gt; &amp;v1, const vector_expression&lt; const LHS, const RHS, OP &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;&amp; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const LHS, const RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9672a2d4e157a13683bc2bbe7d315f15"></a><!-- doxytag: member="viennacl::operator&#45;=" ref="a9672a2d4e157a13683bc2bbe7d315f15" args="(vector_base&lt; NumericT &gt; &amp;v1, const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;NumericT&gt; viennacl::operator-= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; NumericT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_expression&lt; const matrix_expression&lt; const matrix_base&lt; NumericT, F &gt;, const matrix_base&lt; NumericT, F &gt;, op_trans &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 -= A * v2, where A is a matrix. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The addend vector where the result is written to. </td></tr>
    <tr><td class="paramname">proxy</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb7c2e69a5e9e6d41ee3b651605b9750"></a><!-- doxytag: member="viennacl::operator/" ref="afb7c2e69a5e9e6d41ee3b651605b9750" args="(matrix_expression&lt; const LHS, const RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt;const LHS, const RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_expression&lt; const LHS, const RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then divided by alpha. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side matrix expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc8e629b037b3ae3dd4dccf7fd277250"></a><!-- doxytag: member="viennacl::operator/" ref="acc8e629b037b3ae3dd4dccf7fd277250" args="(matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template for scaling the matrix by a GPU scalar 'alpha'. </p>

</div>
</div>
<a class="anchor" id="a33caa6103aea5a99f9d95f041c5cd52a"></a><!-- doxytag: member="viennacl::operator/" ref="a33caa6103aea5a99f9d95f041c5cd52a" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt;LHS, RHS, OP&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then divided by alpha. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Left hand side vector expression </td></tr>
    <tr><td class="paramname">val</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a479f8bc932a3b68dbd4716a0766124f9"></a><!-- doxytag: member="viennacl::operator/" ref="a479f8bc932a3b68dbd4716a0766124f9" args="(vector_base&lt; T &gt; const &amp;v1, S1 const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt;, const S1, <a class="el" href="structviennacl_1_1op__div.html">op_div</a>&gt; &gt;::type viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template for scaling the vector by a GPU scalar 'alpha'. </p>

</div>
</div>
<a class="anchor" id="a2949cf07f6b1bb423de3f634d4b49453"></a><!-- doxytag: member="viennacl::operator/=" ref="a2949cf07f6b1bb423de3f634d4b49453" args="(matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt; &amp; &gt;::type viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a matrix by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="a5911b2abc96a555d3c20855f645441ac"></a><!-- doxytag: member="viennacl::operator/=" ref="a5911b2abc96a555d3c20855f645441ac" args="(vector_base&lt; T &gt; &amp;v1, S1 const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt;S1&gt;::value, <a class="el" href="classviennacl_1_1vector__base.html">vector_base</a>&lt;T&gt; &amp; &gt;::type viennacl::operator/= </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1 const &amp;&#160;</td>
          <td class="paramname"><em>gpu_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="af9a32a60b002b21a968695892e5e564b"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="af9a32a60b002b21a968695892e5e564b" args="(std::ostream &amp;s, vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vandermonde_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL Vandermonde matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62d454e7d9e7b376258fdf34e20e538b"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a62d454e7d9e7b376258fdf34e20e538b" args="(std::ostream &amp;s, hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hankel_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1febce45965241500ed60feeaf290dec"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a1febce45965241500ed60feeaf290dec" args="(std::ostream &amp;s, circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">circulant_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL circulant matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0150a5d176ba2a924ffa44b65287f460"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a0150a5d176ba2a924ffa44b65287f460" args="(std::ostream &amp;s, toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">toeplitz_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A ViennaCL Toeplitz matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb593bb1abab989d5396c3196ba4ff01"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="aeb593bb1abab989d5396c3196ba4ff01" args="(std::ostream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly print the value of a scalar to an output stream. </p>

</div>
</div>
<a class="anchor" id="aea303edb50bfe8b43d5591d62abd690d"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="aea303edb50bfe8b43d5591d62abd690d" args="(std::ostream &amp;s, const matrix_base&lt; SCALARTYPE, F &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_base&lt; SCALARTYPE, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">gpu_matrix</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c1627d47e4b494526e0287de3ed8476"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a6c1627d47e4b494526e0287de3ed8476" args="(std::ostream &amp;s, const matrix_expression&lt; LHS, RHS, OP &gt; &amp;expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; LHS, RHS, OP &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>STL output stream </td></tr>
    <tr><td class="paramname">expr</td><td>A matrix expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab305fb97f519cb1280277cf830e3dfce"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="ab305fb97f519cb1280277cf830e3dfce" args="(std::ostream &amp;os, vector_base&lt; T &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output stream. Output format is ublas compatible. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>STL output stream </td></tr>
    <tr><td class="paramname">val</td><td>The vector that should be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21669e48cbc9c19811088f65b1162c1c"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a21669e48cbc9c19811088f65b1162c1c" args="(std::ostream &amp;os, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4143bdeffd1dc0aa102777fb6179747"></a><!-- doxytag: member="viennacl::operator&gt;&gt;" ref="ad4143bdeffd1dc0aa102777fb6179747" args="(std::istream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; viennacl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly read a value of a scalar from an input stream. </p>

</div>
</div>
<a class="anchor" id="aaa422ff6bca0f275c38493e68cfb6ab7"></a><!-- doxytag: member="viennacl::project" ref="aaa422ff6bca0f275c38493e68cfb6ab7" args="(VectorType &amp;vec, viennacl::range const &amp;r1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4abd13449f84ae5f2a83d1ebd144d37f"></a><!-- doxytag: member="viennacl::project" ref="a4abd13449f84ae5f2a83d1ebd144d37f" args="(viennacl::vector_range&lt; VectorType &gt; &amp;vec, viennacl::range const &amp;r1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__range.html">vector_range</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f562ecf4d6f6591fd3978d857c195b2"></a><!-- doxytag: member="viennacl::project" ref="a3f562ecf4d6f6591fd3978d857c195b2" args="(VectorType &amp;vec, viennacl::slice const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a282a337b4b56bb137484bae8ac82200a"></a><!-- doxytag: member="viennacl::project" ref="a282a337b4b56bb137484bae8ac82200a" args="(viennacl::vector_slice&lt; VectorType &gt; &amp;vec, viennacl::slice const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba33e920e51c7697bb559ff3eade9019"></a><!-- doxytag: member="viennacl::project" ref="aba33e920e51c7697bb559ff3eade9019" args="(MatrixType &amp;A, viennacl::range const &amp;r1, viennacl::range const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cd756eaf11b7a342d350e569d20c01c"></a><!-- doxytag: member="viennacl::project" ref="a0cd756eaf11b7a342d350e569d20c01c" args="(viennacl::vector_slice&lt; VectorType &gt; &amp;vec, viennacl::range const &amp;r1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__slice.html">viennacl::vector_slice</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af97f37bc5782032f5d48aa7d69e00612"></a><!-- doxytag: member="viennacl::project" ref="af97f37bc5782032f5d48aa7d69e00612" args="(matrix_range&lt; MatrixType &gt; &amp;A, viennacl::range const &amp;r1, viennacl::range const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__range.html">matrix_range</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#ad718fa2d632fcefa865374e0a4094d14">viennacl::range</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9d4327108630e688f72f2c135a809a9"></a><!-- doxytag: member="viennacl::project" ref="ac9d4327108630e688f72f2c135a809a9" args="(viennacl::vector_range&lt; VectorType &gt; &amp;vec, viennacl::slice const &amp;s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__slice.html">vector_slice</a>&lt;VectorType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__range.html">viennacl::vector_range</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>s1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad843d07ca697041a7bb42656644c7ef9"></a><!-- doxytag: member="viennacl::project" ref="ad843d07ca697041a7bb42656644c7ef9" args="(MatrixType &amp;A, viennacl::slice const &amp;r1, viennacl::slice const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a7f5b8c12a1e8b2b5a278173414f330"></a><!-- doxytag: member="viennacl::project" ref="a3a7f5b8c12a1e8b2b5a278173414f330" args="(matrix_range&lt; MatrixType &gt; &amp;A, viennacl::slice const &amp;r1, viennacl::slice const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_range&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad17914cefb71411c1c616c8ca21c4342"></a><!-- doxytag: member="viennacl::project" ref="ad17914cefb71411c1c616c8ca21c4342" args="(matrix_slice&lt; MatrixType &gt; &amp;A, viennacl::slice const &amp;r1, viennacl::slice const &amp;r2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__slice.html">matrix_slice</a>&lt;MatrixType&gt; <a class="el" href="namespaceviennacl.html#aba33e920e51c7697bb559ff3eade9019">viennacl::project</a> </td>
          <td>(</td>
          <td class="paramtype">matrix_slice&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceviennacl.html#a0242f7747dc5e72cf3265e18287b6b5c">viennacl::slice</a> const &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acec126e71833e0756286cbf8cd036fbd"></a><!-- doxytag: member="viennacl::reorder" ref="acec126e71833e0756286cbf8cd036fbd" args="(MatrixType const &amp;matrix, gibbs_poole_stockmeyer_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="namespaceviennacl.html#af22338e452cee008bee5e38070ddc611">viennacl::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gibbs_poole_stockmeyer_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for the calculation of a node numbering permutation vector to reduce the bandwidth of a incidence matrix by the Gibbs-Poole-Stockmeyer algorithm. </p>
<p>references: Werner Neudorf: "Bandbreitenreduktion - Teil 3. Algorithmus von
   Gibbs-Poole-Stockmeyer. Testbeispiele mit CM und GPS", Preprint No. M 08/02, September 2002. Technische Universitt Ilmenau, Fakultt fr Mathematik und Naturwissenschaften, Institut fr Mathematik. <a href="http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-8673/IfM_Preprint_M_02_08.pdf">http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-8673/IfM_Preprint_M_02_08.pdf</a> (URL taken on June 14, 2011)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>vector of n matrix rows, where each row is a map&lt;int, double&gt; containing only the nonzero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>permutation vector r. r[l] = i means that the new label of node i will be l. </dd></dl>

</div>
</div>
<a class="anchor" id="af22338e452cee008bee5e38070ddc611"></a><!-- doxytag: member="viennacl::reorder" ref="af22338e452cee008bee5e38070ddc611" args="(std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;matrix, cuthill_mckee_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;IndexT&gt; <a class="el" href="namespaceviennacl.html#af22338e452cee008bee5e38070ddc611">viennacl::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cuthill_mckee_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the Cuthill-McKee algorithm. </p>
<p>references: Algorithm was implemented similary as described in "Tutorial: Bandwidth Reduction - The CutHill-
      McKee Algorithm" posted by Ciprian Zavoianu as weblog at <a href="http://ciprian-zavoianu.blogspot.com/2009/01/project-bandwidth-reduction.html">http://ciprian-zavoianu.blogspot.com/2009/01/project-bandwidth-reduction.html</a> on January 15, 2009 (URL taken on June 14, 2011)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>vector of n matrix rows, where each row is a map&lt;int, double&gt; containing only the nonzero elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>permutation vector r. r[l] = i means that the new label of node i will be l. </dd></dl>

</div>
</div>
<a class="anchor" id="a032f691cd245d13b51b951f8a10825f3"></a><!-- doxytag: member="viennacl::reorder" ref="a032f691cd245d13b51b951f8a10825f3" args="(std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;matrix, advanced_cuthill_mckee_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;IndexT&gt; <a class="el" href="namespaceviennacl.html#af22338e452cee008bee5e38070ddc611">viennacl::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; IndexT, ValueT &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">advanced_cuthill_mckee_tag const &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for the calculation of a node number permutation to reduce the bandwidth of an incidence matrix by the advanced Cuthill-McKee algorithm. </p>
<p>references: see description of original Cuthill McKee implementation, and E. Cuthill and J. McKee: "Reducing the Bandwidth of sparse symmetric Matrices". Naval Ship Research and Development Center, Washington, D. C., 20007 </p>

</div>
</div>
<a class="anchor" id="a0a574e6cd04ca0e42298b4ab845700e4"></a><!-- doxytag: member="viennacl::row" ref="a0a574e6cd04ca0e42298b4ab845700e4" args="(const matrix_base&lt; NumericT, F &gt; &amp;A, unsigned int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const unsigned int, <a class="el" href="structviennacl_1_1op__row.html">op_row</a>&gt; <a class="el" href="namespaceviennacl.html#a0a574e6cd04ca0e42298b4ab845700e4">viennacl::row</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a49233dc20718f52e98e8b06e9711b375"></a><!-- doxytag: member="viennacl::swap" ref="a49233dc20718f52e98e8b06e9711b375" args="(vector_base&lt; T &gt; &amp;vec1, vector_base&lt; T &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a49233dc20718f52e98e8b06e9711b375">viennacl::swap</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>The first vector </td></tr>
    <tr><td class="paramname">vec2</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87d41d517b3d0daca8b1536e15e6659d"></a><!-- doxytag: member="viennacl::switch_memory_context" ref="a87d41d517b3d0daca8b1536e15e6659d" args="(T &amp;obj, viennacl::context new_ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceviennacl.html#a87d41d517b3d0daca8b1536e15e6659d">viennacl::switch_memory_context</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1context.html">viennacl::context</a>&#160;</td>
          <td class="paramname"><em>new_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic convenience routine for migrating data of an object to a new memory domain. </p>

</div>
</div>
<a class="anchor" id="a18c575b08038eb6af18fe1b89e4022ba"></a><!-- doxytag: member="viennacl::tie" ref="a18c575b08038eb6af18fe1b89e4022ba" args="(vector_base&lt; ScalarT &gt; const &amp;v0, vector_base&lt; ScalarT &gt; const &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab25260434dfe3c4c527fd2a9ae437685"></a><!-- doxytag: member="viennacl::tie" ref="ab25260434dfe3c4c527fd2a9ae437685" args="(vector_base&lt; ScalarT &gt; &amp;v0, vector_base&lt; ScalarT &gt; &amp;v1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee58be5508bb77871fc653aa8b33f3e2"></a><!-- doxytag: member="viennacl::tie" ref="aee58be5508bb77871fc653aa8b33f3e2" args="(vector_base&lt; ScalarT &gt; const &amp;v0, vector_base&lt; ScalarT &gt; const &amp;v1, vector_base&lt; ScalarT &gt; const &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a56eeda7139441461f48c7303ad1b4b44"></a><!-- doxytag: member="viennacl::tie" ref="a56eeda7139441461f48c7303ad1b4b44" args="(vector_base&lt; ScalarT &gt; &amp;v0, vector_base&lt; ScalarT &gt; &amp;v1, vector_base&lt; ScalarT &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae7d28ebaf25043e36652c5ef210d405a"></a><!-- doxytag: member="viennacl::tie" ref="ae7d28ebaf25043e36652c5ef210d405a" args="(vector_base&lt; ScalarT &gt; const &amp;v0, vector_base&lt; ScalarT &gt; const &amp;v1, vector_base&lt; ScalarT &gt; const &amp;v2, vector_base&lt; ScalarT &gt; const &amp;v3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0250b6a52a40df48e3ee18f1db6e4747"></a><!-- doxytag: member="viennacl::tie" ref="a0250b6a52a40df48e3ee18f1db6e4747" args="(vector_base&lt; ScalarT &gt; &amp;v0, vector_base&lt; ScalarT &gt; &amp;v1, vector_base&lt; ScalarT &gt; &amp;v2, vector_base&lt; ScalarT &gt; &amp;v3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e40b38f92dd9f2b23f8fa134da43204"></a><!-- doxytag: member="viennacl::tie" ref="a8e40b38f92dd9f2b23f8fa134da43204" args="(vector_base&lt; ScalarT &gt; const &amp;v0, vector_base&lt; ScalarT &gt; const &amp;v1, vector_base&lt; ScalarT &gt; const &amp;v2, vector_base&lt; ScalarT &gt; const &amp;v3, vector_base&lt; ScalarT &gt; const &amp;v4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac96d28a81e8e227f2678360fbdd92ae1"></a><!-- doxytag: member="viennacl::tie" ref="ac96d28a81e8e227f2678360fbdd92ae1" args="(vector_base&lt; ScalarT &gt; &amp;v0, vector_base&lt; ScalarT &gt; &amp;v1, vector_base&lt; ScalarT &gt; &amp;v2, vector_base&lt; ScalarT &gt; &amp;v3, vector_base&lt; ScalarT &gt; &amp;v4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__tuple.html">vector_tuple</a>&lt;ScalarT&gt; <a class="el" href="namespaceviennacl.html#a18c575b08038eb6af18fe1b89e4022ba">viennacl::tie</a> </td>
          <td>(</td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_base&lt; ScalarT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ee5dd77d41040e0a937a60346475b84"></a><!-- doxytag: member="viennacl::trans" ref="a2ee5dd77d41040e0a937a60346475b84" args="(const M1 &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a>&lt;<a class="el" href="structviennacl_1_1is__any__sparse__matrix.html">viennacl::is_any_sparse_matrix</a>&lt;M1&gt;::value, <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const M1, const M1, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a>&gt; &gt;::type <a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">viennacl::trans</a> </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

</div>
</div>
<a class="anchor" id="a0250af0917fd1088eb339e3550964954"></a><!-- doxytag: member="viennacl::trans" ref="a0250af0917fd1088eb339e3550964954" args="(const matrix_base&lt; NumericT, F &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, const <a class="el" href="classviennacl_1_1matrix__base.html">matrix_base</a>&lt;NumericT, F&gt;, <a class="el" href="structviennacl_1_1op__trans.html">op_trans</a>&gt; <a class="el" href="namespaceviennacl.html#a2ee5dd77d41040e0a937a60346475b84">viennacl::trans</a> </td>
          <td>(</td>
          <td class="paramtype">const matrix_base&lt; NumericT, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:37 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
