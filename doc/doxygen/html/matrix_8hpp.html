<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/matrix.hpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">viennacl/matrix.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the dense matrix class.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="forwards_8h_source.html">viennacl/forwards.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="scalar_8hpp_source.html">viennacl/scalar.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="vector_8hpp_source.html">viennacl/vector.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="matrix__operations_8hpp_source.html">viennacl/linalg/matrix_operations.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sparse__matrix__operations_8hpp_source.html">viennacl/linalg/sparse_matrix_operations.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tools_8hpp_source.html">viennacl/tools/tools.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="matrix__size__deducer_8hpp_source.html">viennacl/tools/matrix_size_deducer.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="result__of_8hpp_source.html">viennacl/meta/result_of.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="enable__if_8hpp_source.html">viennacl/meta/enable_if.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="traits_2handle_8hpp_source.html">viennacl/traits/handle.hpp</a>&quot;</code><br/>
</div>
<p><a href="matrix_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1implicit__matrix__base.html">implicit_matrix_base&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for representing matrices where the individual entries are not all stored explicitly, e.g. identity_matrix&lt;&gt;  <a href="classviennacl_1_1implicit__matrix__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1identity__matrix.html">identity_matrix&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of 1 at a given index and zeros otherwise. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1identity__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1zero__matrix.html">zero_matrix&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of zeros only. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1zero__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__matrix.html">scalar_matrix&lt; SCALARTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector consisting of scalars 's' only, i.e. v[i] = s for all i. To be used as an initializer for <a class="el" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector</a>, <a class="el" href="classviennacl_1_1vector__range.html" title="Class for representing non-strided subvectors of a bigger vector x.">vector_range</a>, or vector_slize only.  <a href="classviennacl_1_1scalar__matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression&lt; LHS, RHS, OP &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression template class for representing a tree of expressions which ultimately result in a matrix.  <a href="classviennacl_1_1matrix__expression.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator&lt; ROWCOL, MATRIXTYPE &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">uBLAS-like iterator class for iterating over the entries of a dense matrix.  <a href="classviennacl_1_1matrix__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__base.html">matrix_base&lt; SCALARTYPE, F, SizeType, DistanceType &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix__base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html">viennacl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Main namespace in ViennaCL. Holds all the basic types such as vector, matrix, etc. and defines operations upon them. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aea303edb50bfe8b43d5591d62abd690d">operator&lt;&lt;</a> (std::ostream &amp;s, const matrix_base&lt; SCALARTYPE, F &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#aea303edb50bfe8b43d5591d62abd690d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6c1627d47e4b494526e0287de3ed8476">operator&lt;&lt;</a> (std::ostream &amp;s, const matrix_expression&lt; LHS, RHS, OP &gt; &amp;expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#a6c1627d47e4b494526e0287de3ed8476"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, op_trans &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0250af0917fd1088eb339e3550964954">trans</a> (const matrix_base&lt; NumericT, F &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a0250af0917fd1088eb339e3550964954"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const int, op_matrix_diag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad459d800c7d2ca780bd3ecd21941dc24">diag</a> (const matrix_base&lt; NumericT, F &gt; &amp;A, int k=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
vector_base&lt; NumericT &gt;, const <br class="typebreak"/>
int, op_vector_diag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a96df6ab1bb59ee2c6e540694639d27">diag</a> (const vector_base&lt; NumericT &gt; &amp;v, int k=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const unsigned int, op_row &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0a574e6cd04ca0e42298b4ab845700e4">row</a> (const matrix_base&lt; NumericT, F &gt; &amp;A, unsigned int i)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">vector_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const unsigned int, <br class="typebreak"/>
op_column &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7fca08f4a83edffe7f47666d298ca87d">column</a> (const matrix_base&lt; NumericT, F &gt; &amp;A, unsigned int j)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3728d51018413682b2c807cb26fe0ce6">copy</a> (const CPU_MATRIX &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#a3728d51018413682b2c807cb26fe0ce6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aba57054849e1adf3cd627b22d8512b75">copy</a> (const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU)  <a href="#aba57054849e1adf3cd627b22d8512b75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6fe9c1c3ea45c54d92082b1805790e80">fast_copy</a> (SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU.  <a href="#a6fe9c1c3ea45c54d92082b1805790e80"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad655c8cbb96bf07d2348309a2656799e">copy</a> (const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#ad655c8cbb96bf07d2348309a2656799e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aab87e45b79097799bbaabeed1e240ace">copy</a> (const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#aab87e45b79097799bbaabeed1e240ace"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a67d05f6ec18b2d7c2051eb4f6b47b5a7">fast_copy</a> (const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a67d05f6ec18b2d7c2051eb4f6b47b5a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_expression&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
matrix_expression&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a1467c3b3f6546172c178ac106513a1ae">operator+</a> (matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic 'catch-all' overload, which enforces a temporary if the expression tree gets too deep.  <a href="#a1467c3b3f6546172c178ac106513a1ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_expression&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad31e53305db54fcf4483dec49674f440">operator+</a> (matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_expression<br class="typebreak"/>
&lt; const LHS2, const RHS2, OP2 &gt;<br class="typebreak"/>
, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa21f64d8b17b9c3a8891c584e882a4ca">operator+</a> (matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, op_add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5372fd531482dd77aac96fba60b4538f">operator+</a> (const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 + m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5372fd531482dd77aac96fba60b4538f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_expression&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
matrix_expression&lt; const LHS2, <br class="typebreak"/>
const RHS2, OP2 &gt;, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a182bd38887779e44f6abfbd476538605">operator-</a> (matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_expression&lt; const LHS1, <br class="typebreak"/>
const RHS1, OP1 &gt;, const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2d60c450a5eadd9178afbfde5cc9fd6e">operator-</a> (matrix_expression&lt; const LHS1, const RHS1, OP1 &gt; const &amp;proxy1, matrix_base&lt; NumericT, F &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_expression<br class="typebreak"/>
&lt; const LHS2, const RHS2, OP2 &gt;<br class="typebreak"/>
, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa586c718254a15cf8326253a0d4fac8d">operator-</a> (matrix_base&lt; NumericT, F &gt; const &amp;proxy1, matrix_expression&lt; const LHS2, const RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">matrix_expression&lt; const <br class="typebreak"/>
matrix_base&lt; NumericT, F &gt;<br class="typebreak"/>
, const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, op_sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5bf54d540a468ff7b897e5b4d9b8b330">operator-</a> (const matrix_base&lt; NumericT, F &gt; &amp;m1, const matrix_base&lt; NumericT, F &gt; &amp;m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for m1 - m2, where m1 and m2 are either dense matrices, matrix ranges, or matrix slices. No mixing of different storage layouts allowed at the moment.  <a href="#a5bf54d540a468ff7b897e5b4d9b8b330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename NumericT , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_mult &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad2dd7a1271ffad8b38aa15d24c47f0cc">operator*</a> (S1 const &amp;value, matrix_base&lt; NumericT, F &gt; const &amp;m1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the expression alpha * m1, where alpha is a host scalar (float or double) and m1 is a ViennaCL matrix.  <a href="#ad2dd7a1271ffad8b38aa15d24c47f0cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, op_mult &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9a515a15cb3bffa56339f894312d7a0a">operator*</a> (matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a scalar from the right, e.g. (beta * m1) * alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the right.  <a href="#a9a515a15cb3bffa56339f894312d7a0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression&lt; LHS, <br class="typebreak"/>
RHS, OP &gt;, const S1, op_mult &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2189d7a68eacf7ebf7d7ec97e3430a4e">operator*</a> (S1 const &amp;val, matrix_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the multiplication of a matrix expression with a ViennaCL scalar from the left, e.g. alpha * (beta * m1). Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then multiplied with alpha from the left.  <a href="#a2189d7a68eacf7ebf7d7ec97e3430a4e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_mult &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9a9af1376549e609219bc1e341247817">operator*</a> (matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the matrix by a GPU scalar 'alpha' and returns an expression template.  <a href="#a9a9af1376549e609219bc1e341247817"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a920e8836c8304945668799c249ef35c4">operator*=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a920e8836c8304945668799c249ef35c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_expression<br class="typebreak"/>
&lt; const LHS, const RHS, OP &gt;<br class="typebreak"/>
, const S1, op_div &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afb7c2e69a5e9e6d41ee3b651605b9750">operator/</a> (matrix_expression&lt; const LHS, const RHS, OP &gt; const &amp;proxy, S1 const &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for the division of a matrix expression by a scalar from the right, e.g. (beta * m1) / alpha. Here, beta * m1 is wrapped into a <a class="el" href="classviennacl_1_1matrix__expression.html" title="Expression template class for representing a tree of expressions which ultimately result in a matrix...">matrix_expression</a> and then divided by alpha.  <a href="#afb7c2e69a5e9e6d41ee3b651605b9750"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__any__scalar.html">viennacl::is_any_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_expression<br class="typebreak"/>
&lt; const matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt;, const S1, op_div &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#acc8e629b037b3ae3dd4dccf7fd277250">operator/</a> (matrix_base&lt; NumericT, F &gt; const &amp;m1, S1 const &amp;s1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression template for scaling the matrix by a GPU scalar 'alpha'.  <a href="#acc8e629b037b3ae3dd4dccf7fd277250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename F , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, matrix_base&lt; NumericT, <br class="typebreak"/>
F &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2949cf07f6b1bb423de3f634d4b49453">operator/=</a> (matrix_base&lt; NumericT, F &gt; &amp;m1, S1 const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a GPU scalar value.  <a href="#a2949cf07f6b1bb423de3f634d4b49453"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;, const S1, op_mult &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a50b2b832ea2c80dd6266efc27cc483e8">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy, const S1 &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename S1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennacl_1_1enable__if.html">viennacl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennacl_1_1is__scalar.html">viennacl::is_scalar</a>&lt; S1 &gt;<br class="typebreak"/>
::value, <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, const vector_base&lt; NumericT &gt;<br class="typebreak"/>
, op_prod &gt;, const S1, op_mult &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a21d1613c4092dfdd5db6176f6d7ef7dc">operator*</a> (const S1 &amp;val, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const vector_base&lt; NumericT &gt;, const vector_base&lt; NumericT &gt;, op_prod &gt; &amp;proxy)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation of the dense matrix class. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:37 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
