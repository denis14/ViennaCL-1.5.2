<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ViennaCL - The Vienna Computing Library: viennacl/generator/generate.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ViennaCL - The Vienna Computing Library
   &#160;<span id="projectnumber">1.5.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">viennacl/generator/generate.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="generate_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNACL_GENERATOR_GENERATE_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNACL_GENERATOR_GENERATE_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =========================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2010-2014, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                            Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                            TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">   Portions of this software are copyright by UChicago Argonne, LLC.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">                            -----------------</span>
<a name="l00011"></a>00011 <span class="comment">                  ViennaCL - The Vienna Computing Library</span>
<a name="l00012"></a>00012 <span class="comment">                            -----------------</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   (A list of authors and contributors can be found in the PDF manual)</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   License:         MIT (X11), see file LICENSE in the base directory</span>
<a name="l00019"></a>00019 <span class="comment">============================================================================= */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="scheduler_2forwards_8h.html" title="Provides the datastructures for dealing with a single statement such as &#39;x = y + z;&#39;.">viennacl/scheduler/forwards.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="generator_2forwards_8h.html" title="Forwards declaration.">viennacl/generator/forwards.h</a>&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="profiles_8hpp.html" title="Vendor-specific parameters for the generated kernels.">viennacl/generator/profiles.hpp</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="statement__representation__functor_8hpp.html" title="Functor to generate the string id of a statement.">viennacl/generator/statement_representation_functor.hpp</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="set__arguments__functor_8hpp.html" title="Functor to set the arguments of a statement into a kernel.">viennacl/generator/set_arguments_functor.hpp</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="map__functor_8hpp.html" title="Functor to map the statements to the types defined in mapped_objects.hpp.">viennacl/generator/map_functor.hpp</a>&quot;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html" title="Various little tools used here and there in ViennaCL.">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">namespace </span>viennacl{
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   <span class="keyword">namespace </span>generator{
<a name="l00043"></a>00043 
<a name="l00047"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html">00047</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1generator_1_1code__generator.html" title="Class for handling code generation.">code_generator</a>{
<a name="l00048"></a>00048       <span class="keyword">public</span>:
<a name="l00050"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8c5fa5bac74cbea8b879286843c30f94">00050</a>         <span class="keyword">typedef</span> std::pair&lt;expression_type, vcl_size_t&gt; <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8c5fa5bac74cbea8b879286843c30f94" title="typedef of the key used in the forced profiles. Contains the expression type and the size of the scal...">forced_profile_key_type</a>;
<a name="l00051"></a>00051       <span class="keyword">private</span>:
<a name="l00052"></a>00052         <span class="keyword">typedef</span> std::pair&lt;expression_descriptor, generator::profile_base::statements_type&gt; representation_node_type;
<a name="l00053"></a>00053         <span class="keyword">typedef</span> std::vector&lt;representation_node_type&gt; statements_type;
<a name="l00054"></a>00054         <span class="keyword">typedef</span> std::map&lt;forced_profile_key_type, tools::shared_ptr&lt;profile_base&gt; &gt; forced_profiles_type;
<a name="l00055"></a>00055 
<a name="l00060"></a>00060         <span class="keyword">static</span> <span class="keywordtype">bool</span> is_flow_transposed(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node){
<a name="l00061"></a>00061           <a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a87693159a33a82fd76f7eecf9b7d7a5a">viennacl::scheduler::statement::container_type</a> <span class="keyword">const</span> &amp; expr = statement.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>();
<a name="l00062"></a>00062           <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4ab2503ebf15d4f9e756eb9bff91bc6997">viennacl::scheduler::OPERATION_UNARY_TRANS_TYPE</a>)
<a name="l00063"></a>00063             <span class="keywordflow">return</span> root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#ad6eff2deb1f6a769f32ad1c8a9362732">subtype</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#a4878451ecc367ff7a3aef3243d8e6564aaf3fe03a1d4204342f4dcd9c01f97082">viennacl::scheduler::DENSE_ROW_MATRIX_TYPE</a>;
<a name="l00064"></a>00064           <span class="keywordflow">else</span>{
<a name="l00065"></a>00065             <span class="keywordtype">bool</span> res = root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#ad6eff2deb1f6a769f32ad1c8a9362732">subtype</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#a4878451ecc367ff7a3aef3243d8e6564a696cebd4bfcd0668e646e332fa7ba112">viennacl::scheduler::DENSE_COL_MATRIX_TYPE</a> || root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#ad6eff2deb1f6a769f32ad1c8a9362732">subtype</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#a4878451ecc367ff7a3aef3243d8e6564a696cebd4bfcd0668e646e332fa7ba112">viennacl::scheduler::DENSE_COL_MATRIX_TYPE</a>;
<a name="l00066"></a>00066             <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00067"></a>00067               res = res || is_lhs_flow_transposed(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>]);
<a name="l00068"></a>00068             <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00069"></a>00069               res = res || is_lhs_flow_transposed(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>]);
<a name="l00070"></a>00070             <span class="keywordflow">return</span> res;
<a name="l00071"></a>00071           }
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 
<a name="l00075"></a>00075         <span class="keyword">static</span> <span class="keywordtype">bool</span> is_lhs_flow_transposed(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node){
<a name="l00076"></a>00076           <a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a87693159a33a82fd76f7eecf9b7d7a5a">scheduler::statement::container_type</a> <span class="keyword">const</span> &amp; expr = statement.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>();
<a name="l00077"></a>00077           <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00078"></a>00078             <span class="keywordflow">return</span> is_flow_transposed(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>]);
<a name="l00079"></a>00079           <span class="keywordflow">else</span>
<a name="l00080"></a>00080             <span class="keywordflow">return</span> root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#ad6eff2deb1f6a769f32ad1c8a9362732">subtype</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#a4878451ecc367ff7a3aef3243d8e6564a696cebd4bfcd0668e646e332fa7ba112">viennacl::scheduler::DENSE_COL_MATRIX_TYPE</a>;
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00084"></a>00084         <span class="keyword">static</span> <span class="keywordtype">bool</span> is_rhs_flow_transposed(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node){
<a name="l00085"></a>00085           <a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a87693159a33a82fd76f7eecf9b7d7a5a">viennacl::scheduler::statement::container_type</a> <span class="keyword">const</span> &amp; expr = statement.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>();
<a name="l00086"></a>00086           <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00087"></a>00087             <span class="keywordflow">return</span> is_flow_transposed(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>]);
<a name="l00088"></a>00088           <span class="keywordflow">else</span>
<a name="l00089"></a>00089             <span class="keywordflow">return</span> root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#ad6eff2deb1f6a769f32ad1c8a9362732">subtype</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#a4878451ecc367ff7a3aef3243d8e6564a696cebd4bfcd0668e646e332fa7ba112">viennacl::scheduler::DENSE_COL_MATRIX_TYPE</a>;
<a name="l00090"></a>00090         }
<a name="l00091"></a>00091 
<a name="l00093"></a>00093         <span class="keyword">static</span> <span class="keywordtype">void</span> fill_expression_descriptor_scalar(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node, expression_descriptor &amp; descriptor){
<a name="l00094"></a>00094           <a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a87693159a33a82fd76f7eecf9b7d7a5a">viennacl::scheduler::statement::container_type</a> <span class="keyword">const</span> &amp; expr = statement.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>();
<a name="l00095"></a>00095           <span class="keywordtype">bool</span> is_invalid = (root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a369b1f0ad2c9de8c615a5bf43667dd79">viennacl::scheduler::OPERATION_BINARY_MAT_VEC_PROD_TYPE</a>)
<a name="l00096"></a>00096                           || (descriptor.type_family==<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3aa7a1f4925b0d7d3ba5d0953334e982e7">SCALAR_REDUCE_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a3cf4aef5fe9853d7eb9da2fa9ce13d68">viennacl::scheduler::OPERATION_BINARY_INNER_PROD_TYPE</a>);
<a name="l00097"></a>00097           <span class="keywordflow">if</span>(is_invalid){
<a name="l00098"></a>00098             descriptor.type_family = <a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a>;
<a name="l00099"></a>00099             descriptor.type = <a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa0c9d88cab8c5980f26826a4bcc04b25a">INVALID_EXPRESSION_TYPE</a>;
<a name="l00100"></a>00100           }
<a name="l00101"></a>00101           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a3cf4aef5fe9853d7eb9da2fa9ce13d68">viennacl::scheduler::OPERATION_BINARY_INNER_PROD_TYPE</a>){
<a name="l00102"></a>00102             descriptor.type_family = <a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3aa7a1f4925b0d7d3ba5d0953334e982e7">SCALAR_REDUCE_FAMILY</a>;
<a name="l00103"></a>00103             descriptor.type = <a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa51af6fec1c96d49b984cf27da82c2650">SCALAR_REDUCE_TYPE</a>;
<a name="l00104"></a>00104           }
<a name="l00105"></a>00105           <span class="keywordflow">if</span>(descriptor.type_family!=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00106"></a>00106             fill_expression_descriptor_scalar(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>],descriptor);
<a name="l00107"></a>00107           <span class="keywordflow">if</span>(descriptor.type_family!=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00108"></a>00108             fill_expression_descriptor_scalar(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>],descriptor);
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110 
<a name="l00112"></a>00112         <span class="keyword">static</span> <span class="keywordtype">void</span> fill_expression_descriptor_vector(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node, expression_descriptor &amp; descriptor){
<a name="l00113"></a>00113           <a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a87693159a33a82fd76f7eecf9b7d7a5a">viennacl::scheduler::statement::container_type</a> <span class="keyword">const</span> &amp; expr = statement.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>();
<a name="l00114"></a>00114           <span class="keywordtype">bool</span> is_invalid =  (root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a3cf4aef5fe9853d7eb9da2fa9ce13d68">viennacl::scheduler::OPERATION_BINARY_INNER_PROD_TYPE</a>)
<a name="l00115"></a>00115                           || (root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4af925022586b9fd60539c3e37ff00f4e5">viennacl::scheduler::OPERATION_BINARY_MAT_MAT_PROD_TYPE</a>)
<a name="l00116"></a>00116                           || (descriptor.type_family==<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a447d7210ff7e3597cc4d24d26f30a5e3">VECTOR_REDUCE_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a369b1f0ad2c9de8c615a5bf43667dd79">viennacl::scheduler::OPERATION_BINARY_MAT_VEC_PROD_TYPE</a>);
<a name="l00117"></a>00117           <span class="keywordflow">if</span>(is_invalid){
<a name="l00118"></a>00118             descriptor.type_family=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a>;
<a name="l00119"></a>00119             descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa0c9d88cab8c5980f26826a4bcc04b25a">INVALID_EXPRESSION_TYPE</a>;
<a name="l00120"></a>00120           }
<a name="l00121"></a>00121           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a369b1f0ad2c9de8c615a5bf43667dd79">viennacl::scheduler::OPERATION_BINARY_MAT_VEC_PROD_TYPE</a>){
<a name="l00122"></a>00122             descriptor.type_family=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a447d7210ff7e3597cc4d24d26f30a5e3">VECTOR_REDUCE_FAMILY</a>;
<a name="l00123"></a>00123             <span class="keywordflow">if</span>(is_lhs_flow_transposed(statement,root_node))
<a name="l00124"></a>00124               descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa9d911c0deb2e861640a91b1be9eb3d2e">VECTOR_REDUCE_Tx_TYPE</a>;
<a name="l00125"></a>00125             <span class="keywordflow">else</span>
<a name="l00126"></a>00126               descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa8bd66b44ba82c53362a171434b0ed063">VECTOR_REDUCE_Nx_TYPE</a>;
<a name="l00127"></a>00127           }
<a name="l00128"></a>00128           <span class="keywordflow">if</span>(descriptor.type_family!=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00129"></a>00129             fill_expression_descriptor_vector(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>],descriptor);
<a name="l00130"></a>00130           <span class="keywordflow">if</span>(descriptor.type_family!=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00131"></a>00131             fill_expression_descriptor_vector(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>],descriptor);
<a name="l00132"></a>00132         }
<a name="l00133"></a>00133 
<a name="l00135"></a>00135         <span class="keyword">static</span> <span class="keywordtype">void</span> fill_expression_descriptor_matrix(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node, expression_descriptor &amp; descriptor){
<a name="l00136"></a>00136           <a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a87693159a33a82fd76f7eecf9b7d7a5a">viennacl::scheduler::statement::container_type</a> <span class="keyword">const</span> &amp; expr = statement.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>();
<a name="l00137"></a>00137           <span class="keywordtype">bool</span> is_invalid =  (root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a3cf4aef5fe9853d7eb9da2fa9ce13d68">viennacl::scheduler::OPERATION_BINARY_INNER_PROD_TYPE</a>)
<a name="l00138"></a>00138                           || (root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4a369b1f0ad2c9de8c615a5bf43667dd79">viennacl::scheduler::OPERATION_BINARY_MAT_VEC_PROD_TYPE</a>)
<a name="l00139"></a>00139                           || (descriptor.type_family==<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3ac7dccd976c045e851404e936a23b6234">MATRIX_PRODUCT_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a> == <a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4af925022586b9fd60539c3e37ff00f4e5">viennacl::scheduler::OPERATION_BINARY_MAT_MAT_PROD_TYPE</a>);
<a name="l00140"></a>00140           <span class="keywordflow">if</span>(is_invalid){
<a name="l00141"></a>00141             descriptor.type_family=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a>;
<a name="l00142"></a>00142             descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa0c9d88cab8c5980f26826a4bcc04b25a">INVALID_EXPRESSION_TYPE</a>;
<a name="l00143"></a>00143           }
<a name="l00144"></a>00144           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a97bda6059c17fd92adafdb6d6b347466">op</a>.<a class="code" href="structviennacl_1_1scheduler_1_1op__element.html#a25606a003bea1558deea8d2857eb6fbd">type</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ac13b2126e8e16b21da5ba7f6e493eab4af925022586b9fd60539c3e37ff00f4e5">viennacl::scheduler::OPERATION_BINARY_MAT_MAT_PROD_TYPE</a>){
<a name="l00145"></a>00145             descriptor.type_family=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3ac7dccd976c045e851404e936a23b6234">MATRIX_PRODUCT_FAMILY</a>;
<a name="l00146"></a>00146             <span class="keywordtype">bool</span> lhs_trans = is_lhs_flow_transposed(statement,root_node);
<a name="l00147"></a>00147             <span class="keywordtype">bool</span> rhs_trans = is_rhs_flow_transposed(statement,root_node);
<a name="l00148"></a>00148             <span class="keywordflow">if</span>(!lhs_trans &amp;&amp; !rhs_trans)
<a name="l00149"></a>00149               descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa3323f571b6e463aa7aa89b32373f5a68">MATRIX_PRODUCT_NN_TYPE</a>;
<a name="l00150"></a>00150             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lhs_trans &amp;&amp; !rhs_trans)
<a name="l00151"></a>00151               descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fab2265bfe0fe73b402649467fc037875c">MATRIX_PRODUCT_TN_TYPE</a>;
<a name="l00152"></a>00152             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!lhs_trans &amp;&amp; rhs_trans)
<a name="l00153"></a>00153               descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0faa3295282a22e6bfc52f9bc35fb860c8f">MATRIX_PRODUCT_NT_TYPE</a>;
<a name="l00154"></a>00154             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lhs_trans &amp;&amp; rhs_trans)
<a name="l00155"></a>00155               descriptor.type=<a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa665b6cdcbe8363ae74d761e857ea9cd3">MATRIX_PRODUCT_TT_TYPE</a>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157           }
<a name="l00158"></a>00158           <span class="keywordflow">if</span>(descriptor.type_family!=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00159"></a>00159             fill_expression_descriptor_matrix(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>],descriptor);
<a name="l00160"></a>00160           <span class="keywordflow">if</span>(descriptor.type_family!=<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a> &amp;&amp; root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3feb1e98d523ae047102e492f07adb3">viennacl::scheduler::COMPOSITE_OPERATION_FAMILY</a>)
<a name="l00161"></a>00161             fill_expression_descriptor_matrix(statement, expr[root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a49beb20b6be53a7fac782ce5c19c475d">rhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#aac0686b9e3c49df87602e150c866617a">node_index</a>],descriptor);
<a name="l00162"></a>00162         }
<a name="l00163"></a>00163 
<a name="l00165"></a>00165         <span class="keywordtype">void</span> fill_descriptor(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">viennacl::scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node, expression_descriptor &amp; descriptor){
<a name="l00166"></a>00166           <a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7" title="Groups the type of a node in the statement tree. Used for faster dispatching.">viennacl::scheduler::statement_node_type_family</a> lhs_family = root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>.<a class="code" href="structviennacl_1_1scheduler_1_1lhs__rhs__element.html#a8443c0968a0e3abc6a5e8c9d832f159e">type_family</a>;
<a name="l00167"></a>00167           descriptor.scalartype_size = utils::call_on_element(root_node.<a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html#a9ae7db89436657da77a1357e7c66fa2d">lhs</a>, utils::scalartype_size_fun());
<a name="l00168"></a>00168           <span class="keywordflow">if</span>(lhs_family==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7adf69e5e6d4ee5adf4da6b2253bce396f">viennacl::scheduler::VECTOR_TYPE_FAMILY</a>){
<a name="l00169"></a>00169             descriptor.type_family = <a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3af8c9f96c831a12845bb7453e69bb5b52">VECTOR_SAXPY_FAMILY</a>;
<a name="l00170"></a>00170             descriptor.type = <a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa742a598acd10447fb31dc50d05e94dee">VECTOR_SAXPY_TYPE</a>;
<a name="l00171"></a>00171             fill_expression_descriptor_vector(statement,root_node,descriptor);
<a name="l00172"></a>00172           }
<a name="l00173"></a>00173           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lhs_family==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7abb040e7e148aef5df0296614d114eb37">viennacl::scheduler::MATRIX_TYPE_FAMILY</a>){
<a name="l00174"></a>00174             descriptor.type_family = <a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a7803a9666dfc80695d365acb4cbd3242">MATRIX_SAXPY_FAMILY</a>;
<a name="l00175"></a>00175             descriptor.type = <a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa3f483c9b08600cdae8473685f127ed8e">MATRIX_SAXPY_TYPE</a>;
<a name="l00176"></a>00176             fill_expression_descriptor_matrix(statement,root_node,descriptor);
<a name="l00177"></a>00177           }
<a name="l00178"></a>00178           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(lhs_family==<a class="code" href="namespaceviennacl_1_1scheduler.html#ade8ae1bb446892d57f7349019e1918c7ac3c6256ad435200835c357bdad503b49">viennacl::scheduler::SCALAR_TYPE_FAMILY</a>){
<a name="l00179"></a>00179             descriptor.type_family = <a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a4272ea65161b9460e3cea9d951f14be8">SCALAR_SAXPY_FAMILY</a>;
<a name="l00180"></a>00180             descriptor.type = <a class="code" href="namespaceviennacl_1_1generator.html#a5a6601c4e142145f0e87051cb21ece0fa190865129b99b15d97b6a574b2ed2184">SCALAR_SAXPY_TYPE</a>;
<a name="l00181"></a>00181             fill_expression_descriptor_scalar(statement,root_node,descriptor);
<a name="l00182"></a>00182           }
<a name="l00183"></a>00183         }
<a name="l00184"></a>00184 
<a name="l00189"></a>00189         <span class="keyword">template</span>&lt;<span class="keyword">class</span> StatementsType&gt;
<a name="l00190"></a>00190         <span class="keywordtype">void</span> set_expression_arguments(profile_base <span class="keyword">const</span> &amp; profile, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> device_offset, StatementsType <span class="keyword">const</span> &amp; statements, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; kernel_id, <a class="code" href="classviennacl_1_1ocl_1_1program.html" title="Wrapper class for an OpenCL program.">viennacl::ocl::program</a> &amp; p, std::list&lt;viennacl::ocl::kernel *&gt; &amp; kernels)<span class="keyword"> const </span>{
<a name="l00191"></a>00191           <span class="keywordflow">for</span>(<a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> i = 0 ; i &lt; profile.num_kernels() ; ++i){
<a name="l00192"></a>00192             <span class="comment">//add kernel name</span>
<a name="l00193"></a>00193             <span class="keywordtype">char</span> str[32];
<a name="l00194"></a>00194             std::sprintf(str,<span class="stringliteral">&quot;kernel_%d_%d&quot;</span>,device_offset,kernel_id);
<a name="l00195"></a>00195             <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; kernel = p.<a class="code" href="classviennacl_1_1ocl_1_1program.html#a58ceaeb3c95170bf8082f80023849ff7" title="Returns the kernel with the provided name.">get_kernel</a>(str);
<a name="l00196"></a>00196             kernels.push_back(&amp;kernel);
<a name="l00197"></a>00197             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_arg = 0;
<a name="l00198"></a>00198             <span class="comment">//Configure ND Range and enqueue arguments</span>
<a name="l00199"></a>00199             profile.configure_range_enqueue_arguments(i, statements, kernel, current_arg);
<a name="l00200"></a>00200             std::set&lt;void *&gt; memory;
<a name="l00201"></a>00201             <span class="keywordflow">for</span>(<span class="keyword">typename</span> StatementsType::const_iterator it = statements.begin() ; it != statements.end() ; ++it){
<a name="l00202"></a>00202               detail::traverse(it-&gt;first, it-&gt;second, detail::set_arguments_functor(memory,current_arg,kernel));
<a name="l00203"></a>00203             }
<a name="l00204"></a>00204             ++kernel_id;
<a name="l00205"></a>00205           }
<a name="l00206"></a>00206         }
<a name="l00207"></a>00207 
<a name="l00209"></a>00209         profile_base <span class="keyword">const</span> &amp; get_profile(<a class="code" href="classviennacl_1_1ocl_1_1device.html" title="A class representing a compute device (e.g. a GPU)">viennacl::ocl::device</a> <span class="keyword">const</span> &amp; device, expression_descriptor <span class="keyword">const</span> &amp; descriptor)<span class="keyword"> const </span>{
<a name="l00210"></a>00210           forced_profiles_type::const_iterator it = forced_profiles_.find(std::make_pair(descriptor.type, descriptor.scalartype_size));
<a name="l00211"></a>00211           <span class="keywordflow">if</span>(it != forced_profiles_.end())
<a name="l00212"></a>00212             <span class="keywordflow">return</span> *it-&gt;second;
<a name="l00213"></a>00213           <span class="keywordflow">return</span> *profiles::get(device,descriptor);
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216       <span class="keyword">public</span>:
<a name="l00217"></a>00217 
<a name="l00219"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#aeb50b791664fcfed74c3a7bfc8abc91b">00219</a>         <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#aeb50b791664fcfed74c3a7bfc8abc91b" title="The constructor.">code_generator</a>(<a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> <span class="keyword">const</span> &amp; ctx = <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>()) : ctx_(ctx){
<a name="l00220"></a>00220           statements_.reserve(16);
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 
<a name="l00224"></a>00224         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00225"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a7551ba480d404d4d88b4d6050ae4d734">00225</a>         <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a7551ba480d404d4d88b4d6050ae4d734" title="Force the generator to use a specific profile for an operation.">force_profile</a>(<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8c5fa5bac74cbea8b879286843c30f94" title="typedef of the key used in the forced profiles. Contains the expression type and the size of the scal...">forced_profile_key_type</a> key, T <span class="keyword">const</span> &amp; t){
<a name="l00226"></a>00226           forced_profiles_.insert(std::pair&lt;<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8c5fa5bac74cbea8b879286843c30f94" title="typedef of the key used in the forced profiles. Contains the expression type and the size of the scal...">forced_profile_key_type</a>, <a class="code" href="classviennacl_1_1tools_1_1shared__ptr.html" title="A shared pointer class similar to boost::shared_ptr. Reimplemented in order to avoid a Boost-dependen...">tools::shared_ptr&lt;profile_base&gt;</a> &gt;(key, <a class="code" href="classviennacl_1_1tools_1_1shared__ptr.html" title="A shared pointer class similar to boost::shared_ptr. Reimplemented in order to avoid a Boost-dependen...">tools::shared_ptr&lt;profile_base&gt;</a>(<span class="keyword">new</span> T(t))));
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228 
<a name="l00232"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a9ddd7407adf1f521b0d0073d93e66f48">00232</a>         <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a9ddd7407adf1f521b0d0073d93e66f48" title="Add a statement and the root node to the expression list.">add</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">scheduler::statement</a> <span class="keyword">const</span> &amp; statement, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node) {
<a name="l00233"></a>00233           <a class="code" href="structviennacl_1_1generator_1_1expression__descriptor.html" title="A class for holding meta information such as the type or the underlying scalar type of an expression ...">expression_descriptor</a> descriptor;
<a name="l00234"></a>00234           fill_descriptor(statement, root_node, descriptor);
<a name="l00235"></a>00235           <span class="keywordflow">if</span>(descriptor.<a class="code" href="structviennacl_1_1generator_1_1expression__descriptor.html#a8cef792370e2753e5b7706536b840c50">type_family</a>==<a class="code" href="namespaceviennacl_1_1generator.html#a19c1a72a23d77b510cbdbbd84c8e4ad3a5d3bd6179100bd3be514cca73e465961">INVALID_EXPRESSION_FAMILY</a>)
<a name="l00236"></a>00236             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00237"></a>00237           <span class="keywordflow">if</span>(statements_.empty())
<a name="l00238"></a>00238             statements_.push_back(std::make_pair(descriptor,<a class="code" href="classviennacl_1_1generator_1_1profile__base.html#af833ec2692839d44d165f323ba583001">profile_base::statements_type</a>(1,std::make_pair(statement, root_node))));
<a name="l00239"></a>00239           <span class="keywordflow">else</span>
<a name="l00240"></a>00240             <span class="keywordflow">if</span>(statements_.back().first == descriptor)
<a name="l00241"></a>00241               statements_.back().second.push_back(std::make_pair(statement, root_node));
<a name="l00242"></a>00242             <span class="keywordflow">else</span>
<a name="l00243"></a>00243               statements_.push_back(std::make_pair(descriptor,<a class="code" href="classviennacl_1_1generator_1_1profile__base.html#af833ec2692839d44d165f323ba583001">profile_base::statements_type</a>(1,std::make_pair(statement, root_node))));
<a name="l00244"></a>00244           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246 
<a name="l00248"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8df41ce45d4d309fa96f8e70f1d84048">00248</a>         <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8df41ce45d4d309fa96f8e70f1d84048" title="Set the arguments for a program previously generated by the generator and fills the kernels...">configure_program</a>(<a class="code" href="classviennacl_1_1ocl_1_1program.html" title="Wrapper class for an OpenCL program.">viennacl::ocl::program</a> &amp; p, std::list&lt;viennacl::ocl::kernel *&gt; &amp; kernels)<span class="keyword"> const </span>{
<a name="l00249"></a>00249           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kernel_id = 0;
<a name="l00250"></a>00250           std::vector&lt;viennacl::ocl::device&gt;::const_iterator found = std::find(ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().begin(),ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().end(),ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#ad1be9bca91f95427bc2875827baadab4" title="Returns the current device.">current_device</a>());
<a name="l00251"></a>00251           <span class="keywordflow">for</span>(statements_type::const_iterator it = statements_.begin() ; it != statements_.end() ; ++it)
<a name="l00252"></a>00252             set_expression_arguments(get_profile(ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#ad1be9bca91f95427bc2875827baadab4" title="Returns the current device.">current_device</a>(), it-&gt;first), static_cast&lt;unsigned int&gt;(std::distance(ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().begin(), found)), it-&gt;second, kernel_id, p, kernels);
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254 
<a name="l00256"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a4623d1b06a1912753e748f0778232873">00256</a>         <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a4623d1b06a1912753e748f0778232873" title="Creates an identifier string for the set of expressions in the object.">make_program_name</a>(<span class="keywordtype">char</span> * program_name)<span class="keyword"> const </span>{
<a name="l00257"></a>00257           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_arg = 0;
<a name="l00258"></a>00258           <span class="keywordtype">void</span>* memory[64] = {NULL};
<a name="l00259"></a>00259           <span class="keywordflow">for</span>(statements_type::const_iterator it = statements_.begin() ; it != statements_.end() ; ++it){
<a name="l00260"></a>00260             <span class="keywordflow">for</span>(profile_base::statements_type::const_iterator iit = it-&gt;second.begin() ; iit != it-&gt;second.end() ; ++iit){
<a name="l00261"></a>00261               detail::traverse(iit-&gt;first, iit-&gt;second, <a class="code" href="classviennacl_1_1generator_1_1detail_1_1statement__representation__functor.html" title="Helper class for the OpenCL kernel generator, representing a statement.">detail::statement_representation_functor</a>(memory, current_arg, program_name));
<a name="l00262"></a>00262             }
<a name="l00263"></a>00263           }
<a name="l00264"></a>00264           *program_name=<span class="charliteral">&#39;\0&#39;</span>;
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266 
<a name="l00268"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#ab4ae2567342ebc08df449110098ab033">00268</a>         std::string <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#ab4ae2567342ebc08df449110098ab033" title="Creates the OpenCL program string from the set of expressions in the object.">make_opencl_program_string</a>()<span class="keyword"> const </span>{
<a name="l00269"></a>00269           <a class="code" href="classviennacl_1_1generator_1_1utils_1_1kernel__generation__stream.html" title="A stream class where the kernel sources are streamed to. Takes care of indentation of the sources...">utils::kernel_generation_stream</a> stream;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271           <span class="comment">//Headers generation</span>
<a name="l00272"></a>00272           stream &lt;&lt; <span class="stringliteral">&quot;#if defined(cl_khr_fp64)\n&quot;</span>;
<a name="l00273"></a>00273           stream &lt;&lt;  <span class="stringliteral">&quot;#  pragma OPENCL EXTENSION cl_khr_fp64: enable\n&quot;</span>;
<a name="l00274"></a>00274           stream &lt;&lt;  <span class="stringliteral">&quot;#elif defined(cl_amd_fp64)\n&quot;</span>;
<a name="l00275"></a>00275           stream &lt;&lt;  <span class="stringliteral">&quot;#  pragma OPENCL EXTENSION cl_amd_fp64: enable\n&quot;</span>;
<a name="l00276"></a>00276           stream &lt;&lt;  <span class="stringliteral">&quot;#endif\n&quot;</span>;
<a name="l00277"></a>00277           stream &lt;&lt; std::endl;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> device_offset =0;
<a name="l00280"></a>00280           <span class="keywordflow">for</span>(std::vector&lt;viennacl::ocl::device&gt;::const_iterator it = ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().begin() ; it != ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().end() ; ++it)
<a name="l00281"></a>00281             <span class="keywordflow">for</span>(statements_type::const_iterator iit = statements_.begin() ; iit != statements_.end() ; ++iit)
<a name="l00282"></a>00282               get_profile(*it,iit-&gt;first)(stream,device_offset++,iit-&gt;second);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284           <span class="keywordflow">return</span> stream.<a class="code" href="classviennacl_1_1generator_1_1utils_1_1kernel__generation__stream.html#a615ccd723733653b9e6a2d72563f1cab">str</a>();
<a name="l00285"></a>00285         }
<a name="l00286"></a>00286 
<a name="l00291"></a><a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8ffc73a6e7ceefc3d1ed3bba00383c74">00291</a>         std::string <a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8ffc73a6e7ceefc3d1ed3bba00383c74" title="Creates the CUDA device code from the set of expressions in the object.">make_cuda_program_string</a>()<span class="keyword"> const </span>{
<a name="l00292"></a>00292           <span class="comment">//Creates OpenCL string with #ifdef and attributes</span>
<a name="l00293"></a>00293           <a class="code" href="classviennacl_1_1generator_1_1utils_1_1kernel__generation__stream.html" title="A stream class where the kernel sources are streamed to. Takes care of indentation of the sources...">utils::kernel_generation_stream</a> stream;
<a name="l00294"></a>00294           <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> device_offset =0;
<a name="l00295"></a>00295           <span class="keywordflow">for</span>(std::vector&lt;viennacl::ocl::device&gt;::const_iterator it = ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().begin() ; it != ctx_.<a class="code" href="classviennacl_1_1ocl_1_1context.html#acd464974135d4def89834832207da4b9" title="Returns a vector with all devices in this context.">devices</a>().end() ; ++it)
<a name="l00296"></a>00296             <span class="keywordflow">for</span>(statements_type::const_iterator iit = statements_.begin() ; iit != statements_.end() ; ++iit)
<a name="l00297"></a>00297               get_profile(*it,iit-&gt;first)(stream,device_offset++,iit-&gt;second);
<a name="l00298"></a>00298           std::string res = stream.<a class="code" href="classviennacl_1_1generator_1_1utils_1_1kernel__generation__stream.html#a615ccd723733653b9e6a2d72563f1cab">str</a>();
<a name="l00299"></a>00299 
<a name="l00300"></a>00300           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;__attribute__&quot;</span>,<span class="stringliteral">&quot;//__attribute__&quot;</span>);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302           <span class="comment">//Pointer</span>
<a name="l00303"></a>00303           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res, <span class="stringliteral">&quot;__global float*&quot;</span>, <span class="stringliteral">&quot;float*&quot;</span>);
<a name="l00304"></a>00304           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res, <span class="stringliteral">&quot;__local float*&quot;</span>, <span class="stringliteral">&quot;float*&quot;</span>);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res, <span class="stringliteral">&quot;__global double*&quot;</span>, <span class="stringliteral">&quot;double*&quot;</span>);
<a name="l00307"></a>00307           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res, <span class="stringliteral">&quot;__local double*&quot;</span>, <span class="stringliteral">&quot;double*&quot;</span>);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309           <span class="comment">//Qualifiers</span>
<a name="l00310"></a>00310           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;__global&quot;</span>,<span class="stringliteral">&quot;__device__&quot;</span>);
<a name="l00311"></a>00311           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;__kernel&quot;</span>,<span class="stringliteral">&quot;__global__&quot;</span>);
<a name="l00312"></a>00312           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;__constant&quot;</span>,<span class="stringliteral">&quot;__constant__&quot;</span>);
<a name="l00313"></a>00313           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;__local&quot;</span>,<span class="stringliteral">&quot;__shared__&quot;</span>);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315           <span class="comment">//Indexing</span>
<a name="l00316"></a>00316           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_num_groups(0)&quot;</span>,<span class="stringliteral">&quot;gridDim.x&quot;</span>);
<a name="l00317"></a>00317           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_num_groups(1)&quot;</span>,<span class="stringliteral">&quot;gridDim.y&quot;</span>);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_local_size(0)&quot;</span>,<span class="stringliteral">&quot;blockDim.x&quot;</span>);
<a name="l00320"></a>00320           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_local_size(1)&quot;</span>,<span class="stringliteral">&quot;blockDim.y&quot;</span>);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_group_id(0)&quot;</span>,<span class="stringliteral">&quot;blockIdx.x&quot;</span>);
<a name="l00323"></a>00323           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_group_id(1)&quot;</span>,<span class="stringliteral">&quot;blockIdx.y&quot;</span>);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_local_id(0)&quot;</span>,<span class="stringliteral">&quot;threadIdx.x&quot;</span>);
<a name="l00326"></a>00326           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_local_id(1)&quot;</span>,<span class="stringliteral">&quot;threadIdx.y&quot;</span>);
<a name="l00327"></a>00327 
<a name="l00328"></a>00328           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_global_id(0)&quot;</span>,<span class="stringliteral">&quot;(blockIdx.x*blockDim.x + threadIdx.x)&quot;</span>);
<a name="l00329"></a>00329           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;get_global_id(1)&quot;</span>,<span class="stringliteral">&quot;(blockIdx.y*blockDim.y + threadIdx.y)&quot;</span>);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331           <span class="comment">//Synchronization</span>
<a name="l00332"></a>00332           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;barrier(CLK_LOCAL_MEM_FENCE)&quot;</span>,<span class="stringliteral">&quot;__syncthreads()&quot;</span>);
<a name="l00333"></a>00333           <a class="code" href="namespaceviennacl_1_1tools.html#abbf7abeae5d6de9edeb5d8460d4fe831" title="Replace in a source string a pattern by another.">viennacl::tools::find_and_replace</a>(res,<span class="stringliteral">&quot;barrier(CLK_GLOBAL_MEM_FENCE)&quot;</span>,<span class="stringliteral">&quot;__syncthreads()&quot;</span>);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 
<a name="l00336"></a>00336           <span class="keywordflow">return</span> res;
<a name="l00337"></a>00337         }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339       <span class="keyword">private</span>:
<a name="l00340"></a>00340         statements_type statements_;
<a name="l00341"></a>00341         <a class="code" href="classviennacl_1_1ocl_1_1context.html" title="Manages an OpenCL context and provides the respective convenience functions for creating buffers...">viennacl::ocl::context</a> <span class="keyword">const</span> &amp; ctx_;
<a name="l00342"></a>00342         forced_profiles_type forced_profiles_;
<a name="l00343"></a>00343     };
<a name="l00344"></a>00344 
<a name="l00351"></a><a class="code" href="namespaceviennacl_1_1generator.html#a0018e4229efa6bb79238a784aa9d4ff8">00351</a>     <span class="keyword">inline</span> <a class="code" href="classviennacl_1_1ocl_1_1program.html" title="Wrapper class for an OpenCL program.">viennacl::ocl::program</a> &amp; <a class="code" href="namespaceviennacl_1_1generator.html#a0018e4229efa6bb79238a784aa9d4ff8" title="Creates the program associated with a generator object and fills the kernels. Checks the context for ...">get_configured_program</a>(<a class="code" href="classviennacl_1_1generator_1_1code__generator.html" title="Class for handling code generation.">viennacl::generator::code_generator</a> <span class="keyword">const</span> &amp; generator, std::list&lt;viennacl::ocl::kernel*&gt; &amp; kernels, <span class="keywordtype">bool</span> force_recompilation = <span class="keyword">false</span>){
<a name="l00352"></a>00352       <span class="keywordtype">char</span>* program_name = <span class="keyword">new</span> <span class="keywordtype">char</span>[256];
<a name="l00353"></a>00353       generator.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a4623d1b06a1912753e748f0778232873" title="Creates an identifier string for the set of expressions in the object.">make_program_name</a>(program_name);
<a name="l00354"></a>00354       <span class="keywordflow">if</span>(force_recompilation)
<a name="l00355"></a>00355         <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a5f2aee6423a51faa240a8e28cd90a65c" title="Delete the program with the provided name.">delete_program</a>(program_name);
<a name="l00356"></a>00356       <span class="keywordflow">if</span>(!<a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().has_program(program_name)){
<a name="l00357"></a>00357         std::string source_code = generator.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#ab4ae2567342ebc08df449110098ab033" title="Creates the OpenCL program string from the set of expressions in the object.">make_opencl_program_string</a>();
<a name="l00358"></a>00358 <span class="preprocessor">    #ifdef VIENNACL_DEBUG_BUILD</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Building &quot;</span> &lt;&lt; program_name &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; std::endl;
<a name="l00360"></a>00360         std::cout &lt;&lt; source_code &lt;&lt; std::endl;
<a name="l00361"></a>00361 <span class="preprocessor">    #endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>        <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a87c0fbb40f4ee1928c72dbf8d19512bb" title="Adds a program to the context.">add_program</a>(source_code, program_name);
<a name="l00363"></a>00363       }
<a name="l00364"></a>00364       <a class="code" href="classviennacl_1_1ocl_1_1program.html" title="Wrapper class for an OpenCL program.">viennacl::ocl::program</a> &amp; p = <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a9258b6b0121e6f1bebe7b83b9e2a625a" title="Returns the program with the provided name.">get_program</a>(program_name);
<a name="l00365"></a>00365       generator.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8df41ce45d4d309fa96f8e70f1d84048" title="Set the arguments for a program previously generated by the generator and fills the kernels...">configure_program</a>(p, kernels);
<a name="l00366"></a>00366       <span class="keyword">delete</span>[] program_name;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368       <span class="keywordflow">return</span> p;
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370 
<a name="l00372"></a><a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92">00372</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">enqueue</a>(<a class="code" href="classviennacl_1_1generator_1_1code__generator.html" title="Class for handling code generation.">viennacl::generator::code_generator</a> <span class="keyword">const</span> &amp; generator, <span class="keywordtype">bool</span> force_recompilation = <span class="keyword">false</span>){
<a name="l00373"></a>00373       std::list&lt;viennacl::ocl::kernel*&gt; kernels;
<a name="l00374"></a>00374       <a class="code" href="namespaceviennacl_1_1generator.html#a0018e4229efa6bb79238a784aa9d4ff8" title="Creates the program associated with a generator object and fills the kernels. Checks the context for ...">get_configured_program</a>(generator, kernels, force_recompilation);
<a name="l00375"></a>00375       <span class="keywordflow">for</span>(std::list&lt;viennacl::ocl::kernel*&gt;::iterator it = kernels.begin() ; it != kernels.end() ; ++it){
<a name="l00376"></a>00376         <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::ocl::enqueue</a>(**it, (*it)-&gt;context().get_queue());
<a name="l00377"></a>00377       }
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 
<a name="l00381"></a><a class="code" href="namespaceviennacl_1_1generator.html#a3ba251aa7bf9b43ef1f86952b73576b6">00381</a>     <span class="keyword">inline</span> std::string <a class="code" href="namespaceviennacl_1_1generator.html#a3ba251aa7bf9b43ef1f86952b73576b6" title="Convenience function to get the OpenCL program string for a single statement.">get_opencl_program_string</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; s){
<a name="l00382"></a>00382       <a class="code" href="classviennacl_1_1generator_1_1code__generator.html" title="Class for handling code generation.">generator::code_generator</a> gen;
<a name="l00383"></a>00383       gen.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a9ddd7407adf1f521b0d0073d93e66f48" title="Add a statement and the root node to the expression list.">add</a>(s,s.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>()[0]);
<a name="l00384"></a>00384       <span class="keywordflow">return</span> gen.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#ab4ae2567342ebc08df449110098ab033" title="Creates the OpenCL program string from the set of expressions in the object.">make_opencl_program_string</a>();
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386 
<a name="l00388"></a><a class="code" href="namespaceviennacl_1_1generator.html#aff28dddb1750ecbb35b47feb93e8758b">00388</a>     <span class="keyword">inline</span> std::string <a class="code" href="namespaceviennacl_1_1generator.html#aff28dddb1750ecbb35b47feb93e8758b" title="Convenience function to get the CUDA device code for a single statement.">get_cuda_device_code</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; s){
<a name="l00389"></a>00389       <a class="code" href="classviennacl_1_1generator_1_1code__generator.html" title="Class for handling code generation.">generator::code_generator</a> gen;
<a name="l00390"></a>00390       gen.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a9ddd7407adf1f521b0d0073d93e66f48" title="Add a statement and the root node to the expression list.">add</a>(s, s.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>()[0]);
<a name="l00391"></a>00391       <span class="keywordflow">return</span> gen.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a8ffc73a6e7ceefc3d1ed3bba00383c74" title="Creates the CUDA device code from the set of expressions in the object.">make_cuda_program_string</a>();
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393 
<a name="l00395"></a><a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f">00395</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">generate_enqueue_statement</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; s, <a class="code" href="structviennacl_1_1scheduler_1_1statement__node.html" title="Main datastructure for an node in the statement tree.">scheduler::statement_node</a> <span class="keyword">const</span> &amp; root_node){
<a name="l00396"></a>00396       <a class="code" href="classviennacl_1_1generator_1_1code__generator.html" title="Class for handling code generation.">generator::code_generator</a> gen;
<a name="l00397"></a>00397       gen.<a class="code" href="classviennacl_1_1generator_1_1code__generator.html#a9ddd7407adf1f521b0d0073d93e66f48" title="Add a statement and the root node to the expression list.">add</a>(s,root_node);
<a name="l00398"></a>00398       <a class="code" href="namespaceviennacl_1_1generator.html#a483735b7cc2c67baead03bf73936cc92" title="Set the arguments and enqueue a generator object.">viennacl::generator::enqueue</a>(gen);
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400 
<a name="l00402"></a><a class="code" href="namespaceviennacl_1_1generator.html#a069aa58cfafd60c9fd14f95e15c359a9">00402</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">generate_enqueue_statement</a>(<a class="code" href="classviennacl_1_1scheduler_1_1statement.html" title="The main class for representing a statement such as x = inner_prod(y,z); at runtime.">viennacl::scheduler::statement</a> <span class="keyword">const</span> &amp; s){
<a name="l00403"></a>00403       <a class="code" href="namespaceviennacl_1_1generator.html#aae6216b72af1dbb3698bf7c77293ba9f" title="Generate and enqueue a statement plus root_node into the current queue.">generate_enqueue_statement</a>(s, s.<a class="code" href="classviennacl_1_1scheduler_1_1statement.html#a14055c27a0adb77a5bd9df8845d33ecc">array</a>()[0]);
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   }
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 15 2014 22:19:33 for ViennaCL - The Vienna Computing Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
